var tipuesearch = {"pages":[{"title":" Charge Migration ","text":"Charge Migration Fortran code for the calculation of the charge migration in molecules. Interfaced with Python's DensityPy library.","tags":"home","loc":"index.html"},{"title":"zTraceFunction – Charge Migration","text":"function zTraceFunction(zA) result(zTrace) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: zA (:,:) Return Value complex(kind=kind(1d0))","tags":"","loc":"proc/ztracefunction.html"},{"title":"LiouvillianPropagator – Charge Migration","text":"subroutine LiouvillianPropagator(L0_Eval, L0_LEvec, L0_REvec, zStatRho) The central routine in simulating the dynamics of a quantum system subject to an external field, describing the time evolution of the system in Liouville space.\n Build the time-independent Lindblad superoperator Where: is the time derivative of the density matrix. represents the commutator of the Hamiltonian and the density matrix , which is the standard von Neumann equation describing the unitary evolution of the system, the Liouvillian. (L_{mn}) are the Lindblad (or jump) operators. These represent the different ways the environment can affect the system, leading to decoherence and relaxation. The terms with describe the action of the environment on the system, and thus are responsible for transitions induced by the bath. The terms with and subtract off double-counted terms and ensure the trace of the density matrix remains equal to 1. Behaving as \"decoherence\" processes where the system's off-diagonal elements (coherences) are diminished due to interactions with the environment. For pure dephasing without relaxation: For relaxation without pure dephasing: subject to the constraint where Key steps in the subroutine: Transform the initial density matrix zStatRho into Liouville space. Propagate the transformed matrix in the absence of external fields for a time interval dt/2. Convert the propagated matrix back into Hilbert space. Consider the system's interaction with an external electric field by applying rotations in the Hilbert space. Diagonalize the density matrix to determine the pure states it comprises. Propagate each individual state under the influence of the external field. Re-form the density matrix from the propagated pure states. Repeat steps 1-3 for the re-formed density matrix to complete the propagation process over the time interval dt. Notes: This subroutine heavily relies on various matrix operations and makes use of other subroutines such as HilbertToLiouvilleMatrix, ZGEMV, LiouvilleToHilbertMatrix, DiagonalizeDipole, ZGEMM, Short_ZHEEV, and ExternalElectricFieldCart, which are not defined within this subroutine and are expected to be defined elsewhere. Important to note is that certain variables used within this subroutine, such as dt, t, iSim, train, Z1, Zi, Z0, nStates, and Dmat, are not defined or passed as arguments, implying that they are either global variables or passed from a higher-level routine that calls this function. The FIRST_CALL logical variable is used to execute certain lines of code only during the first invocation of the subroutine, primarily for the allocation and initialization of arrays. This subroutine effectively encapsulates a single iteration or time step of the simulation. For a complete simulation over a given time period, this subroutine would typically be called repeatedly in a loop. Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: L0_Eval (:) a complex array holding the eigenvalues of the Liouville operator. complex(kind=kind(1d0)), intent(in) :: L0_LEvec (:,:) a complex array holding the left eigenvectors of the Liouville operator. complex(kind=kind(1d0)), intent(in) :: L0_REvec (:,:) a complex array holding the right eigenvectors of the Liouville operator. complex(kind=kind(1d0)), intent(inout) :: zStatRho (:,:) a complex array holding the initial state density matrix of the quantum system. The array is updated within the subroutine, and hence is an input/output parameter. Calls proc~~liouvillianpropagator~~CallsGraph proc~liouvillianpropagator ChargeMigration::LiouvillianPropagator externalelectricfieldcart externalelectricfieldcart proc~liouvillianpropagator->externalelectricfieldcart proc~diagonalizedipole ChargeMigration::DiagonalizeDipole proc~liouvillianpropagator->proc~diagonalizedipole proc~hilberttoliouvillematrix ChargeMigration::HilbertToLiouvilleMatrix proc~liouvillianpropagator->proc~hilberttoliouvillematrix proc~liouvilletohilbertmatrix ChargeMigration::LiouvilleToHilbertMatrix proc~liouvillianpropagator->proc~liouvilletohilbertmatrix short_zheev short_zheev proc~liouvillianpropagator->short_zheev zgemm zgemm proc~liouvillianpropagator->zgemm zgemv zgemv proc~liouvillianpropagator->zgemv short_diag short_diag proc~diagonalizedipole->short_diag proc~hilberttoliouvilleindexes ChargeMigration::HilbertToLiouvilleIndexes proc~hilberttoliouvillematrix->proc~hilberttoliouvilleindexes proc~liouvilletohilbertmatrix->proc~hilberttoliouvilleindexes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~liouvillianpropagator~~CalledByGraph proc~liouvillianpropagator ChargeMigration::LiouvillianPropagator program~chargemigration ChargeMigration program~chargemigration->proc~liouvillianpropagator Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/liouvillianpropagator.html"},{"title":"ComputeLiouvillian_0 – Charge Migration","text":"subroutine ComputeLiouvillian_0(Evec, Dmat, Liouvillian0, bath_temperature, dephasing_factor, relaxation_factor) Calculates the time-independent Lindblad superoperator (Liouvillian), a crucial element in the Lindblad master equation, used for describing the time evolution of the density matrix of a quantum system in an open quantum system framework. Key steps in the subroutine:\n* First, the subroutine initializes parameters and allocates space for the Liouvillian.\n* The unitary part of the Liouvillian is computed, based on the system Hamiltonian eigenvalues.\n* The subroutine calculates the pair relaxation rates and the dephasing rates for all pairs of states, taking into account the energy levels, dipole moment matrix, and input parameters related to dephasing and relaxation.\n* The total relaxation rate for each state is computed as the sum of the pair relaxation rates involving the state.\n* Finally, the dissipative part of the Liouvillian, capturing the effects of the interaction of the system with its environment, is computed based on these relaxation rates. Note: Please note that this subroutine computes the Lindblad superoperator for a specific case where the relaxation and dephasing rates are assumed to be constants and the Lindblad operators are assumed to be proportional to the dipole moment operator. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: Evec (:) The array of energy eigenvalues of the system's Hamiltonian. real(kind=kind(1d0)), intent(in) :: Dmat (:,:,:) The dipole moment matrix of the system. complex(kind=kind(1d0)), intent(out), allocatable :: Liouvillian0 (:,:) The computed Liouvillian superoperator. It's an output parameter that's updated in the subroutine. real(kind=kind(1d0)), intent(in) :: bath_temperature The temperature of the bath or environment interacting with the quantum system. real(kind=kind(1d0)), intent(in) :: dephasing_factor The factor representing dephasing effects in the system. real(kind=kind(1d0)), intent(in) :: relaxation_factor The factor representing relaxation effects in the system. Calls proc~~computeliouvillian_0~~CallsGraph proc~computeliouvillian_0 ChargeMigration::ComputeLiouvillian_0 proc~hilberttoliouvilleindexes ChargeMigration::HilbertToLiouvilleIndexes proc~computeliouvillian_0->proc~hilberttoliouvilleindexes proc~liouvilletohilbertindexes ChargeMigration::LiouvilleToHilbertIndexes proc~computeliouvillian_0->proc~liouvilletohilbertindexes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~computeliouvillian_0~~CalledByGraph proc~computeliouvillian_0 ChargeMigration::ComputeLiouvillian_0 program~chargemigration ChargeMigration program~chargemigration->proc~computeliouvillian_0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/computeliouvillian_0.html"},{"title":"DiagonalizeLindblad_0 – Charge Migration","text":"subroutine DiagonalizeLindblad_0(Liouvillian0, L0_Eval, L0_LEvec, L0_REvec) Performs the diagonalization of the time-independent\nLindblad superoperator (Liouvillian0). The diagonalization is performed using the\nShort_Diag subroutine, and the results are printed to the standard output.\nThis routine also checks that the product of right and conjugate transpose of left eigenvectors\nis an identity matrix (a necessary condition for a valid diagonalization). Note: The input matrix Liouvillian0 is also modified during the execution of this subroutine. Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(inout) :: Liouvillian0 (:,:) A complex square matrix representing the Lindblad superoperator to be diagonalized. complex(kind=kind(1d0)), intent(out), allocatable :: L0_Eval (:) A complex vector that will hold the eigenvalues of Liouvillian0. complex(kind=kind(1d0)), intent(out), allocatable :: L0_LEvec (:,:) A complex square matrix that will hold the left eigenvectors of Liouvillian0. complex(kind=kind(1d0)), intent(out), allocatable :: L0_REvec (:,:) A complex square matrix that will hold the right eigenvectors of Liouvillian0. Calls proc~~diagonalizelindblad_0~~CallsGraph proc~diagonalizelindblad_0 ChargeMigration::DiagonalizeLindblad_0 short_diag short_diag proc~diagonalizelindblad_0->short_diag zgemm zgemm proc~diagonalizelindblad_0->zgemm Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~diagonalizelindblad_0~~CalledByGraph proc~diagonalizelindblad_0 ChargeMigration::DiagonalizeLindblad_0 program~chargemigration ChargeMigration program~chargemigration->proc~diagonalizelindblad_0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/diagonalizelindblad_0.html"},{"title":"HilbertToLiouvilleMatrix – Charge Migration","text":"subroutine HilbertToLiouvilleMatrix(RhoMat, RhoVec) Transforms a matrix from Hilbert space into a vector\nin Liouville space. The transformation is performed by looping through each element of the input\nmatrix and mapping it to the corresponding position in the output vector using the subroutine\nHilbertToLiouvilleIndexes. This transformation is required for the application of the Liouville operator. Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: RhoMat (:,:) A complex matrix representing the state in Hilbert space. complex(kind=kind(1d0)), intent(out) :: RhoVec (:) A complex vector representing the transformed state in Liouville space. Calls proc~~hilberttoliouvillematrix~~CallsGraph proc~hilberttoliouvillematrix ChargeMigration::HilbertToLiouvilleMatrix proc~hilberttoliouvilleindexes ChargeMigration::HilbertToLiouvilleIndexes proc~hilberttoliouvillematrix->proc~hilberttoliouvilleindexes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hilberttoliouvillematrix~~CalledByGraph proc~hilberttoliouvillematrix ChargeMigration::HilbertToLiouvilleMatrix proc~liouvillianpropagator ChargeMigration::LiouvillianPropagator proc~liouvillianpropagator->proc~hilberttoliouvillematrix program~chargemigration ChargeMigration program~chargemigration->proc~liouvillianpropagator Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/hilberttoliouvillematrix.html"},{"title":"LiouvilleToHilbertMatrix – Charge Migration","text":"subroutine LiouvilleToHilbertMatrix(RhoVec, RhoMat) Performs the inverse transformation of\nHilbertToLiouvilleMatrix, transforming a vector in Liouville space back into a matrix in\nHilbert space. The transformation is performed by looping through each element of the output matrix\nand assigning it the corresponding value from the input vector using the subroutine\nHilbertToLiouvilleIndexes. Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: RhoVec (:) A complex vector representing the state in Liouville space. complex(kind=kind(1d0)), intent(out) :: RhoMat (:,:) A complex matrix representing the transformed state in Hilbert space. Calls proc~~liouvilletohilbertmatrix~~CallsGraph proc~liouvilletohilbertmatrix ChargeMigration::LiouvilleToHilbertMatrix proc~hilberttoliouvilleindexes ChargeMigration::HilbertToLiouvilleIndexes proc~liouvilletohilbertmatrix->proc~hilberttoliouvilleindexes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~liouvilletohilbertmatrix~~CalledByGraph proc~liouvilletohilbertmatrix ChargeMigration::LiouvilleToHilbertMatrix proc~liouvillianpropagator ChargeMigration::LiouvillianPropagator proc~liouvillianpropagator->proc~liouvilletohilbertmatrix program~chargemigration ChargeMigration program~chargemigration->proc~liouvillianpropagator Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/liouvilletohilbertmatrix.html"},{"title":"HilbertToLiouvilleIndexes – Charge Migration","text":"subroutine HilbertToLiouvilleIndexes(i, j, iPair) Transforms matrix indices in Hilbert space into a\nsingle index in Liouville space. The transformation is dependent on the relative values of the\ninput indices. The resulting single index is required for the transformation from Hilbert to\nLiouville space. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Integers representing the indices in Hilbert space. integer, intent(in) :: j Integers representing the indices in Hilbert space. integer, intent(out) :: iPair An integer representing the corresponding single index in Liouville space. Called by proc~~hilberttoliouvilleindexes~~CalledByGraph proc~hilberttoliouvilleindexes ChargeMigration::HilbertToLiouvilleIndexes proc~computeliouvillian_0 ChargeMigration::ComputeLiouvillian_0 proc~computeliouvillian_0->proc~hilberttoliouvilleindexes proc~hilberttoliouvillematrix ChargeMigration::HilbertToLiouvilleMatrix proc~hilberttoliouvillematrix->proc~hilberttoliouvilleindexes proc~liouvilletohilbertmatrix ChargeMigration::LiouvilleToHilbertMatrix proc~liouvilletohilbertmatrix->proc~hilberttoliouvilleindexes proc~liouvillianpropagator ChargeMigration::LiouvillianPropagator proc~liouvillianpropagator->proc~hilberttoliouvillematrix proc~liouvillianpropagator->proc~liouvilletohilbertmatrix program~chargemigration ChargeMigration program~chargemigration->proc~computeliouvillian_0 program~chargemigration->proc~liouvillianpropagator Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/hilberttoliouvilleindexes.html"},{"title":"LiouvilleToHilbertIndexes – Charge Migration","text":"subroutine LiouvilleToHilbertIndexes(iPair, i, j) Takes in a single integer index in Liouville space\nand converts it into a pair of matrix indices in Hilbert space. The indices are calculated by\ndecomposing the given Liouville index into a square plus a remainder, which are then used to\ncalculate the corresponding Hilbert indices. Arguments Type Intent Optional Attributes Name integer, intent(in) :: iPair An integer representing a single index in Liouville space. integer, intent(out) :: i Integers representing the corresponding indices in Hilbert space. integer, intent(out) :: j Integers representing the corresponding indices in Hilbert space. Called by proc~~liouvilletohilbertindexes~~CalledByGraph proc~liouvilletohilbertindexes ChargeMigration::LiouvilleToHilbertIndexes proc~computeliouvillian_0 ChargeMigration::ComputeLiouvillian_0 proc~computeliouvillian_0->proc~liouvilletohilbertindexes program~chargemigration ChargeMigration program~chargemigration->proc~computeliouvillian_0 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/liouvilletohilbertindexes.html"},{"title":"DiagonalizeDipole – Charge Migration","text":"subroutine DiagonalizeDipole(Dmat, EVEC_DX, zUMAT_DX, EVEC_DY, zUMAT_DY, EVEC_DZ, zUMAT_DZ) input and computes the diagonalized matrices and their eigenvalues. Internal Operations: Allocation of matrices, diagonalization using Short_Diag, and assignment of the resultant matrices and eigenvalues. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: Dmat (:,:,:) Real 3D array representing the dipole moment matrix. real(kind=kind(1d0)), intent(out), allocatable :: EVEC_DX (:) Real 1D arrays for the eigenvalues of the dipoles in X, Y, and Z directions. complex(kind=kind(1d0)), intent(out), allocatable :: zUMAT_DX (:,:) Complex 2D arrays for the diagonalized matrices in X, Y, and Z directions, respectively. real(kind=kind(1d0)), intent(out), allocatable :: EVEC_DY (:) Real 1D arrays for the eigenvalues of the dipoles in X, Y, and Z directions. complex(kind=kind(1d0)), intent(out), allocatable :: zUMAT_DY (:,:) Complex 2D arrays for the diagonalized matrices in X, Y, and Z directions, respectively. real(kind=kind(1d0)), intent(out), allocatable :: EVEC_DZ (:) Real 1D arrays for the eigenvalues of the dipoles in X, Y, and Z directions. complex(kind=kind(1d0)), intent(out), allocatable :: zUMAT_DZ (:,:) Complex 2D arrays for the diagonalized matrices in X, Y, and Z directions, respectively. Calls proc~~diagonalizedipole~~CallsGraph proc~diagonalizedipole ChargeMigration::DiagonalizeDipole short_diag short_diag proc~diagonalizedipole->short_diag Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~diagonalizedipole~~CalledByGraph proc~diagonalizedipole ChargeMigration::DiagonalizeDipole proc~liouvillianpropagator ChargeMigration::LiouvillianPropagator proc~liouvillianpropagator->proc~diagonalizedipole program~chargemigration ChargeMigration program~chargemigration->proc~liouvillianpropagator Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/diagonalizedipole.html"},{"title":"Computevolume – Charge Migration","text":"subroutine Computevolume(nPts, volume, gridv) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPts real(kind=kind(1d0)), intent(out) :: volume real(kind=kind(1d0)), intent(in), allocatable :: gridv (:,:) Called by proc~~computevolume~~CalledByGraph proc~computevolume ChargeMigration::Computevolume program~chargemigration ChargeMigration program~chargemigration->proc~computevolume Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/computevolume.html"},{"title":"Compute_R_el – Charge Migration","text":"subroutine Compute_R_el(gridv, WeightV, OrbTab, R_el) Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in), allocatable :: gridv (:,:) real(kind=kind(1d0)), intent(in), allocatable :: WeightV (:,:) real(kind=kind(1d0)), intent(in), allocatable :: OrbTab (:,:) real(kind=kind(1d0)), intent(out), allocatable :: R_el (:,:) Called by proc~~compute_r_el~~CalledByGraph proc~compute_r_el ChargeMigration::Compute_R_el program~chargemigration ChargeMigration program~chargemigration->proc~compute_r_el Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/compute_r_el.html"},{"title":"AtomicRadius_Bragg_Slater_Becke – Charge Migration","text":"subroutine AtomicRadius_Bragg_Slater_Becke(atom_names, nAtom, Radius_BS) Arguments Type Intent Optional Attributes Name character(len=16), intent(in) :: atom_names (:) integer, intent(in) :: nAtom real(kind=kind(1d0)), intent(out), allocatable :: Radius_BS (:) Calls proc~~atomicradius_bragg_slater_becke~~CallsGraph proc~atomicradius_bragg_slater_becke ChargeMigration::AtomicRadius_Bragg_Slater_Becke proc~radius_table Module_Becke::Radius_Table proc~atomicradius_bragg_slater_becke->proc~radius_table Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~atomicradius_bragg_slater_becke~~CalledByGraph proc~atomicradius_bragg_slater_becke ChargeMigration::AtomicRadius_Bragg_Slater_Becke program~chargemigration ChargeMigration program~chargemigration->proc~atomicradius_bragg_slater_becke Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/atomicradius_bragg_slater_becke.html"},{"title":"ComputeAtomicCharges – Charge Migration","text":"subroutine ComputeAtomicCharges(OrbitalDensity, BeckeMatrix, QchargeVec) Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: OrbitalDensity (:,:) real(kind=kind(1d0)), intent(in) :: BeckeMatrix (:,:,:,:) real(kind=kind(1d0)), intent(out), allocatable :: QchargeVec (:,:) Called by proc~~computeatomiccharges~~CalledByGraph proc~computeatomiccharges ChargeMigration::ComputeAtomicCharges program~chargemigration ChargeMigration program~chargemigration->proc~computeatomiccharges Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/computeatomiccharges.html"},{"title":"ComputeOrbitalDensity – Charge Migration","text":"subroutine ComputeOrbitalDensity(zStatRho, TDM, Amat) Build the expansion Matrix where is the solution of a suitable Master equation, starting from Here, we will neglect relaxation and decoherence and hence where Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: zStatRho (:,:) real(kind=kind(1d0)), intent(in) :: TDM (:,:,:,:) real(kind=kind(1d0)), intent(out), allocatable :: Amat (:,:) Called by proc~~computeorbitaldensity~~CalledByGraph proc~computeorbitaldensity ChargeMigration::ComputeOrbitalDensity program~chargemigration ChargeMigration program~chargemigration->proc~computeorbitaldensity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/computeorbitaldensity.html"},{"title":"ComputeAtomicWeights – Charge Migration","text":"subroutine ComputeAtomicWeights(nPts, gridv, nAtoms, AtCoord, WeightV, Radius_BS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPts real(kind=kind(1d0)), intent(in) :: gridv (:,:) integer, intent(in) :: nAtoms real(kind=kind(1d0)), intent(in) :: AtCoord (:,:) real(kind=kind(1d0)), intent(out), allocatable :: WeightV (:,:) real(kind=kind(1d0)), intent(in) :: Radius_BS (:) Calls proc~~computeatomicweights~~CallsGraph proc~computeatomicweights ChargeMigration::ComputeAtomicWeights proc~wkfun Module_Becke::wkfun proc~computeatomicweights->proc~wkfun proc~pkfuna Module_Becke::Pkfuna proc~wkfun->proc~pkfuna proc~pkfuntot Module_Becke::PkFunTot proc~wkfun->proc~pkfuntot proc~get_param_a Module_Becke::get_param_a proc~pkfuna->proc~get_param_a proc~skfunab Module_Becke::skfunab proc~pkfuna->proc~skfunab proc~pkfuntot->proc~pkfuna proc~ellipticalcoord Module_Becke::EllipticalCoord proc~skfunab->proc~ellipticalcoord proc~new_mu_transformation Module_Becke::new_mu_transformation proc~skfunab->proc~new_mu_transformation proc~skfun Module_Becke::skfun proc~skfunab->proc~skfun proc~eucldist Module_Becke::EuclDist proc~ellipticalcoord->proc~eucldist proc~fkfun Module_Becke::fkfun proc~skfun->proc~fkfun proc~fkfun->proc~fkfun Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~computeatomicweights~~CalledByGraph proc~computeatomicweights ChargeMigration::ComputeAtomicWeights program~chargemigration ChargeMigration program~chargemigration->proc~computeatomicweights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/computeatomicweights.html"},{"title":"TabulateChargeDensity – Charge Migration","text":"subroutine TabulateChargeDensity(Amat, OrbTab, ChDen) Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: Amat (:,:) real(kind=kind(1d0)), intent(in) :: OrbTab (:,:) real(kind=kind(1d0)), intent(out) :: ChDen (:) Called by proc~~tabulatechargedensity~~CalledByGraph proc~tabulatechargedensity ChargeMigration::TabulateChargeDensity program~chargemigration ChargeMigration program~chargemigration->proc~tabulatechargedensity Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/tabulatechargedensity.html"},{"title":"ComputeBeckeMatrix – Charge Migration","text":"subroutine ComputeBeckeMatrix(WeightV, OrbTab, BeckeMatrix, Bary_center) Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: WeightV (:,:) real(kind=kind(1d0)), intent(in) :: OrbTab (:,:) real(kind=kind(1d0)), intent(out), allocatable :: BeckeMatrix (:,:,:,:) real(kind=kind(1d0)), intent(in) :: Bary_center (:,:) Called by proc~~computebeckematrix~~CalledByGraph proc~computebeckematrix ChargeMigration::ComputeBeckeMatrix program~chargemigration ChargeMigration program~chargemigration->proc~computebeckematrix Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/computebeckematrix.html"},{"title":"EuclDist – Charge Migration","text":"public  function EuclDist(avec, bvec) result(res) This function calculates the Euclidean distance between two points in 3D space. The inputs are two 3-component vectors representing the coordinates of the points, and the output is a scalar representing the distance between them. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: avec (3) real(kind=kind(1d0)), intent(in) :: bvec (3) Return Value real(kind=kind(1d0)) Called by proc~~eucldist~~CalledByGraph proc~eucldist Module_Becke::EuclDist proc~ellipticalcoord Module_Becke::EllipticalCoord proc~ellipticalcoord->proc~eucldist proc~skfunab Module_Becke::skfunab proc~skfunab->proc~ellipticalcoord proc~pkfuna Module_Becke::Pkfuna proc~pkfuna->proc~skfunab proc~pkfuntot Module_Becke::PkFunTot proc~pkfuntot->proc~pkfuna proc~wkfun Module_Becke::wkfun proc~wkfun->proc~pkfuna proc~wkfun->proc~pkfuntot proc~computeatomicweights ChargeMigration::ComputeAtomicWeights proc~computeatomicweights->proc~wkfun program~chargemigration ChargeMigration program~chargemigration->proc~computeatomicweights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/eucldist.html"},{"title":"EllipticalCoord – Charge Migration","text":"public  function EllipticalCoord(rvec, avec, bvec) result(res) Eq. 1 This function calculates the elliptical coordinate ( ) of a point relative to two other points (defined as atoms 'a' and 'b'). This coordinate is a measure of how much closer the point is to atom 'a' compared to atom 'b'. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) real(kind=kind(1d0)), intent(in) :: avec (3) real(kind=kind(1d0)), intent(in) :: bvec (3) Return Value real(kind=kind(1d0)) Calls proc~~ellipticalcoord~~CallsGraph proc~ellipticalcoord Module_Becke::EllipticalCoord proc~eucldist Module_Becke::EuclDist proc~ellipticalcoord->proc~eucldist Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ellipticalcoord~~CalledByGraph proc~ellipticalcoord Module_Becke::EllipticalCoord proc~skfunab Module_Becke::skfunab proc~skfunab->proc~ellipticalcoord proc~pkfuna Module_Becke::Pkfuna proc~pkfuna->proc~skfunab proc~pkfuntot Module_Becke::PkFunTot proc~pkfuntot->proc~pkfuna proc~wkfun Module_Becke::wkfun proc~wkfun->proc~pkfuna proc~wkfun->proc~pkfuntot proc~computeatomicweights ChargeMigration::ComputeAtomicWeights proc~computeatomicweights->proc~wkfun program~chargemigration ChargeMigration program~chargemigration->proc~computeatomicweights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/ellipticalcoord.html"},{"title":"Radius_Table – Charge Migration","text":"public  function Radius_Table(Atomic_Name) result(Atomic_Radius) Radius_Table for atomic radius based on atomic name\nThis function provides the atomic radius based on the atomic name. The input is a string representing the atomic name and the output is the corresponding atomic radius. This is useful for defining the size of atoms in molecular modelling. Arguments Type Intent Optional Attributes Name character(len=16), intent(in) :: Atomic_Name Return Value real(kind=kind(1d0)) Called by proc~~radius_table~~CalledByGraph proc~radius_table Module_Becke::Radius_Table proc~atomicradius_bragg_slater_becke ChargeMigration::AtomicRadius_Bragg_Slater_Becke proc~atomicradius_bragg_slater_becke->proc~radius_table program~chargemigration ChargeMigration program~chargemigration->proc~atomicradius_bragg_slater_becke Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/radius_table.html"},{"title":"get_param_a – Charge Migration","text":"public  function get_param_a(R_i, R_j) result(a_ij) This function calculates the parameter 'a' ( ) which depends on the radii of two atoms. This parameter is used in the transformation of the elliptical coordinate. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: R_i real(kind=kind(1d0)), intent(in) :: R_j Return Value real(kind=kind(1d0)) Called by proc~~get_param_a~~CalledByGraph proc~get_param_a Module_Becke::get_param_a proc~pkfuna Module_Becke::Pkfuna proc~pkfuna->proc~get_param_a proc~pkfuntot Module_Becke::PkFunTot proc~pkfuntot->proc~pkfuna proc~wkfun Module_Becke::wkfun proc~wkfun->proc~pkfuna proc~wkfun->proc~pkfuntot proc~computeatomicweights ChargeMigration::ComputeAtomicWeights proc~computeatomicweights->proc~wkfun program~chargemigration ChargeMigration program~chargemigration->proc~computeatomicweights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/get_param_a.html"},{"title":"new_mu_transformation – Charge Migration","text":"public  function new_mu_transformation(mu, a_ij) result(res) This function transforms the elliptical coordinate using the parameter 'a' ( ). This transformation is used to handle cases where the point is much closer to one atom than the other. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: mu real(kind=kind(1d0)), intent(in) :: a_ij Return Value real(kind=kind(1d0)) Called by proc~~new_mu_transformation~~CalledByGraph proc~new_mu_transformation Module_Becke::new_mu_transformation proc~skfunab Module_Becke::skfunab proc~skfunab->proc~new_mu_transformation proc~pkfuna Module_Becke::Pkfuna proc~pkfuna->proc~skfunab proc~pkfuntot Module_Becke::PkFunTot proc~pkfuntot->proc~pkfuna proc~wkfun Module_Becke::wkfun proc~wkfun->proc~pkfuna proc~wkfun->proc~pkfuntot proc~computeatomicweights ChargeMigration::ComputeAtomicWeights proc~computeatomicweights->proc~wkfun program~chargemigration ChargeMigration program~chargemigration->proc~computeatomicweights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/new_mu_transformation.html"},{"title":"fkfun – Charge Migration","text":"public recursive function fkfun(mu, k) result(res) Eq. 4 Recursive This function calculates a recursive function of the transformed elliptical coordinate. The output of this function will be used in the calculation of the step function skfun. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: mu integer, intent(in) :: k Return Value real(kind=kind(1d0)) Called by proc~~fkfun~~CalledByGraph proc~fkfun Module_Becke::fkfun proc~fkfun->proc~fkfun proc~skfun Module_Becke::skfun proc~skfun->proc~fkfun proc~skfunab Module_Becke::skfunab proc~skfunab->proc~skfun proc~pkfuna Module_Becke::Pkfuna proc~pkfuna->proc~skfunab proc~pkfuntot Module_Becke::PkFunTot proc~pkfuntot->proc~pkfuna proc~wkfun Module_Becke::wkfun proc~wkfun->proc~pkfuna proc~wkfun->proc~pkfuntot proc~computeatomicweights ChargeMigration::ComputeAtomicWeights proc~computeatomicweights->proc~wkfun program~chargemigration ChargeMigration program~chargemigration->proc~computeatomicweights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/fkfun.html"},{"title":"skfun – Charge Migration","text":"public  function skfun(mu, k) result(res) (Step Function)\nThis function calculates a step function of the transformed elliptical coordinate. This function maps the transformed elliptical coordinate from the range [-1,1] to [0,1]. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: mu integer, intent(in) :: k Return Value real(kind=kind(1d0)) Calls proc~~skfun~~CallsGraph proc~skfun Module_Becke::skfun proc~fkfun Module_Becke::fkfun proc~skfun->proc~fkfun proc~fkfun->proc~fkfun Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~skfun~~CalledByGraph proc~skfun Module_Becke::skfun proc~skfunab Module_Becke::skfunab proc~skfunab->proc~skfun proc~pkfuna Module_Becke::Pkfuna proc~pkfuna->proc~skfunab proc~pkfuntot Module_Becke::PkFunTot proc~pkfuntot->proc~pkfuna proc~wkfun Module_Becke::wkfun proc~wkfun->proc~pkfuna proc~wkfun->proc~pkfuntot proc~computeatomicweights ChargeMigration::ComputeAtomicWeights proc~computeatomicweights->proc~wkfun program~chargemigration ChargeMigration program~chargemigration->proc~computeatomicweights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/skfun.html"},{"title":"skfunab – Charge Migration","text":"public  function skfunab(rvec, avec, bvec, k, a_ij) result(res) This function combines the calculations of the transformed elliptical coordinate and the step function. The output of this function will be used in the calculation of the partial partition function Pkfuna. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) real(kind=kind(1d0)), intent(in) :: avec (3) real(kind=kind(1d0)), intent(in) :: bvec (3) integer, intent(in) :: k real(kind=kind(1d0)) :: a_ij Return Value real(kind=kind(1d0)) Calls proc~~skfunab~~CallsGraph proc~skfunab Module_Becke::skfunab proc~ellipticalcoord Module_Becke::EllipticalCoord proc~skfunab->proc~ellipticalcoord proc~new_mu_transformation Module_Becke::new_mu_transformation proc~skfunab->proc~new_mu_transformation proc~skfun Module_Becke::skfun proc~skfunab->proc~skfun proc~eucldist Module_Becke::EuclDist proc~ellipticalcoord->proc~eucldist proc~fkfun Module_Becke::fkfun proc~skfun->proc~fkfun proc~fkfun->proc~fkfun Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~skfunab~~CalledByGraph proc~skfunab Module_Becke::skfunab proc~pkfuna Module_Becke::Pkfuna proc~pkfuna->proc~skfunab proc~pkfuntot Module_Becke::PkFunTot proc~pkfuntot->proc~pkfuna proc~wkfun Module_Becke::wkfun proc~wkfun->proc~pkfuna proc~wkfun->proc~pkfuntot proc~computeatomicweights ChargeMigration::ComputeAtomicWeights proc~computeatomicweights->proc~wkfun program~chargemigration ChargeMigration program~chargemigration->proc~computeatomicweights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/skfunab.html"},{"title":"Pkfuna – Charge Migration","text":"public  function Pkfuna(rvec, iAtom, AtCoord, nAtoms, k, Radius_BS) result(res) Eq. 2 , nominator of Eq. 3\nThis function calculates the partial partition function for a specific atom. The output of this function represents the contribution of a specific atom to the total partition function. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) integer, intent(in) :: iAtom real(kind=kind(1d0)), intent(in) :: AtCoord (3,nAtoms) integer, intent(in) :: nAtoms integer, intent(in) :: k real(kind=kind(1d0)), intent(in) :: Radius_BS (:) Return Value real(kind=kind(1d0)) Calls proc~~pkfuna~~CallsGraph proc~pkfuna Module_Becke::Pkfuna proc~get_param_a Module_Becke::get_param_a proc~pkfuna->proc~get_param_a proc~skfunab Module_Becke::skfunab proc~pkfuna->proc~skfunab proc~ellipticalcoord Module_Becke::EllipticalCoord proc~skfunab->proc~ellipticalcoord proc~new_mu_transformation Module_Becke::new_mu_transformation proc~skfunab->proc~new_mu_transformation proc~skfun Module_Becke::skfun proc~skfunab->proc~skfun proc~eucldist Module_Becke::EuclDist proc~ellipticalcoord->proc~eucldist proc~fkfun Module_Becke::fkfun proc~skfun->proc~fkfun proc~fkfun->proc~fkfun Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~pkfuna~~CalledByGraph proc~pkfuna Module_Becke::Pkfuna proc~pkfuntot Module_Becke::PkFunTot proc~pkfuntot->proc~pkfuna proc~wkfun Module_Becke::wkfun proc~wkfun->proc~pkfuna proc~wkfun->proc~pkfuntot proc~computeatomicweights ChargeMigration::ComputeAtomicWeights proc~computeatomicweights->proc~wkfun program~chargemigration ChargeMigration program~chargemigration->proc~computeatomicweights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/pkfuna.html"},{"title":"PkFunTot – Charge Migration","text":"public  function PkFunTot(rvec, AtCoord, nAtoms, k, Radius_BS) result(res) Eq. 3 in the denominator\nThis function calculates the total partition function. This is done by summing the partial partition functions for all atoms. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) real(kind=kind(1d0)), intent(in) :: AtCoord (3,nAtoms) integer, intent(in) :: nAtoms integer, intent(in) :: k real(kind=kind(1d0)), intent(in) :: Radius_BS (:) Return Value real(kind=kind(1d0)) Calls proc~~pkfuntot~~CallsGraph proc~pkfuntot Module_Becke::PkFunTot proc~pkfuna Module_Becke::Pkfuna proc~pkfuntot->proc~pkfuna proc~get_param_a Module_Becke::get_param_a proc~pkfuna->proc~get_param_a proc~skfunab Module_Becke::skfunab proc~pkfuna->proc~skfunab proc~ellipticalcoord Module_Becke::EllipticalCoord proc~skfunab->proc~ellipticalcoord proc~new_mu_transformation Module_Becke::new_mu_transformation proc~skfunab->proc~new_mu_transformation proc~skfun Module_Becke::skfun proc~skfunab->proc~skfun proc~eucldist Module_Becke::EuclDist proc~ellipticalcoord->proc~eucldist proc~fkfun Module_Becke::fkfun proc~skfun->proc~fkfun proc~fkfun->proc~fkfun Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~pkfuntot~~CalledByGraph proc~pkfuntot Module_Becke::PkFunTot proc~wkfun Module_Becke::wkfun proc~wkfun->proc~pkfuntot proc~computeatomicweights ChargeMigration::ComputeAtomicWeights proc~computeatomicweights->proc~wkfun program~chargemigration ChargeMigration program~chargemigration->proc~computeatomicweights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/pkfuntot.html"},{"title":"wkfun – Charge Migration","text":"public  function wkfun(rvec, iAtom, AtCoord, nAtoms, k, Radius_BS) result(res) Eq. 3 $w_a \\vec(r)$  (WEIGHTS)\nThis function calculates the weight of an atom. The weight is defined as the ratio of the partial partition function of the atom to the total partition function. This weight represents the relative importance of the atom. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) integer, intent(in) :: iAtom real(kind=kind(1d0)), intent(in) :: AtCoord (3,nAtoms) integer, intent(in) :: nAtoms integer, intent(in) :: k real(kind=kind(1d0)), intent(in) :: Radius_BS (:) Return Value real(kind=kind(1d0)) Calls proc~~wkfun~~CallsGraph proc~wkfun Module_Becke::wkfun proc~pkfuna Module_Becke::Pkfuna proc~wkfun->proc~pkfuna proc~pkfuntot Module_Becke::PkFunTot proc~wkfun->proc~pkfuntot proc~get_param_a Module_Becke::get_param_a proc~pkfuna->proc~get_param_a proc~skfunab Module_Becke::skfunab proc~pkfuna->proc~skfunab proc~pkfuntot->proc~pkfuna proc~ellipticalcoord Module_Becke::EllipticalCoord proc~skfunab->proc~ellipticalcoord proc~new_mu_transformation Module_Becke::new_mu_transformation proc~skfunab->proc~new_mu_transformation proc~skfun Module_Becke::skfun proc~skfunab->proc~skfun proc~eucldist Module_Becke::EuclDist proc~ellipticalcoord->proc~eucldist proc~fkfun Module_Becke::fkfun proc~skfun->proc~fkfun proc~fkfun->proc~fkfun Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~wkfun~~CalledByGraph proc~wkfun Module_Becke::wkfun proc~computeatomicweights ChargeMigration::ComputeAtomicWeights proc~computeatomicweights->proc~wkfun program~chargemigration ChargeMigration program~chargemigration->proc~computeatomicweights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/wkfun.html"},{"title":"Set_CD_IO_Verbous – Charge Migration","text":"public  subroutine Set_CD_IO_Verbous(logi) Commons <<! Arguments Type Intent Optional Attributes Name logical, intent(in) :: logi Called by proc~~set_cd_io_verbous~~CalledByGraph proc~set_cd_io_verbous Module_CM_CD_IO::Set_CD_IO_Verbous program~chargemigration ChargeMigration program~chargemigration->proc~set_cd_io_verbous Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/set_cd_io_verbous.html"},{"title":"Write_Summary – Charge Migration","text":"public  subroutine Write_Summary(FileName, nPts, nAtoms, Computed_volume, n_times, t_min, t_max, atom_names, Radius_BS, number_of_orbitals, OrbTab) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(in) :: nPts integer, intent(in) :: nAtoms real(kind=kind(1d0)), intent(in) :: Computed_volume integer, intent(in) :: n_times real(kind=kind(1d0)), intent(in) :: t_min real(kind=kind(1d0)), intent(in) :: t_max character(len=16), intent(in) :: atom_names (:) real(kind=kind(1d0)), intent(in) :: Radius_BS (:) integer, intent(in) :: number_of_orbitals real(kind=kind(1d0)), intent(in) :: OrbTab (:,:) Calls proc~~write_summary~~CallsGraph proc~write_summary Module_CM_CD_IO::Write_Summary assert assert proc~write_summary->assert Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~write_summary~~CalledByGraph proc~write_summary Module_CM_CD_IO::Write_Summary program~chargemigration ChargeMigration program~chargemigration->proc~write_summary Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/write_summary.html"},{"title":"LoadGeometry – Charge Migration","text":"public  subroutine LoadGeometry(nAtoms, AtCoord, FileName, atom_names) Load Subroutines <<!\n Load the position of the atomic nuclei ** Skip to the line specifying the number of atoms\n determine the number of atoms Arguments Type Intent Optional Attributes Name integer, intent(out) :: nAtoms real(kind=kind(1d0)), intent(out), allocatable :: AtCoord (:,:) character(len=*), intent(in) :: FileName character(len=16), intent(out), allocatable :: atom_names (:) Called by proc~~loadgeometry~~CalledByGraph proc~loadgeometry Module_CM_CD_IO::LoadGeometry program~chargemigration ChargeMigration program~chargemigration->proc~loadgeometry Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/loadgeometry.html"},{"title":"LoadEnergies – Charge Migration","text":"public  subroutine LoadEnergies(FileName, nStates, Evec) Uses ModuleErrorHandling ModuleString proc~~loadenergies~~UsesGraph proc~loadenergies Module_CM_CD_IO::LoadEnergies ModuleErrorHandling ModuleErrorHandling proc~loadenergies->ModuleErrorHandling ModuleString ModuleString proc~loadenergies->ModuleString Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Loads the Energies found inside the input_directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(out) :: nStates real(kind=kind(1d0)), intent(out), allocatable :: Evec (:) Calls proc~~loadenergies~~CallsGraph proc~loadenergies Module_CM_CD_IO::LoadEnergies errormessage errormessage proc~loadenergies->errormessage Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~loadenergies~~CalledByGraph proc~loadenergies Module_CM_CD_IO::LoadEnergies program~chargemigration ChargeMigration program~chargemigration->proc~loadenergies Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/loadenergies.html"},{"title":"LoadGrid – Charge Migration","text":"public  subroutine LoadGrid(FileName, npts, gridv) Uses ModuleErrorHandling ModuleString proc~~loadgrid~~UsesGraph proc~loadgrid Module_CM_CD_IO::LoadGrid ModuleErrorHandling ModuleErrorHandling proc~loadgrid->ModuleErrorHandling ModuleString ModuleString proc~loadgrid->ModuleString Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Loads the Grid found inside the input_directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(out) :: npts real(kind=kind(1d0)), intent(out), allocatable :: gridv (:,:) Calls proc~~loadgrid~~CallsGraph proc~loadgrid Module_CM_CD_IO::LoadGrid errormessage errormessage proc~loadgrid->errormessage Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~loadgrid~~CalledByGraph proc~loadgrid Module_CM_CD_IO::LoadGrid program~chargemigration ChargeMigration program~chargemigration->proc~loadgrid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/loadgrid.html"},{"title":"LoadOrbitals – Charge Migration","text":"public  subroutine LoadOrbitals(Dir, number_of_orbitals, npts, OrbTab) Uses ModuleErrorHandling ModuleString proc~~loadorbitals~~UsesGraph proc~loadorbitals Module_CM_CD_IO::LoadOrbitals ModuleErrorHandling ModuleErrorHandling proc~loadorbitals->ModuleErrorHandling ModuleString ModuleString proc~loadorbitals->ModuleString Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Loads the Orbitals found inside the input_directory\nLoads the Orbitals from the grid_density.csv file inside the input_directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Dir integer, intent(in) :: number_of_orbitals integer, intent(in) :: npts real(kind=kind(1d0)), intent(out), allocatable :: OrbTab (:,:) Calls proc~~loadorbitals~~CallsGraph proc~loadorbitals Module_CM_CD_IO::LoadOrbitals assert assert proc~loadorbitals->assert converttostrn converttostrn proc~loadorbitals->converttostrn errormessage errormessage proc~loadorbitals->errormessage stopexecution stopexecution proc~loadorbitals->stopexecution Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~loadorbitals~~CalledByGraph proc~loadorbitals Module_CM_CD_IO::LoadOrbitals program~chargemigration ChargeMigration program~chargemigration->proc~loadorbitals Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/loadorbitals.html"},{"title":"LoadDipoleME – Charge Migration","text":"public  subroutine LoadDipoleME(Dmat, input_directory, nStates) Uses ModuleErrorHandling proc~~loaddipoleme~~UsesGraph proc~loaddipoleme Module_CM_CD_IO::LoadDipoleME ModuleErrorHandling ModuleErrorHandling proc~loaddipoleme->ModuleErrorHandling Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Loads all the Dipoles found inside the input_directory Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(out), allocatable :: Dmat (:,:,:) character(len=*), intent(in) :: input_directory integer, intent(in) :: nStates Calls proc~~loaddipoleme~~CallsGraph proc~loaddipoleme Module_CM_CD_IO::LoadDipoleME errormessage errormessage proc~loaddipoleme->errormessage Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~loaddipoleme~~CalledByGraph proc~loaddipoleme Module_CM_CD_IO::LoadDipoleME program~chargemigration ChargeMigration program~chargemigration->proc~loaddipoleme Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/loaddipoleme.html"},{"title":"LoadTDMs – Charge Migration","text":"public  subroutine LoadTDMs(FileNameDM, FileNameTDM, nStates, number_of_orbitals, TDM) Uses ModuleErrorHandling ModuleString proc~~loadtdms~~UsesGraph proc~loadtdms Module_CM_CD_IO::LoadTDMs ModuleErrorHandling ModuleErrorHandling proc~loadtdms->ModuleErrorHandling ModuleString ModuleString proc~loadtdms->ModuleString Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Loads the TDM found inside the input_directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileNameDM character(len=*), intent(in) :: FileNameTDM integer, intent(in) :: nStates integer, intent(out) :: number_of_orbitals real(kind=kind(1d0)), intent(out), allocatable :: TDM (:,:,:,:) Calls proc~~loadtdms~~CallsGraph proc~loadtdms Module_CM_CD_IO::LoadTDMs errormessage errormessage proc~loadtdms->errormessage Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~loadtdms~~CalledByGraph proc~loadtdms Module_CM_CD_IO::LoadTDMs program~chargemigration ChargeMigration program~chargemigration->proc~loadtdms Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/loadtdms.html"},{"title":"LoadDipoleMO – Charge Migration","text":"public  subroutine LoadDipoleMO(input_directory, number_of_orbitals, ivOrb, MuOrb) Uses ModuleErrorHandling ModuleString proc~~loaddipolemo~~UsesGraph proc~loaddipolemo Module_CM_CD_IO::LoadDipoleMO ModuleErrorHandling ModuleErrorHandling proc~loaddipolemo->ModuleErrorHandling ModuleString ModuleString proc~loaddipolemo->ModuleString Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Loads Dipole Matrix Elements between molecular orbitals\nIDEALLY, SHOULD COMPUTE THE DIPOLE FROM THE AO - AO DIPOLES. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_directory integer, intent(in) :: number_of_orbitals integer, intent(in) :: ivOrb (:) real(kind=kind(1d0)), intent(out), allocatable :: MuOrb (:,:) Calls proc~~loaddipolemo~~CallsGraph proc~loaddipolemo Module_CM_CD_IO::LoadDipoleMO errormessage errormessage proc~loaddipolemo->errormessage Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/loaddipolemo.html"},{"title":"Write_R_el_bc – Charge Migration","text":"public  subroutine Write_R_el_bc(output_directory, atom_names, nAtoms, R_el) Save Subroutines Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: output_directory character(len=16), intent(in), allocatable :: atom_names (:) integer, intent(in) :: nAtoms real(kind=kind(1d0)), intent(in), allocatable :: R_el (:,:) Called by proc~~write_r_el_bc~~CalledByGraph proc~write_r_el_bc Module_CM_CD_IO::Write_R_el_bc program~chargemigration ChargeMigration program~chargemigration->proc~write_r_el_bc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/write_r_el_bc.html"},{"title":"Write_Dipole – Charge Migration","text":"public  subroutine Write_Dipole(FileName, Dipole, n_times, t_min, dt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(in) :: Dipole (:,:) integer, intent(in) :: n_times real(kind=kind(1d0)), intent(in) :: t_min real(kind=kind(1d0)), intent(in) :: dt Called by proc~~write_dipole~~CalledByGraph proc~write_dipole Module_CM_CD_IO::Write_Dipole program~chargemigration ChargeMigration program~chargemigration->proc~write_dipole Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/write_dipole.html"},{"title":"Write_Q_Charge – Charge Migration","text":"public  subroutine Write_Q_Charge(FileName, Charge, n_times, t_min, dt, nAtoms, atom_names) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(in) :: Charge (:,:,:) integer, intent(in) :: n_times real(kind=kind(1d0)), intent(in) :: t_min real(kind=kind(1d0)), intent(in) :: dt integer, intent(in) :: nAtoms character(len=16), intent(in) :: atom_names (:) Called by proc~~write_q_charge~~CalledByGraph proc~write_q_charge Module_CM_CD_IO::Write_Q_Charge program~chargemigration ChargeMigration program~chargemigration->proc~write_q_charge Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/write_q_charge.html"},{"title":"Write_Charge_Density – Charge Migration","text":"public  subroutine Write_Charge_Density(FileName, nPts, gridv, ChDen, Weightv, nAtoms, atom_names) Uses ModuleErrorHandling ModuleString proc~~write_charge_density~~UsesGraph proc~write_charge_density Module_CM_CD_IO::Write_Charge_Density ModuleErrorHandling ModuleErrorHandling proc~write_charge_density->ModuleErrorHandling ModuleString ModuleString proc~write_charge_density->ModuleString Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(in) :: nPts real(kind=kind(1d0)), intent(in), allocatable :: gridv (:,:) real(kind=kind(1d0)), intent(in), allocatable :: ChDen (:) real(kind=kind(1d0)), intent(in), allocatable :: Weightv (:,:) integer, intent(in) :: nAtoms character(len=16), intent(in) :: atom_names (:) Calls proc~~write_charge_density~~CallsGraph proc~write_charge_density Module_CM_CD_IO::Write_Charge_Density errormessage errormessage proc~write_charge_density->errormessage Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~write_charge_density~~CalledByGraph proc~write_charge_density Module_CM_CD_IO::Write_Charge_Density program~chargemigration ChargeMigration program~chargemigration->proc~write_charge_density Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/write_charge_density.html"},{"title":"Write_Weights – Charge Migration","text":"public  subroutine Write_Weights(FileName, WEIGHTV, gridv, nAtoms, nPts, atom_names) Write Weights Subroutine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(in) :: WEIGHTV (:,:) real(kind=kind(1d0)), intent(in) :: gridv (:,:) integer, intent(in) :: nAtoms integer, intent(in) :: nPts character(len=16), intent(in) :: atom_names (:) Called by proc~~write_weights~~CalledByGraph proc~write_weights Module_CM_CD_IO::Write_Weights program~chargemigration ChargeMigration program~chargemigration->proc~write_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/write_weights.html"},{"title":"Read_Weights – Charge Migration","text":"public  subroutine Read_Weights(FileName, WEIGHTV, nAtoms, nPts) Read Weights Subroutine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(out), allocatable :: WEIGHTV (:,:) integer, intent(in) :: nAtoms integer, intent(in) :: nPts Called by proc~~read_weights~~CalledByGraph proc~read_weights Module_CM_CD_IO::Read_Weights program~chargemigration ChargeMigration program~chargemigration->proc~read_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/read_weights.html"},{"title":"Set_CD_IO_Verbous – Charge Migration","text":"public  subroutine Set_CD_IO_Verbous(logi) Arguments Type Intent Optional Attributes Name logical, intent(in) :: logi","tags":"","loc":"proc/set_cd_io_verbous~2.html"},{"title":"LoadGeometry – Charge Migration","text":"public  subroutine LoadGeometry(nAtoms, AtCoord, FileName, atom_names) ** Skip to the line specifying the number of atoms\n determine the number of atoms\n** Skip to the line where the coordinates start to be listed\nallocate the matrix of coordinates Arguments Type Intent Optional Attributes Name integer, intent(out) :: nAtoms real(kind=kind(1d0)), intent(out), allocatable :: AtCoord (:,:) character(len=*), intent(in) :: FileName character(len=16), intent(out), allocatable :: atom_names (:)","tags":"","loc":"proc/loadgeometry~2.html"},{"title":"LoadBidimentioal_Dipole_Spectrum – Charge Migration","text":"public  subroutine LoadBidimentioal_Dipole_Spectrum(FileName, DipoleFTww, TauOmegaVec, OmegaVec, nTauOmegas, nOmegas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(out), allocatable :: DipoleFTww (:,:,:) real(kind=kind(1d0)), intent(in) :: TauOmegaVec (:) real(kind=kind(1d0)), intent(in) :: OmegaVec (:) integer, intent(in) :: nTauOmegas integer, intent(in) :: nOmegas","tags":"","loc":"proc/loadbidimentioal_dipole_spectrum.html"},{"title":"Write_2DReconstructDipole – Charge Migration","text":"public  subroutine Write_2DReconstructDipole(FileName, Dipole, TauOmegaVec, OmegaVec, nTauOmegas, nOmegas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(in) :: Dipole (:,:,:) real(kind=kind(1d0)), intent(in) :: TauOmegaVec (:) real(kind=kind(1d0)), intent(in) :: OmegaVec (:) integer, intent(in) :: nTauOmegas integer, intent(in) :: nOmegas","tags":"","loc":"proc/write_2dreconstructdipole.html"},{"title":"Load_BidimentionalChargeFTww – Charge Migration","text":"public  subroutine Load_BidimentionalChargeFTww(FileName, ChargeFTww_new, TauOmegaVec, OmegaVec, nTauOmegas, nOmegas, nAtoms) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(out), allocatable :: ChargeFTww_new (:,:,:,:) real(kind=kind(1d0)), intent(in) :: TauOmegaVec (:) real(kind=kind(1d0)), intent(in) :: OmegaVec (:) integer, intent(in) :: nTauOmegas integer, intent(in) :: nOmegas integer, intent(in) :: nAtoms","tags":"","loc":"proc/load_bidimentionalchargeftww.html"},{"title":"GetRunTimeParameters – Charge Migration","text":"public  subroutine GetRunTimeParameters(InpDir, OutDir, FileGeometry, StepTime, StepWidth, FieldFile, Verbous, nOmegas, OmegaMin, OmegaMax, nTauOmegas, TauOmegaMin, TauOmegaMax) Uses ModuleErrorHandling ModuleString ModuleCommandLineParameterList proc~~getruntimeparameters~~UsesGraph proc~getruntimeparameters Module_CMFT_RTP::GetRunTimeParameters ModuleCommandLineParameterList ModuleCommandLineParameterList proc~getruntimeparameters->ModuleCommandLineParameterList ModuleErrorHandling ModuleErrorHandling proc~getruntimeparameters->ModuleErrorHandling ModuleString ModuleString proc~getruntimeparameters->ModuleString Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Reads the run time parameters specified in the command line. Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: InpDir character(len=:), intent(out), allocatable :: OutDir character(len=:), intent(out), allocatable :: FileGeometry real(kind=kind(1d0)), intent(out) :: StepTime real(kind=kind(1d0)), intent(out) :: StepWidth character(len=:), intent(out), allocatable :: FieldFile logical, intent(out) :: Verbous integer, intent(out) :: nOmegas real(kind=kind(1d0)), intent(out) :: OmegaMin real(kind=kind(1d0)), intent(out) :: OmegaMax integer, intent(out) :: nTauOmegas real(kind=kind(1d0)), intent(out) :: TauOmegaMin real(kind=kind(1d0)), intent(out) :: TauOmegaMax Calls proc~~getruntimeparameters~~CallsGraph proc~getruntimeparameters Module_CMFT_RTP::GetRunTimeParameters add add proc~getruntimeparameters->add get get proc~getruntimeparameters->get parse parse proc~getruntimeparameters->parse printusage printusage proc~getruntimeparameters->printusage setdescription setdescription proc~getruntimeparameters->setdescription Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~getruntimeparameters~~CalledByGraph proc~getruntimeparameters Module_CMFT_RTP::GetRunTimeParameters program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~getruntimeparameters Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/getruntimeparameters.html"},{"title":"DetermineNumberOfTimes – Charge Migration","text":"subroutine DetermineNumberOfTimes(FileName, tmin, tmax, nTimes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(out) :: tmin real(kind=kind(1d0)), intent(out) :: tmax integer, intent(out) :: nTimes Called by proc~~determinenumberoftimes~~CalledByGraph proc~determinenumberoftimes ChargeMigrationFT::DetermineNumberOfTimes program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~determinenumberoftimes Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/determinenumberoftimes.html"},{"title":"Regularize_XUVDipole – Charge Migration","text":"subroutine Regularize_XUVDipole(XUVDipole, tmin, dt, nTimes, StepTime, StepWidth) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(inout) :: XUVDipole (:,:) real(kind=kind(1d0)), intent(in) :: tmin real(kind=kind(1d0)), intent(in) :: dt integer, intent(in) :: nTimes real(kind=kind(1d0)), intent(in) :: StepTime real(kind=kind(1d0)), intent(in) :: StepWidth Calls proc~~regularize_xuvdipole~~CallsGraph proc~regularize_xuvdipole ChargeMigrationFT::Regularize_XUVDipole ncd_phi ncd_phi proc~regularize_xuvdipole->ncd_phi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~regularize_xuvdipole~~CalledByGraph proc~regularize_xuvdipole ChargeMigrationFT::Regularize_XUVDipole program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~regularize_xuvdipole Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/regularize_xuvdipole.html"},{"title":"Regularize_XUVAtomicCharge – Charge Migration","text":"subroutine Regularize_XUVAtomicCharge(Charge, tmin, dt, nTimes, StepTime, StepWidth) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(inout) :: Charge (:,:,:) real(kind=kind(1d0)), intent(in) :: tmin real(kind=kind(1d0)), intent(in) :: dt integer, intent(in) :: nTimes real(kind=kind(1d0)), intent(in) :: StepTime real(kind=kind(1d0)), intent(in) :: StepWidth Calls proc~~regularize_xuvatomiccharge~~CallsGraph proc~regularize_xuvatomiccharge ChargeMigrationFT::Regularize_XUVAtomicCharge ncd_phi ncd_phi proc~regularize_xuvatomiccharge->ncd_phi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~regularize_xuvatomiccharge~~CalledByGraph proc~regularize_xuvatomiccharge ChargeMigrationFT::Regularize_XUVAtomicCharge program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~regularize_xuvatomiccharge Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/regularize_xuvatomiccharge.html"},{"title":"Regularize_Dipole_and_AtomicCharge1 – Charge Migration","text":"subroutine Regularize_Dipole_and_AtomicCharge1(Dipole, Charge, tmin, dt, nTimes, StepTime, StepWidth) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(inout) :: Dipole (:,:) real(kind=kind(1d0)), intent(inout) :: Charge (:,:,:) real(kind=kind(1d0)), intent(in) :: tmin real(kind=kind(1d0)), intent(in) :: dt integer, intent(in) :: nTimes real(kind=kind(1d0)), intent(in) :: StepTime real(kind=kind(1d0)), intent(in) :: StepWidth Calls proc~~regularize_dipole_and_atomiccharge1~~CallsGraph proc~regularize_dipole_and_atomiccharge1 ChargeMigrationFT::Regularize_Dipole_and_AtomicCharge1 ncd_phi ncd_phi proc~regularize_dipole_and_atomiccharge1->ncd_phi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~regularize_dipole_and_atomiccharge1~~CalledByGraph proc~regularize_dipole_and_atomiccharge1 ChargeMigrationFT::Regularize_Dipole_and_AtomicCharge1 program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~regularize_dipole_and_atomiccharge1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/regularize_dipole_and_atomiccharge1.html"},{"title":"ComputeFT_Dipole_and_AtomicCharges – Charge Migration","text":"subroutine ComputeFT_Dipole_and_AtomicCharges(DipoleFTminus, AtomicChargeFT, Dipole, OmegaVec, AtomicChargeEvolution, tmin, dt, nTimes, nOmegas) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(out) :: DipoleFTminus (:,:) complex(kind=kind(1d0)), intent(out), allocatable :: AtomicChargeFT (:,:,:) complex(kind=kind(1d0)), intent(in) :: Dipole (:,:) real(kind=kind(1d0)), intent(in) :: OmegaVec (:) real(kind=kind(1d0)), intent(in) :: AtomicChargeEvolution (:,:,:) real(kind=kind(1d0)), intent(in) :: tmin real(kind=kind(1d0)), intent(in) :: dt integer, intent(in) :: nTimes integer, intent(in) :: nOmegas Called by proc~~computeft_dipole_and_atomiccharges~~CalledByGraph proc~computeft_dipole_and_atomiccharges ChargeMigrationFT::ComputeFT_Dipole_and_AtomicCharges program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~computeft_dipole_and_atomiccharges Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/computeft_dipole_and_atomiccharges.html"},{"title":"Regularize_Dipole_withRespectto_TimeDelay – Charge Migration","text":"subroutine Regularize_Dipole_withRespectto_TimeDelay(DipoleFTwt, tvec, N_Simulations) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(inout) :: DipoleFTwt (:,:,:) real(kind=kind(1d0)), intent(in) :: tvec (:) integer, intent(in) :: N_Simulations Calls proc~~regularize_dipole_withrespectto_timedelay~~CallsGraph proc~regularize_dipole_withrespectto_timedelay ChargeMigrationFT::Regularize_Dipole_withRespectto_TimeDelay ncd_phi ncd_phi proc~regularize_dipole_withrespectto_timedelay->ncd_phi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~regularize_dipole_withrespectto_timedelay~~CalledByGraph proc~regularize_dipole_withrespectto_timedelay ChargeMigrationFT::Regularize_Dipole_withRespectto_TimeDelay program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~regularize_dipole_withrespectto_timedelay Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/regularize_dipole_withrespectto_timedelay.html"},{"title":"Compute_FTofDipole_withRespectto_Time – Charge Migration","text":"subroutine Compute_FTofDipole_withRespectto_Time(DipoleFTwt, DipoleFTww, tvec, TauOmegaVec, N_Simulations, nTauOmegas) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: DipoleFTwt (:,:,:) complex(kind=kind(1d0)), intent(out), allocatable :: DipoleFTww (:,:,:) real(kind=kind(1d0)), intent(in) :: tvec (:) real(kind=kind(1d0)), intent(in) :: TauOmegaVec (:) integer, intent(in) :: N_Simulations integer, intent(in) :: nTauOmegas Called by proc~~compute_ftofdipole_withrespectto_time~~CalledByGraph proc~compute_ftofdipole_withrespectto_time ChargeMigrationFT::Compute_FTofDipole_withRespectto_Time program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~compute_ftofdipole_withrespectto_time Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/compute_ftofdipole_withrespectto_time.html"},{"title":"Regularize_Charge_withtimedelay – Charge Migration","text":"subroutine Regularize_Charge_withtimedelay(ChargeFTwt, tvec, nAtoms, N_Simulations) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(inout) :: ChargeFTwt (:,:,:,:) real(kind=kind(1d0)), intent(in) :: tvec (:) integer, intent(in) :: nAtoms integer, intent(in) :: N_Simulations Calls proc~~regularize_charge_withtimedelay~~CallsGraph proc~regularize_charge_withtimedelay ChargeMigrationFT::Regularize_Charge_withtimedelay ncd_phi ncd_phi proc~regularize_charge_withtimedelay->ncd_phi Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~regularize_charge_withtimedelay~~CalledByGraph proc~regularize_charge_withtimedelay ChargeMigrationFT::Regularize_Charge_withtimedelay program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~regularize_charge_withtimedelay Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/regularize_charge_withtimedelay.html"},{"title":"Compute_FTCharge_withTimeDelay – Charge Migration","text":"subroutine Compute_FTCharge_withTimeDelay(ChargeFTwt, tvec, ChargeFTww, N_simulations, nOmegas, nAtoms, nTauOmegas, TauOmegaVec) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: ChargeFTwt (:,:,:,:) real(kind=kind(1d0)), intent(in) :: tvec (:) complex(kind=kind(1d0)), intent(out), allocatable :: ChargeFTww (:,:,:,:) integer, intent(in) :: N_simulations integer, intent(in) :: nOmegas integer, intent(in) :: nAtoms integer, intent(in) :: nTauOmegas real(kind=kind(1d0)), intent(in) :: TauOmegaVec (:) Called by proc~~compute_ftcharge_withtimedelay~~CalledByGraph proc~compute_ftcharge_withtimedelay ChargeMigrationFT::Compute_FTCharge_withTimeDelay program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~compute_ftcharge_withtimedelay Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/compute_ftcharge_withtimedelay.html"},{"title":"GetRunTimeParameters – Charge Migration","text":"public  subroutine GetRunTimeParameters(input_directory, output_directory, molecular_geometry_file, n_times, t_min, t_max, FieldFile, Verbous, Weight_File, read_precomputed_weights_flag, save_charge_migration_flag, ivorb, counted_number_of_orbitals, dephasing_factor, relaxation_factor, bath_temperature) Uses ModuleErrorHandling ModuleString ModuleCommandLineParameterList proc~~getruntimeparameters~2~~UsesGraph proc~getruntimeparameters~2 Module_CM_RTP::GetRunTimeParameters ModuleCommandLineParameterList ModuleCommandLineParameterList proc~getruntimeparameters~2->ModuleCommandLineParameterList ModuleErrorHandling ModuleErrorHandling proc~getruntimeparameters~2->ModuleErrorHandling ModuleString ModuleString proc~getruntimeparameters~2->ModuleString Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Reads the run time parameters specified in the command line.\nReads the run time parameters specified in the command line. Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: input_directory character(len=:), intent(out), allocatable :: output_directory character(len=:), intent(out), allocatable :: molecular_geometry_file integer, intent(out) :: n_times real(kind=kind(1d0)), intent(out) :: t_min real(kind=kind(1d0)), intent(out) :: t_max character(len=:), intent(out), allocatable :: FieldFile logical, intent(out) :: Verbous character(len=:), intent(out), allocatable :: Weight_File logical, intent(out) :: read_precomputed_weights_flag logical, intent(out) :: save_charge_migration_flag integer, intent(out), allocatable :: ivorb (:) integer, intent(out) :: counted_number_of_orbitals real(kind=kind(1d0)), intent(out) :: dephasing_factor real(kind=kind(1d0)), intent(out) :: relaxation_factor real(kind=kind(1d0)), intent(out) :: bath_temperature Calls proc~~getruntimeparameters~2~~CallsGraph proc~getruntimeparameters~2 Module_CM_RTP::GetRunTimeParameters add add proc~getruntimeparameters~2->add get get proc~getruntimeparameters~2->get parse parse proc~getruntimeparameters~2->parse printusage printusage proc~getruntimeparameters~2->printusage setdescription setdescription proc~getruntimeparameters~2->setdescription Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~getruntimeparameters~2~~CalledByGraph proc~getruntimeparameters~2 Module_CM_RTP::GetRunTimeParameters program~chargemigration ChargeMigration program~chargemigration->proc~getruntimeparameters~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/getruntimeparameters~2.html"},{"title":"GetRunTimeParameters – Charge Migration","text":"public  subroutine GetRunTimeParameters(InpDir, OutDir, FileGeometry, StepTime, StepWidth, FieldFile, Verbous, nOmegas, OmegaMin, OmegaMax, nTauOmegas, TauOmegaMin, TauOmegaMax) Uses ModuleErrorHandling ModuleString ModuleCommandLineParameterList proc~~getruntimeparameters~3~~UsesGraph proc~getruntimeparameters~3 Module_SR_RTP::GetRunTimeParameters ModuleCommandLineParameterList ModuleCommandLineParameterList proc~getruntimeparameters~3->ModuleCommandLineParameterList ModuleErrorHandling ModuleErrorHandling proc~getruntimeparameters~3->ModuleErrorHandling ModuleString ModuleString proc~getruntimeparameters~3->ModuleString Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Reads the run time parameters specified in the command line. Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: InpDir character(len=:), intent(out), allocatable :: OutDir character(len=:), intent(out), allocatable :: FileGeometry real(kind=kind(1d0)), intent(out) :: StepTime real(kind=kind(1d0)), intent(out) :: StepWidth character(len=:), intent(out), allocatable :: FieldFile logical, intent(out) :: Verbous integer, intent(out) :: nOmegas real(kind=kind(1d0)), intent(out) :: OmegaMin real(kind=kind(1d0)), intent(out) :: OmegaMax integer, intent(out) :: nTauOmegas real(kind=kind(1d0)), intent(out) :: TauOmegaMin real(kind=kind(1d0)), intent(out) :: TauOmegaMax Calls proc~~getruntimeparameters~3~~CallsGraph proc~getruntimeparameters~3 Module_SR_RTP::GetRunTimeParameters add add proc~getruntimeparameters~3->add get get proc~getruntimeparameters~3->get parse parse proc~getruntimeparameters~3->parse printusage printusage proc~getruntimeparameters~3->printusage setdescription setdescription proc~getruntimeparameters~3->setdescription Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/getruntimeparameters~3.html"},{"title":"Set_CD_IO_Verbous – Charge Migration","text":"public  subroutine Set_CD_IO_Verbous(logi) Arguments Type Intent Optional Attributes Name logical, intent(in) :: logi Called by proc~~set_cd_io_verbous~3~~CalledByGraph proc~set_cd_io_verbous~3 Module_CMFT_CD_IO::Set_CD_IO_Verbous program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~set_cd_io_verbous~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/set_cd_io_verbous~3.html"},{"title":"LoadGeometry – Charge Migration","text":"public  subroutine LoadGeometry(nAtoms, AtCoord, FileName, AtomName) Load the position of the atomic nuclei ** Skip to the line specifying the number of atoms\n determine the number of atoms\n** Skip to the line where the coordinates start to be listed\nallocate the matrix of coordinates Arguments Type Intent Optional Attributes Name integer, intent(out) :: nAtoms real(kind=kind(1d0)), intent(out), allocatable :: AtCoord (:,:) character(len=*), intent(in) :: FileName character(len=16), intent(out), allocatable :: AtomName (:) Called by proc~~loadgeometry~3~~CalledByGraph proc~loadgeometry~3 Module_CMFT_CD_IO::LoadGeometry program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~loadgeometry~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/loadgeometry~3.html"},{"title":"LoadEnergies – Charge Migration","text":"public  subroutine LoadEnergies(FileName, nStates, Evec) Uses ModuleErrorHandling ModuleString proc~~loadenergies~2~~UsesGraph proc~loadenergies~2 Module_CMFT_CD_IO::LoadEnergies ModuleErrorHandling ModuleErrorHandling proc~loadenergies~2->ModuleErrorHandling ModuleString ModuleString proc~loadenergies~2->ModuleString Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Loads the Energies found inside the InpDir Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(out) :: nStates real(kind=kind(1d0)), intent(out), allocatable :: Evec (:) Calls proc~~loadenergies~2~~CallsGraph proc~loadenergies~2 Module_CMFT_CD_IO::LoadEnergies errormessage errormessage proc~loadenergies~2->errormessage Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~loadenergies~2~~CalledByGraph proc~loadenergies~2 Module_CMFT_CD_IO::LoadEnergies program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~loadenergies~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/loadenergies~2.html"},{"title":"Load_XUVAtomicCharge – Charge Migration","text":"public  subroutine Load_XUVAtomicCharge(FileName, Charge, nTimes, nAtoms) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(out), allocatable :: Charge (:,:,:) integer, intent(in) :: nTimes integer, intent(in) :: nAtoms Called by proc~~load_xuvatomiccharge~~CalledByGraph proc~load_xuvatomiccharge Module_CMFT_CD_IO::Load_XUVAtomicCharge program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~load_xuvatomiccharge Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/load_xuvatomiccharge.html"},{"title":"Load_Dipole – Charge Migration","text":"public  subroutine Load_Dipole(FileName, Dipole, nTimes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(out), allocatable :: Dipole (:,:) integer, intent(in) :: nTimes Called by proc~~load_dipole~~CalledByGraph proc~load_dipole Module_CMFT_CD_IO::Load_Dipole program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~load_dipole Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/load_dipole.html"},{"title":"Load_Q_Charge_and_Write2ALL – Charge Migration","text":"public  subroutine Load_Q_Charge_and_Write2ALL(FileName, Charge, nTimes, tmin, dt, nAtoms, iSim, atom_names, uid_AtomicChargeALL) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(out), allocatable :: Charge (:,:,:) integer, intent(in) :: nTimes real(kind=kind(1d0)), intent(in) :: tmin real(kind=kind(1d0)), intent(in) :: dt integer, intent(in) :: nAtoms integer, intent(in) :: iSim character(len=16), intent(in) :: atom_names (:) integer, intent(in) :: uid_AtomicChargeALL Called by proc~~load_q_charge_and_write2all~~CalledByGraph proc~load_q_charge_and_write2all Module_CMFT_CD_IO::Load_Q_Charge_and_Write2ALL program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~load_q_charge_and_write2all Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/load_q_charge_and_write2all.html"},{"title":"LoadAtomicCharges – Charge Migration","text":"public  subroutine LoadAtomicCharges(FileName, AtomicChargeEvolution, nTimes, nAtoms, iSim, tmin, dt, uid_AtomicChargeALL) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(out), allocatable :: AtomicChargeEvolution (:,:) integer, intent(in) :: nTimes integer, intent(in) :: nAtoms integer, intent(in) :: iSim real(kind=kind(1d0)), intent(in) :: tmin real(kind=kind(1d0)), intent(in) :: dt integer, intent(in) :: uid_AtomicChargeALL","tags":"","loc":"proc/loadatomiccharges.html"},{"title":"WriteDipoleFTFile – Charge Migration","text":"public  subroutine WriteDipoleFTFile(FileName, DipoleFTtotal, OmegaVec, nOmegas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(in) :: DipoleFTtotal (:,:) real(kind=kind(1d0)), allocatable :: OmegaVec (:) integer, intent(in) :: nOmegas Called by proc~~writedipoleftfile~~CalledByGraph proc~writedipoleftfile Module_CMFT_CD_IO::WriteDipoleFTFile program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~writedipoleftfile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/writedipoleftfile.html"},{"title":"AppendDipole2FTAllFile – Charge Migration","text":"public  subroutine AppendDipole2FTAllFile(FileName, DipoleFTtotal, OmegaVec, nOmegas, iSim, train) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(in) :: DipoleFTtotal (:,:) real(kind=kind(1d0)) :: OmegaVec (:) integer, intent(in) :: nOmegas integer, intent(in) :: iSim type(pulse_train), intent(in), pointer :: train (:) Calls proc~~appenddipole2ftallfile~~CallsGraph proc~appenddipole2ftallfile Module_CMFT_CD_IO::AppendDipole2FTAllFile p p proc~appenddipole2ftallfile->p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~appenddipole2ftallfile~~CalledByGraph proc~appenddipole2ftallfile Module_CMFT_CD_IO::AppendDipole2FTAllFile program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~appenddipole2ftallfile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/appenddipole2ftallfile.html"},{"title":"WriteAtomicChargeFT – Charge Migration","text":"public  subroutine WriteAtomicChargeFT(FileName, AtomicChargeFT, OmegaVec, nOmegas, nAtoms, AtomName) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(in) :: AtomicChargeFT (:,:,:) real(kind=kind(1d0)) :: OmegaVec (:) integer, intent(in) :: nOmegas integer, intent(in) :: nAtoms character(len=16), intent(in) :: AtomName (:) Called by proc~~writeatomicchargeft~~CalledByGraph proc~writeatomicchargeft Module_CMFT_CD_IO::WriteAtomicChargeFT program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~writeatomicchargeft Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/writeatomicchargeft.html"},{"title":"WriteAllAtomicChargeFTtoSingleFile – Charge Migration","text":"public  subroutine WriteAllAtomicChargeFTtoSingleFile(FileName, AtomicChargeFT_new, OmegaVec, nOmegas, nAtoms, iSim, train, AtomName) Uses ModuleErrorHandling proc~~writeallatomicchargefttosinglefile~~UsesGraph proc~writeallatomicchargefttosinglefile Module_CMFT_CD_IO::WriteAllAtomicChargeFTtoSingleFile ModuleErrorHandling ModuleErrorHandling proc~writeallatomicchargefttosinglefile->ModuleErrorHandling Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)) :: AtomicChargeFT_new (:,:,:) real(kind=kind(1d0)) :: OmegaVec (:) integer, intent(in) :: nOmegas integer, intent(in) :: nAtoms integer, intent(in) :: iSim type(pulse_train), intent(in), pointer :: train (:) character(len=16), intent(in) :: AtomName (:) Calls proc~~writeallatomicchargefttosinglefile~~CallsGraph proc~writeallatomicchargefttosinglefile Module_CMFT_CD_IO::WriteAllAtomicChargeFTtoSingleFile p p proc~writeallatomicchargefttosinglefile->p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~writeallatomicchargefttosinglefile~~CalledByGraph proc~writeallatomicchargefttosinglefile Module_CMFT_CD_IO::WriteAllAtomicChargeFTtoSingleFile program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~writeallatomicchargefttosinglefile Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/writeallatomicchargefttosinglefile.html"},{"title":"LoadFTDipole_asfuncitonof_TimeDelay – Charge Migration","text":"public  subroutine LoadFTDipole_asfuncitonof_TimeDelay(FileName, N_simulations, nOmegas, DipoleFTwt, tvec) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(in) :: N_simulations integer, intent(in) :: nOmegas complex(kind=kind(1d0)), intent(out), allocatable :: DipoleFTwt (:,:,:) real(kind=kind(1d0)), intent(out), allocatable :: tvec (:) Called by proc~~loadftdipole_asfuncitonof_timedelay~~CalledByGraph proc~loadftdipole_asfuncitonof_timedelay Module_CMFT_CD_IO::LoadFTDipole_asfuncitonof_TimeDelay program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~loadftdipole_asfuncitonof_timedelay Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/loadftdipole_asfuncitonof_timedelay.html"},{"title":"SaveBidimentioal_Dipole_Spectrum – Charge Migration","text":"public  subroutine SaveBidimentioal_Dipole_Spectrum(FileName, DipoleFTww, TauOmegaVec, OmegaVec, nTauOmegas, nOmegas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(in) :: DipoleFTww (:,:,:) real(kind=kind(1d0)), intent(in) :: TauOmegaVec (:) real(kind=kind(1d0)), intent(in) :: OmegaVec (:) integer, intent(in) :: nTauOmegas integer, intent(in) :: nOmegas Called by proc~~savebidimentioal_dipole_spectrum~~CalledByGraph proc~savebidimentioal_dipole_spectrum Module_CMFT_CD_IO::SaveBidimentioal_Dipole_Spectrum program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~savebidimentioal_dipole_spectrum Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/savebidimentioal_dipole_spectrum.html"},{"title":"LoadFTofChargeasFuncofTimeDelay – Charge Migration","text":"public  subroutine LoadFTofChargeasFuncofTimeDelay(FileName, N_simulations, nOmegas, nAtoms, tvec, ChargeFTwt_new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(in) :: N_simulations integer, intent(in) :: nOmegas integer, intent(in) :: nAtoms real(kind=kind(1d0)), intent(out), allocatable :: tvec (:) complex(kind=kind(1d0)), intent(out), allocatable :: ChargeFTwt_new (:,:,:,:) Called by proc~~loadftofchargeasfuncoftimedelay~~CalledByGraph proc~loadftofchargeasfuncoftimedelay Module_CMFT_CD_IO::LoadFTofChargeasFuncofTimeDelay program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~loadftofchargeasfuncoftimedelay Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/loadftofchargeasfuncoftimedelay.html"},{"title":"Write_BidimentionalChargeFTww – Charge Migration","text":"public  subroutine Write_BidimentionalChargeFTww(FileName, ChargeFTww_new, TauOmegaVec, OmegaVec, nTauOmegas, nOmegas, nAtoms, AtomName) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(in) :: ChargeFTww_new (:,:,:,:) real(kind=kind(1d0)), intent(in) :: TauOmegaVec (:) real(kind=kind(1d0)), intent(in) :: OmegaVec (:) integer, intent(in) :: nTauOmegas integer, intent(in) :: nOmegas integer, intent(in) :: nAtoms character(len=16), intent(in) :: AtomName (:) Called by proc~~write_bidimentionalchargeftww~~CalledByGraph proc~write_bidimentionalchargeftww Module_CMFT_CD_IO::Write_BidimentionalChargeFTww program~chargemigrationft ChargeMigrationFT program~chargemigrationft->proc~write_bidimentionalchargeftww Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module.","tags":"","loc":"proc/write_bidimentionalchargeftww.html"},{"title":"Module_Becke – Charge Migration","text":"This code is a Fortran implementation of the Becke partitioning scheme based on the following papers: H. Gharibnejad, N. Douguet, B.I. Schneider, J. Olsen, L. Argenti,\n  A multi-center quadrature scheme for the molecular continuum,\n  Computer Physics Communications, Volume 263, 2021, 107889, ISSN 0010-4655,\n  https://doi.org/10.1016/j.cpc.2021.107889. and A. D. Becke; A multicenter numerical integration scheme for polyatomic molecules.\n  J. Chem. Phys. 15 February 1988; 88 (4): 2547–2553. https://doi.org/10.1063/1.454033 Quick Notes: Radius_Table: Given the name of an atom, returns its atomic radius. Only supports H, C, N, O, and Mg. get_param_a: Given two radii R_i and R_j, returns a transformed parameter a_ij. If the absolute value of is greater than 0.5, it's set to 0.5. new_mu_transformation: Returns a new mu parameter, given the original mu and . wkfun: Calculates a weighted function for atom i. PkFunTot: Sums up the function Pkfuna over all atoms. Pkfuna: Calculates a product of skfunab over all atoms excluding atom i. skfunab: Transforms an elliptical coordinate to a new mu, then returns the result of skfun with this new mu. skfun: Transforms a mu parameter into a step function. fkfun: Recursively calculates a function of mu. EllipticalCoord: Given coordinates rvec, avec, and bvec, calculates an elliptical coordinate. EuclDist: Given two points in space, calculates their Euclidean distance. The main considerations:\nThis code does not handle the case where the input atomic name does not match one of the provided options in Radius_Table. This could lead to an error or unexpected behavior.\nThe recursion in fkfun does not seem to have a base case when k is less than 1, which could potentially lead to a stack overflow error.\nThere are no checks for zero or negative distances in EuclDist which might cause issues if not handled properly upstream.\nThe input values are not validated for possible errors. Adding error handling and input validation could make the code more robust.\nThe functions are tightly coupled, which might make modifications and debugging more difficult. Uses iso_fortran_env module~~module_becke~~UsesGraph module~module_becke Module_Becke iso_fortran_env iso_fortran_env module~module_becke->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~module_becke~~UsedByGraph module~module_becke Module_Becke program~chargemigration ChargeMigration program~chargemigration->module~module_becke Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function EuclDist (avec, bvec) result(res) This function calculates the Euclidean distance between two points in 3D space. The inputs are two 3-component vectors representing the coordinates of the points, and the output is a scalar representing the distance between them. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: avec (3) real(kind=kind(1d0)), intent(in) :: bvec (3) Return Value real(kind=kind(1d0)) public  function EllipticalCoord (rvec, avec, bvec) result(res) Eq. 1 This function calculates the elliptical coordinate ( ) of a point relative to two other points (defined as atoms 'a' and 'b'). This coordinate is a measure of how much closer the point is to atom 'a' compared to atom 'b'. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) real(kind=kind(1d0)), intent(in) :: avec (3) real(kind=kind(1d0)), intent(in) :: bvec (3) Return Value real(kind=kind(1d0)) public  function Radius_Table (Atomic_Name) result(Atomic_Radius) Radius_Table for atomic radius based on atomic name\nThis function provides the atomic radius based on the atomic name. The input is a string representing the atomic name and the output is the corresponding atomic radius. This is useful for defining the size of atoms in molecular modelling. Arguments Type Intent Optional Attributes Name character(len=16), intent(in) :: Atomic_Name Return Value real(kind=kind(1d0)) public  function get_param_a (R_i, R_j) result(a_ij) This function calculates the parameter 'a' ( ) which depends on the radii of two atoms. This parameter is used in the transformation of the elliptical coordinate. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: R_i real(kind=kind(1d0)), intent(in) :: R_j Return Value real(kind=kind(1d0)) public  function new_mu_transformation (mu, a_ij) result(res) This function transforms the elliptical coordinate using the parameter 'a' ( ). This transformation is used to handle cases where the point is much closer to one atom than the other. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: mu real(kind=kind(1d0)), intent(in) :: a_ij Return Value real(kind=kind(1d0)) public recursive function fkfun (mu, k) result(res) Eq. 4 Recursive This function calculates a recursive function of the transformed elliptical coordinate. The output of this function will be used in the calculation of the step function skfun. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: mu integer, intent(in) :: k Return Value real(kind=kind(1d0)) public  function skfun (mu, k) result(res) (Step Function)\nThis function calculates a step function of the transformed elliptical coordinate. This function maps the transformed elliptical coordinate from the range [-1,1] to [0,1]. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: mu integer, intent(in) :: k Return Value real(kind=kind(1d0)) public  function skfunab (rvec, avec, bvec, k, a_ij) result(res) This function combines the calculations of the transformed elliptical coordinate and the step function. The output of this function will be used in the calculation of the partial partition function Pkfuna. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) real(kind=kind(1d0)), intent(in) :: avec (3) real(kind=kind(1d0)), intent(in) :: bvec (3) integer, intent(in) :: k real(kind=kind(1d0)) :: a_ij Return Value real(kind=kind(1d0)) public  function Pkfuna (rvec, iAtom, AtCoord, nAtoms, k, Radius_BS) result(res) Eq. 2 , nominator of Eq. 3\nThis function calculates the partial partition function for a specific atom. The output of this function represents the contribution of a specific atom to the total partition function. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) integer, intent(in) :: iAtom real(kind=kind(1d0)), intent(in) :: AtCoord (3,nAtoms) integer, intent(in) :: nAtoms integer, intent(in) :: k real(kind=kind(1d0)), intent(in) :: Radius_BS (:) Return Value real(kind=kind(1d0)) public  function PkFunTot (rvec, AtCoord, nAtoms, k, Radius_BS) result(res) Eq. 3 in the denominator\nThis function calculates the total partition function. This is done by summing the partial partition functions for all atoms. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) real(kind=kind(1d0)), intent(in) :: AtCoord (3,nAtoms) integer, intent(in) :: nAtoms integer, intent(in) :: k real(kind=kind(1d0)), intent(in) :: Radius_BS (:) Return Value real(kind=kind(1d0)) public  function wkfun (rvec, iAtom, AtCoord, nAtoms, k, Radius_BS) result(res) Eq. 3 $w_a \\vec(r)$  (WEIGHTS)\nThis function calculates the weight of an atom. The weight is defined as the ratio of the partial partition function of the atom to the total partition function. This weight represents the relative importance of the atom. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) integer, intent(in) :: iAtom real(kind=kind(1d0)), intent(in) :: AtCoord (3,nAtoms) integer, intent(in) :: nAtoms integer, intent(in) :: k real(kind=kind(1d0)), intent(in) :: Radius_BS (:) Return Value real(kind=kind(1d0))","tags":"","loc":"module/module_becke.html"},{"title":"Module_CM_CD_IO – Charge Migration","text":"Uses ModuleErrorHandling ModuleString iso_fortran_env module~~module_cm_cd_io~~UsesGraph module~module_cm_cd_io Module_CM_CD_IO ModuleErrorHandling ModuleErrorHandling module~module_cm_cd_io->ModuleErrorHandling ModuleString ModuleString module~module_cm_cd_io->ModuleString iso_fortran_env iso_fortran_env module~module_cm_cd_io->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~module_cm_cd_io~~UsedByGraph module~module_cm_cd_io Module_CM_CD_IO program~chargemigration ChargeMigration program~chargemigration->module~module_cm_cd_io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine Set_CD_IO_Verbous (logi) Commons <<! Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: logi public  subroutine Write_Summary (FileName, nPts, nAtoms, Computed_volume, n_times, t_min, t_max, atom_names, Radius_BS, number_of_orbitals, OrbTab) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(in) :: nPts integer, intent(in) :: nAtoms real(kind=kind(1d0)), intent(in) :: Computed_volume integer, intent(in) :: n_times real(kind=kind(1d0)), intent(in) :: t_min real(kind=kind(1d0)), intent(in) :: t_max character(len=16), intent(in) :: atom_names (:) real(kind=kind(1d0)), intent(in) :: Radius_BS (:) integer, intent(in) :: number_of_orbitals real(kind=kind(1d0)), intent(in) :: OrbTab (:,:) public  subroutine LoadGeometry (nAtoms, AtCoord, FileName, atom_names) Load Subroutines <<!\n Load the position of the atomic nuclei Read more… Arguments Type Intent Optional Attributes Name integer, intent(out) :: nAtoms real(kind=kind(1d0)), intent(out), allocatable :: AtCoord (:,:) character(len=*), intent(in) :: FileName character(len=16), intent(out), allocatable :: atom_names (:) public  subroutine LoadEnergies (FileName, nStates, Evec) Loads the Energies found inside the input_directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(out) :: nStates real(kind=kind(1d0)), intent(out), allocatable :: Evec (:) public  subroutine LoadGrid (FileName, npts, gridv) Loads the Grid found inside the input_directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(out) :: npts real(kind=kind(1d0)), intent(out), allocatable :: gridv (:,:) public  subroutine LoadOrbitals (Dir, number_of_orbitals, npts, OrbTab) Loads the Orbitals found inside the input_directory\nLoads the Orbitals from the grid_density.csv file inside the input_directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Dir integer, intent(in) :: number_of_orbitals integer, intent(in) :: npts real(kind=kind(1d0)), intent(out), allocatable :: OrbTab (:,:) public  subroutine LoadDipoleME (Dmat, input_directory, nStates) Loads all the Dipoles found inside the input_directory Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(out), allocatable :: Dmat (:,:,:) character(len=*), intent(in) :: input_directory integer, intent(in) :: nStates public  subroutine LoadTDMs (FileNameDM, FileNameTDM, nStates, number_of_orbitals, TDM) Loads the TDM found inside the input_directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileNameDM character(len=*), intent(in) :: FileNameTDM integer, intent(in) :: nStates integer, intent(out) :: number_of_orbitals real(kind=kind(1d0)), intent(out), allocatable :: TDM (:,:,:,:) public  subroutine LoadDipoleMO (input_directory, number_of_orbitals, ivOrb, MuOrb) Loads Dipole Matrix Elements between molecular orbitals\nIDEALLY, SHOULD COMPUTE THE DIPOLE FROM THE AO - AO DIPOLES. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_directory integer, intent(in) :: number_of_orbitals integer, intent(in) :: ivOrb (:) real(kind=kind(1d0)), intent(out), allocatable :: MuOrb (:,:) public  subroutine Write_R_el_bc (output_directory, atom_names, nAtoms, R_el) Save Subroutines Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: output_directory character(len=16), intent(in), allocatable :: atom_names (:) integer, intent(in) :: nAtoms real(kind=kind(1d0)), intent(in), allocatable :: R_el (:,:) public  subroutine Write_Dipole (FileName, Dipole, n_times, t_min, dt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(in) :: Dipole (:,:) integer, intent(in) :: n_times real(kind=kind(1d0)), intent(in) :: t_min real(kind=kind(1d0)), intent(in) :: dt public  subroutine Write_Q_Charge (FileName, Charge, n_times, t_min, dt, nAtoms, atom_names) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(in) :: Charge (:,:,:) integer, intent(in) :: n_times real(kind=kind(1d0)), intent(in) :: t_min real(kind=kind(1d0)), intent(in) :: dt integer, intent(in) :: nAtoms character(len=16), intent(in) :: atom_names (:) public  subroutine Write_Charge_Density (FileName, nPts, gridv, ChDen, Weightv, nAtoms, atom_names) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(in) :: nPts real(kind=kind(1d0)), intent(in), allocatable :: gridv (:,:) real(kind=kind(1d0)), intent(in), allocatable :: ChDen (:) real(kind=kind(1d0)), intent(in), allocatable :: Weightv (:,:) integer, intent(in) :: nAtoms character(len=16), intent(in) :: atom_names (:) public  subroutine Write_Weights (FileName, WEIGHTV, gridv, nAtoms, nPts, atom_names) Write Weights Subroutine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(in) :: WEIGHTV (:,:) real(kind=kind(1d0)), intent(in) :: gridv (:,:) integer, intent(in) :: nAtoms integer, intent(in) :: nPts character(len=16), intent(in) :: atom_names (:) public  subroutine Read_Weights (FileName, WEIGHTV, nAtoms, nPts) Read Weights Subroutine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(out), allocatable :: WEIGHTV (:,:) integer, intent(in) :: nAtoms integer, intent(in) :: nPts","tags":"","loc":"module/module_cm_cd_io.html"},{"title":"Module_SR_CD_IO – Charge Migration","text":"Uses ModulePulses_3D iso_fortran_env ModuleConstants module~~module_sr_cd_io~~UsesGraph module~module_sr_cd_io Module_SR_CD_IO ModuleConstants ModuleConstants module~module_sr_cd_io->ModuleConstants ModulePulses_3D ModulePulses_3D module~module_sr_cd_io->ModulePulses_3D iso_fortran_env iso_fortran_env module~module_sr_cd_io->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine Set_CD_IO_Verbous (logi) Arguments Type Intent Optional Attributes Name logical, intent(in) :: logi public  subroutine LoadGeometry (nAtoms, AtCoord, FileName, atom_names) ** Skip to the line specifying the number of atoms\n determine the number of atoms\n** Skip to the line where the coordinates start to be listed\nallocate the matrix of coordinates Arguments Type Intent Optional Attributes Name integer, intent(out) :: nAtoms real(kind=kind(1d0)), intent(out), allocatable :: AtCoord (:,:) character(len=*), intent(in) :: FileName character(len=16), intent(out), allocatable :: atom_names (:) public  subroutine LoadBidimentioal_Dipole_Spectrum (FileName, DipoleFTww, TauOmegaVec, OmegaVec, nTauOmegas, nOmegas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(out), allocatable :: DipoleFTww (:,:,:) real(kind=kind(1d0)), intent(in) :: TauOmegaVec (:) real(kind=kind(1d0)), intent(in) :: OmegaVec (:) integer, intent(in) :: nTauOmegas integer, intent(in) :: nOmegas public  subroutine Write_2DReconstructDipole (FileName, Dipole, TauOmegaVec, OmegaVec, nTauOmegas, nOmegas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(in) :: Dipole (:,:,:) real(kind=kind(1d0)), intent(in) :: TauOmegaVec (:) real(kind=kind(1d0)), intent(in) :: OmegaVec (:) integer, intent(in) :: nTauOmegas integer, intent(in) :: nOmegas public  subroutine Load_BidimentionalChargeFTww (FileName, ChargeFTww_new, TauOmegaVec, OmegaVec, nTauOmegas, nOmegas, nAtoms) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(out), allocatable :: ChargeFTww_new (:,:,:,:) real(kind=kind(1d0)), intent(in) :: TauOmegaVec (:) real(kind=kind(1d0)), intent(in) :: OmegaVec (:) integer, intent(in) :: nTauOmegas integer, intent(in) :: nOmegas integer, intent(in) :: nAtoms","tags":"","loc":"module/module_sr_cd_io.html"},{"title":"Module_CMFT_RTP – Charge Migration","text":"Used by module~~module_cmft_rtp~~UsedByGraph module~module_cmft_rtp Module_CMFT_RTP program~chargemigrationft ChargeMigrationFT program~chargemigrationft->module~module_cmft_rtp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine GetRunTimeParameters (InpDir, OutDir, FileGeometry, StepTime, StepWidth, FieldFile, Verbous, nOmegas, OmegaMin, OmegaMax, nTauOmegas, TauOmegaMin, TauOmegaMax) Reads the run time parameters specified in the command line. Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: InpDir character(len=:), intent(out), allocatable :: OutDir character(len=:), intent(out), allocatable :: FileGeometry real(kind=kind(1d0)), intent(out) :: StepTime real(kind=kind(1d0)), intent(out) :: StepWidth character(len=:), intent(out), allocatable :: FieldFile logical, intent(out) :: Verbous integer, intent(out) :: nOmegas real(kind=kind(1d0)), intent(out) :: OmegaMin real(kind=kind(1d0)), intent(out) :: OmegaMax integer, intent(out) :: nTauOmegas real(kind=kind(1d0)), intent(out) :: TauOmegaMin real(kind=kind(1d0)), intent(out) :: TauOmegaMax","tags":"","loc":"module/module_cmft_rtp.html"},{"title":"Module_CM_RTP – Charge Migration","text":"Used by module~~module_cm_rtp~~UsedByGraph module~module_cm_rtp Module_CM_RTP program~chargemigration ChargeMigration program~chargemigration->module~module_cm_rtp Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine GetRunTimeParameters (input_directory, output_directory, molecular_geometry_file, n_times, t_min, t_max, FieldFile, Verbous, Weight_File, read_precomputed_weights_flag, save_charge_migration_flag, ivorb, counted_number_of_orbitals, dephasing_factor, relaxation_factor, bath_temperature) Reads the run time parameters specified in the command line.\nReads the run time parameters specified in the command line. Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: input_directory character(len=:), intent(out), allocatable :: output_directory character(len=:), intent(out), allocatable :: molecular_geometry_file integer, intent(out) :: n_times real(kind=kind(1d0)), intent(out) :: t_min real(kind=kind(1d0)), intent(out) :: t_max character(len=:), intent(out), allocatable :: FieldFile logical, intent(out) :: Verbous character(len=:), intent(out), allocatable :: Weight_File logical, intent(out) :: read_precomputed_weights_flag logical, intent(out) :: save_charge_migration_flag integer, intent(out), allocatable :: ivorb (:) integer, intent(out) :: counted_number_of_orbitals real(kind=kind(1d0)), intent(out) :: dephasing_factor real(kind=kind(1d0)), intent(out) :: relaxation_factor real(kind=kind(1d0)), intent(out) :: bath_temperature","tags":"","loc":"module/module_cm_rtp.html"},{"title":"Module_SR_RTP – Charge Migration","text":"Subroutines public  subroutine GetRunTimeParameters (InpDir, OutDir, FileGeometry, StepTime, StepWidth, FieldFile, Verbous, nOmegas, OmegaMin, OmegaMax, nTauOmegas, TauOmegaMin, TauOmegaMax) Reads the run time parameters specified in the command line. Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: InpDir character(len=:), intent(out), allocatable :: OutDir character(len=:), intent(out), allocatable :: FileGeometry real(kind=kind(1d0)), intent(out) :: StepTime real(kind=kind(1d0)), intent(out) :: StepWidth character(len=:), intent(out), allocatable :: FieldFile logical, intent(out) :: Verbous integer, intent(out) :: nOmegas real(kind=kind(1d0)), intent(out) :: OmegaMin real(kind=kind(1d0)), intent(out) :: OmegaMax integer, intent(out) :: nTauOmegas real(kind=kind(1d0)), intent(out) :: TauOmegaMin real(kind=kind(1d0)), intent(out) :: TauOmegaMax","tags":"","loc":"module/module_sr_rtp.html"},{"title":"Module_CMFT_CD_IO – Charge Migration","text":"Uses ModulePulses_3D ModuleErrorHandling iso_fortran_env ModuleConstants module~~module_cmft_cd_io~~UsesGraph module~module_cmft_cd_io Module_CMFT_CD_IO ModuleConstants ModuleConstants module~module_cmft_cd_io->ModuleConstants ModuleErrorHandling ModuleErrorHandling module~module_cmft_cd_io->ModuleErrorHandling ModulePulses_3D ModulePulses_3D module~module_cmft_cd_io->ModulePulses_3D iso_fortran_env iso_fortran_env module~module_cmft_cd_io->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~module_cmft_cd_io~~UsedByGraph module~module_cmft_cd_io Module_CMFT_CD_IO program~chargemigrationft ChargeMigrationFT program~chargemigrationft->module~module_cmft_cd_io Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine Set_CD_IO_Verbous (logi) Arguments Type Intent Optional Attributes Name logical, intent(in) :: logi public  subroutine LoadGeometry (nAtoms, AtCoord, FileName, AtomName) Load the position of the atomic nuclei Read more… Arguments Type Intent Optional Attributes Name integer, intent(out) :: nAtoms real(kind=kind(1d0)), intent(out), allocatable :: AtCoord (:,:) character(len=*), intent(in) :: FileName character(len=16), intent(out), allocatable :: AtomName (:) public  subroutine LoadEnergies (FileName, nStates, Evec) Loads the Energies found inside the InpDir Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(out) :: nStates real(kind=kind(1d0)), intent(out), allocatable :: Evec (:) public  subroutine Load_XUVAtomicCharge (FileName, Charge, nTimes, nAtoms) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(out), allocatable :: Charge (:,:,:) integer, intent(in) :: nTimes integer, intent(in) :: nAtoms public  subroutine Load_Dipole (FileName, Dipole, nTimes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(out), allocatable :: Dipole (:,:) integer, intent(in) :: nTimes public  subroutine Load_Q_Charge_and_Write2ALL (FileName, Charge, nTimes, tmin, dt, nAtoms, iSim, atom_names, uid_AtomicChargeALL) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(out), allocatable :: Charge (:,:,:) integer, intent(in) :: nTimes real(kind=kind(1d0)), intent(in) :: tmin real(kind=kind(1d0)), intent(in) :: dt integer, intent(in) :: nAtoms integer, intent(in) :: iSim character(len=16), intent(in) :: atom_names (:) integer, intent(in) :: uid_AtomicChargeALL public  subroutine LoadAtomicCharges (FileName, AtomicChargeEvolution, nTimes, nAtoms, iSim, tmin, dt, uid_AtomicChargeALL) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(out), allocatable :: AtomicChargeEvolution (:,:) integer, intent(in) :: nTimes integer, intent(in) :: nAtoms integer, intent(in) :: iSim real(kind=kind(1d0)), intent(in) :: tmin real(kind=kind(1d0)), intent(in) :: dt integer, intent(in) :: uid_AtomicChargeALL public  subroutine WriteDipoleFTFile (FileName, DipoleFTtotal, OmegaVec, nOmegas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(in) :: DipoleFTtotal (:,:) real(kind=kind(1d0)), allocatable :: OmegaVec (:) integer, intent(in) :: nOmegas public  subroutine AppendDipole2FTAllFile (FileName, DipoleFTtotal, OmegaVec, nOmegas, iSim, train) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(in) :: DipoleFTtotal (:,:) real(kind=kind(1d0)) :: OmegaVec (:) integer, intent(in) :: nOmegas integer, intent(in) :: iSim type(pulse_train), intent(in), pointer :: train (:) public  subroutine WriteAtomicChargeFT (FileName, AtomicChargeFT, OmegaVec, nOmegas, nAtoms, AtomName) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(in) :: AtomicChargeFT (:,:,:) real(kind=kind(1d0)) :: OmegaVec (:) integer, intent(in) :: nOmegas integer, intent(in) :: nAtoms character(len=16), intent(in) :: AtomName (:) public  subroutine WriteAllAtomicChargeFTtoSingleFile (FileName, AtomicChargeFT_new, OmegaVec, nOmegas, nAtoms, iSim, train, AtomName) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)) :: AtomicChargeFT_new (:,:,:) real(kind=kind(1d0)) :: OmegaVec (:) integer, intent(in) :: nOmegas integer, intent(in) :: nAtoms integer, intent(in) :: iSim type(pulse_train), intent(in), pointer :: train (:) character(len=16), intent(in) :: AtomName (:) public  subroutine LoadFTDipole_asfuncitonof_TimeDelay (FileName, N_simulations, nOmegas, DipoleFTwt, tvec) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(in) :: N_simulations integer, intent(in) :: nOmegas complex(kind=kind(1d0)), intent(out), allocatable :: DipoleFTwt (:,:,:) real(kind=kind(1d0)), intent(out), allocatable :: tvec (:) public  subroutine SaveBidimentioal_Dipole_Spectrum (FileName, DipoleFTww, TauOmegaVec, OmegaVec, nTauOmegas, nOmegas) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(in) :: DipoleFTww (:,:,:) real(kind=kind(1d0)), intent(in) :: TauOmegaVec (:) real(kind=kind(1d0)), intent(in) :: OmegaVec (:) integer, intent(in) :: nTauOmegas integer, intent(in) :: nOmegas public  subroutine LoadFTofChargeasFuncofTimeDelay (FileName, N_simulations, nOmegas, nAtoms, tvec, ChargeFTwt_new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(in) :: N_simulations integer, intent(in) :: nOmegas integer, intent(in) :: nAtoms real(kind=kind(1d0)), intent(out), allocatable :: tvec (:) complex(kind=kind(1d0)), intent(out), allocatable :: ChargeFTwt_new (:,:,:,:) public  subroutine Write_BidimentionalChargeFTww (FileName, ChargeFTww_new, TauOmegaVec, OmegaVec, nTauOmegas, nOmegas, nAtoms, AtomName) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(in) :: ChargeFTww_new (:,:,:,:) real(kind=kind(1d0)), intent(in) :: TauOmegaVec (:) real(kind=kind(1d0)), intent(in) :: OmegaVec (:) integer, intent(in) :: nTauOmegas integer, intent(in) :: nOmegas integer, intent(in) :: nAtoms character(len=16), intent(in) :: AtomName (:)","tags":"","loc":"module/module_cmft_cd_io.html"},{"title":"ChargeMigration – Charge Migration","text":"Uses Module_CM_RTP iso_fortran_env ModuleDiagonalize Module_CM_CD_IO ModuleConstants ModulePulses_3D Module_Becke omp_lib ModuleErrorHandling ModuleSystemUtils ModuleString ModuleIO program~~chargemigration~~UsesGraph program~chargemigration ChargeMigration ModuleConstants ModuleConstants program~chargemigration->ModuleConstants ModuleDiagonalize ModuleDiagonalize program~chargemigration->ModuleDiagonalize ModuleErrorHandling ModuleErrorHandling program~chargemigration->ModuleErrorHandling ModuleIO ModuleIO program~chargemigration->ModuleIO ModulePulses_3D ModulePulses_3D program~chargemigration->ModulePulses_3D ModuleString ModuleString program~chargemigration->ModuleString ModuleSystemUtils ModuleSystemUtils program~chargemigration->ModuleSystemUtils iso_fortran_env iso_fortran_env program~chargemigration->iso_fortran_env module~module_becke Module_Becke program~chargemigration->module~module_becke module~module_cm_cd_io Module_CM_CD_IO program~chargemigration->module~module_cm_cd_io module~module_cm_rtp Module_CM_RTP program~chargemigration->module~module_cm_rtp omp_lib omp_lib program~chargemigration->omp_lib module~module_becke->iso_fortran_env module~module_cm_cd_io->ModuleErrorHandling module~module_cm_cd_io->ModuleString module~module_cm_cd_io->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Synopsis: Simulates charge migration in molecular systems under external fields, relaxations, and dephasing effects using the Lindblad master equation. Key Subroutines: LiouvillianPropagator: This central routine simulates the dynamics of a quantum system subject to an external field. It updates the state density matrix zStatRho using the eigenvalues L0_Eval and eigenvectors L0_LEvec, L0_REvec of the Liouvillian operator. ComputeLiouvillian_0: Calculates the time-independent Lindblad superoperator (Liouvillian), crucial in describing the time evolution of the density matrix in an open quantum system. It uses system energy eigenvalues Evec, dipole moment matrix Dmat, and parameters like bath_temperature, dephasing_factor, and relaxation_factor. DiagonalizeLindblad_0: Performs diagonalization of the Lindblad superoperator Liouvillian0, determining its eigenvalues L0_Eval and eigenvectors L0_LEvec and L0_REvec. HilbertToLiouvilleMatrix and LiouvilleToHilbertMatrix: These subroutines transform between Hilbert space matrices and Liouville space vectors. They are crucial for applying the Liouville operator in the simulations. ComputeOrbitalDensity: Builds the orbital density matrix Amat from the state density matrix zStatRho and transition density matrices TDM. ComputeAtomicCharges: Calculates new atomic charges QchargeVec from the orbital density OrbitalDensity and Becke matrix BeckeMatrix. TabulateChargeDensity: Generates charge density ChDen from the orbital density matrix Amat and orbital table OrbTab. ComputeBeckeMatrix: Constructs the Becke matrix BeckeMatrix using weights WeightV, orbital table OrbTab, and barycenter coordinates Bary_center. ComputeAtomicWeights: Calculates atomic weights WeightV for a given set of points gridv, atomic coordinates AtCoord, and radii Radius_BS. Calls program~~chargemigration~~CallsGraph program~chargemigration ChargeMigration omp_set_num_threads omp_set_num_threads program~chargemigration->omp_set_num_threads parse_simulation_file parse_simulation_file program~chargemigration->parse_simulation_file proc~atomicradius_bragg_slater_becke ChargeMigration::AtomicRadius_Bragg_Slater_Becke program~chargemigration->proc~atomicradius_bragg_slater_becke proc~compute_r_el ChargeMigration::Compute_R_el program~chargemigration->proc~compute_r_el proc~computeatomiccharges ChargeMigration::ComputeAtomicCharges program~chargemigration->proc~computeatomiccharges proc~computeatomicweights ChargeMigration::ComputeAtomicWeights program~chargemigration->proc~computeatomicweights proc~computebeckematrix ChargeMigration::ComputeBeckeMatrix program~chargemigration->proc~computebeckematrix proc~computeliouvillian_0 ChargeMigration::ComputeLiouvillian_0 program~chargemigration->proc~computeliouvillian_0 proc~computeorbitaldensity ChargeMigration::ComputeOrbitalDensity program~chargemigration->proc~computeorbitaldensity proc~computevolume ChargeMigration::Computevolume program~chargemigration->proc~computevolume proc~diagonalizelindblad_0 ChargeMigration::DiagonalizeLindblad_0 program~chargemigration->proc~diagonalizelindblad_0 proc~getruntimeparameters~2 Module_CM_RTP::GetRunTimeParameters program~chargemigration->proc~getruntimeparameters~2 proc~liouvillianpropagator ChargeMigration::LiouvillianPropagator program~chargemigration->proc~liouvillianpropagator proc~loaddipoleme Module_CM_CD_IO::LoadDipoleME program~chargemigration->proc~loaddipoleme proc~loadenergies Module_CM_CD_IO::LoadEnergies program~chargemigration->proc~loadenergies proc~loadgeometry Module_CM_CD_IO::LoadGeometry program~chargemigration->proc~loadgeometry proc~loadgrid Module_CM_CD_IO::LoadGrid program~chargemigration->proc~loadgrid proc~loadorbitals Module_CM_CD_IO::LoadOrbitals program~chargemigration->proc~loadorbitals proc~loadtdms Module_CM_CD_IO::LoadTDMs program~chargemigration->proc~loadtdms proc~read_weights Module_CM_CD_IO::Read_Weights program~chargemigration->proc~read_weights proc~set_cd_io_verbous Module_CM_CD_IO::Set_CD_IO_Verbous program~chargemigration->proc~set_cd_io_verbous proc~tabulatechargedensity ChargeMigration::TabulateChargeDensity program~chargemigration->proc~tabulatechargedensity proc~write_charge_density Module_CM_CD_IO::Write_Charge_Density program~chargemigration->proc~write_charge_density proc~write_dipole Module_CM_CD_IO::Write_Dipole program~chargemigration->proc~write_dipole proc~write_q_charge Module_CM_CD_IO::Write_Q_Charge program~chargemigration->proc~write_q_charge proc~write_r_el_bc Module_CM_CD_IO::Write_R_el_bc program~chargemigration->proc~write_r_el_bc proc~write_summary Module_CM_CD_IO::Write_Summary program~chargemigration->proc~write_summary proc~write_weights Module_CM_CD_IO::Write_Weights program~chargemigration->proc~write_weights writefta writefta program~chargemigration->writefta zdotu zdotu program~chargemigration->zdotu proc~radius_table Module_Becke::Radius_Table proc~atomicradius_bragg_slater_becke->proc~radius_table proc~wkfun Module_Becke::wkfun proc~computeatomicweights->proc~wkfun proc~hilberttoliouvilleindexes ChargeMigration::HilbertToLiouvilleIndexes proc~computeliouvillian_0->proc~hilberttoliouvilleindexes proc~liouvilletohilbertindexes ChargeMigration::LiouvilleToHilbertIndexes proc~computeliouvillian_0->proc~liouvilletohilbertindexes short_diag short_diag proc~diagonalizelindblad_0->short_diag zgemm zgemm proc~diagonalizelindblad_0->zgemm add add proc~getruntimeparameters~2->add get get proc~getruntimeparameters~2->get parse parse proc~getruntimeparameters~2->parse printusage printusage proc~getruntimeparameters~2->printusage setdescription setdescription proc~getruntimeparameters~2->setdescription externalelectricfieldcart externalelectricfieldcart proc~liouvillianpropagator->externalelectricfieldcart proc~diagonalizedipole ChargeMigration::DiagonalizeDipole proc~liouvillianpropagator->proc~diagonalizedipole proc~hilberttoliouvillematrix ChargeMigration::HilbertToLiouvilleMatrix proc~liouvillianpropagator->proc~hilberttoliouvillematrix proc~liouvilletohilbertmatrix ChargeMigration::LiouvilleToHilbertMatrix proc~liouvillianpropagator->proc~liouvilletohilbertmatrix short_zheev short_zheev proc~liouvillianpropagator->short_zheev proc~liouvillianpropagator->zgemm zgemv zgemv proc~liouvillianpropagator->zgemv errormessage errormessage proc~loaddipoleme->errormessage proc~loadenergies->errormessage proc~loadgrid->errormessage assert assert proc~loadorbitals->assert converttostrn converttostrn proc~loadorbitals->converttostrn proc~loadorbitals->errormessage stopexecution stopexecution proc~loadorbitals->stopexecution proc~loadtdms->errormessage proc~write_charge_density->errormessage proc~write_summary->assert proc~diagonalizedipole->short_diag proc~hilberttoliouvillematrix->proc~hilberttoliouvilleindexes proc~liouvilletohilbertmatrix->proc~hilberttoliouvilleindexes proc~pkfuna Module_Becke::Pkfuna proc~wkfun->proc~pkfuna proc~pkfuntot Module_Becke::PkFunTot proc~wkfun->proc~pkfuntot proc~get_param_a Module_Becke::get_param_a proc~pkfuna->proc~get_param_a proc~skfunab Module_Becke::skfunab proc~pkfuna->proc~skfunab proc~pkfuntot->proc~pkfuna proc~ellipticalcoord Module_Becke::EllipticalCoord proc~skfunab->proc~ellipticalcoord proc~new_mu_transformation Module_Becke::new_mu_transformation proc~skfunab->proc~new_mu_transformation proc~skfun Module_Becke::skfun proc~skfunab->proc~skfun proc~eucldist Module_Becke::EuclDist proc~ellipticalcoord->proc~eucldist proc~fkfun Module_Becke::fkfun proc~skfun->proc~fkfun proc~fkfun->proc~fkfun Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=:), allocatable :: input_directory character(len=:), allocatable :: output_directory character(len=:), allocatable :: molecular_geometry_file integer :: n_times real(kind=kind(1d0)) :: t_min real(kind=kind(1d0)) :: t_max character(len=:), allocatable :: Ext_field_file character(len=:), allocatable :: Weight_File logical :: Verbous logical :: read_precomputed_weights_flag logical :: save_charge_migration_flag integer, allocatable :: ivorb (:) integer :: counted_number_of_orbitals real(kind=kind(1d0)) :: dephasing_factor real(kind=kind(1d0)) :: relaxation_factor real(kind=kind(1d0)) :: bath_temperature integer, parameter :: GS_IDX = 1 integer :: nStates integer :: number_of_orbitals integer :: i real(kind=kind(1d0)), allocatable :: Evec (:) real(kind=kind(1d0)), allocatable :: Dmat (:,:,:) real(kind=kind(1d0)), allocatable :: TDM (:,:,:,:) complex(kind=kind(1d0)), allocatable :: zMuEV (:,:) complex(kind=kind(1d0)), allocatable :: zDmat_t (:,:,:) integer :: npts integer :: nAtoms real(kind=kind(1d0)), allocatable :: gridv (:,:) real(kind=kind(1d0)), allocatable :: AtCoord (:,:) real(kind=kind(1d0)), allocatable :: OrbTab (:,:) complex(kind=kind(1d0)), allocatable :: zStatRho (:,:) real(kind=kind(1d0)) :: t real(kind=kind(1d0)) :: dt real(kind=kind(1d0)), allocatable :: ChDen (:) real(kind=kind(1d0)), allocatable :: WEIGHTV (:,:) real(kind=kind(1d0)), allocatable :: AtomicChargeVec (:,:) real(kind=kind(1d0)), allocatable :: AtomicChargeEvolution (:,:,:) character(len=30) :: istrn character(len=16), allocatable :: atom_names (:) integer :: iPts integer :: it integer :: iPol integer :: iAtom complex(kind=kind(1d0)), allocatable :: Liouvillian0 (:,:) complex(kind=kind(1d0)), allocatable :: L0_LEvec (:,:) complex(kind=kind(1d0)), allocatable :: L0_REvec (:,:) complex(kind=kind(1d0)), allocatable :: L0_Eval (:) integer :: iSim integer :: N_Simulations integer :: uid character(len=64), pointer :: Simulation_Tagv (:) character(len=1000) :: strn type(pulse_train), pointer :: train (:) real(kind=kind(1d0)), allocatable :: BeckeMatrix (:,:,:,:) real(kind=kind(1d0)), allocatable :: OrbitalDensity (:,:) real(kind=kind(1d0)), allocatable :: Radius_BS (:) real(kind=kind(1d0)) :: Computed_volume integer :: iOrb integer :: jOrb real(kind=kind(1d0)), allocatable :: QchargeVec (:,:) real(kind=kind(1d0)), allocatable :: R_el (:,:) Functions function zTraceFunction (zA) result(zTrace) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: zA (:,:) Return Value complex(kind=kind(1d0)) Subroutines subroutine LiouvillianPropagator (L0_Eval, L0_LEvec, L0_REvec, zStatRho) The central routine in simulating the dynamics of a quantum system subject to an external field, describing the time evolution of the system in Liouville space.\n Build the time-independent Lindblad superoperator Read more… Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: L0_Eval (:) a complex array holding the eigenvalues of the Liouville operator. complex(kind=kind(1d0)), intent(in) :: L0_LEvec (:,:) a complex array holding the left eigenvectors of the Liouville operator. complex(kind=kind(1d0)), intent(in) :: L0_REvec (:,:) a complex array holding the right eigenvectors of the Liouville operator. complex(kind=kind(1d0)), intent(inout) :: zStatRho (:,:) a complex array holding the initial state density matrix of the quantum system. The array is updated within the subroutine, and hence is an input/output parameter. subroutine ComputeLiouvillian_0 (Evec, Dmat, Liouvillian0, bath_temperature, dephasing_factor, relaxation_factor) Calculates the time-independent Lindblad superoperator (Liouvillian), a crucial element in the Lindblad master equation, used for describing the time evolution of the density matrix of a quantum system in an open quantum system framework. Read more… Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: Evec (:) The array of energy eigenvalues of the system's Hamiltonian. real(kind=kind(1d0)), intent(in) :: Dmat (:,:,:) The dipole moment matrix of the system. complex(kind=kind(1d0)), intent(out), allocatable :: Liouvillian0 (:,:) The computed Liouvillian superoperator. It's an output parameter that's updated in the subroutine. real(kind=kind(1d0)), intent(in) :: bath_temperature The temperature of the bath or environment interacting with the quantum system. real(kind=kind(1d0)), intent(in) :: dephasing_factor The factor representing dephasing effects in the system. real(kind=kind(1d0)), intent(in) :: relaxation_factor The factor representing relaxation effects in the system. subroutine DiagonalizeLindblad_0 (Liouvillian0, L0_Eval, L0_LEvec, L0_REvec) Performs the diagonalization of the time-independent\nLindblad superoperator (Liouvillian0). The diagonalization is performed using the\nShort_Diag subroutine, and the results are printed to the standard output.\nThis routine also checks that the product of right and conjugate transpose of left eigenvectors\nis an identity matrix (a necessary condition for a valid diagonalization). Read more… Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(inout) :: Liouvillian0 (:,:) A complex square matrix representing the Lindblad superoperator to be diagonalized. complex(kind=kind(1d0)), intent(out), allocatable :: L0_Eval (:) A complex vector that will hold the eigenvalues of Liouvillian0. complex(kind=kind(1d0)), intent(out), allocatable :: L0_LEvec (:,:) A complex square matrix that will hold the left eigenvectors of Liouvillian0. complex(kind=kind(1d0)), intent(out), allocatable :: L0_REvec (:,:) A complex square matrix that will hold the right eigenvectors of Liouvillian0. subroutine HilbertToLiouvilleMatrix (RhoMat, RhoVec) Transforms a matrix from Hilbert space into a vector\nin Liouville space. The transformation is performed by looping through each element of the input\nmatrix and mapping it to the corresponding position in the output vector using the subroutine\nHilbertToLiouvilleIndexes. This transformation is required for the application of the Liouville operator. Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: RhoMat (:,:) A complex matrix representing the state in Hilbert space. complex(kind=kind(1d0)), intent(out) :: RhoVec (:) A complex vector representing the transformed state in Liouville space. subroutine LiouvilleToHilbertMatrix (RhoVec, RhoMat) Performs the inverse transformation of\nHilbertToLiouvilleMatrix, transforming a vector in Liouville space back into a matrix in\nHilbert space. The transformation is performed by looping through each element of the output matrix\nand assigning it the corresponding value from the input vector using the subroutine\nHilbertToLiouvilleIndexes. Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: RhoVec (:) A complex vector representing the state in Liouville space. complex(kind=kind(1d0)), intent(out) :: RhoMat (:,:) A complex matrix representing the transformed state in Hilbert space. subroutine HilbertToLiouvilleIndexes (i, j, iPair) Transforms matrix indices in Hilbert space into a\nsingle index in Liouville space. The transformation is dependent on the relative values of the\ninput indices. The resulting single index is required for the transformation from Hilbert to\nLiouville space. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Integers representing the indices in Hilbert space. integer, intent(in) :: j Integers representing the indices in Hilbert space. integer, intent(out) :: iPair An integer representing the corresponding single index in Liouville space. subroutine LiouvilleToHilbertIndexes (iPair, i, j) Takes in a single integer index in Liouville space\nand converts it into a pair of matrix indices in Hilbert space. The indices are calculated by\ndecomposing the given Liouville index into a square plus a remainder, which are then used to\ncalculate the corresponding Hilbert indices. Arguments Type Intent Optional Attributes Name integer, intent(in) :: iPair An integer representing a single index in Liouville space. integer, intent(out) :: i Integers representing the corresponding indices in Hilbert space. integer, intent(out) :: j Integers representing the corresponding indices in Hilbert space. subroutine DiagonalizeDipole (Dmat, EVEC_DX, zUMAT_DX, EVEC_DY, zUMAT_DY, EVEC_DZ, zUMAT_DZ) input and computes the diagonalized matrices and their eigenvalues. Read more… Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: Dmat (:,:,:) Real 3D array representing the dipole moment matrix. real(kind=kind(1d0)), intent(out), allocatable :: EVEC_DX (:) Real 1D arrays for the eigenvalues of the dipoles in X, Y, and Z directions. complex(kind=kind(1d0)), intent(out), allocatable :: zUMAT_DX (:,:) Complex 2D arrays for the diagonalized matrices in X, Y, and Z directions, respectively. real(kind=kind(1d0)), intent(out), allocatable :: EVEC_DY (:) Real 1D arrays for the eigenvalues of the dipoles in X, Y, and Z directions. complex(kind=kind(1d0)), intent(out), allocatable :: zUMAT_DY (:,:) Complex 2D arrays for the diagonalized matrices in X, Y, and Z directions, respectively. real(kind=kind(1d0)), intent(out), allocatable :: EVEC_DZ (:) Real 1D arrays for the eigenvalues of the dipoles in X, Y, and Z directions. complex(kind=kind(1d0)), intent(out), allocatable :: zUMAT_DZ (:,:) Complex 2D arrays for the diagonalized matrices in X, Y, and Z directions, respectively. subroutine Computevolume (nPts, volume, gridv) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPts real(kind=kind(1d0)), intent(out) :: volume real(kind=kind(1d0)), intent(in), allocatable :: gridv (:,:) subroutine Compute_R_el (gridv, WeightV, OrbTab, R_el) Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in), allocatable :: gridv (:,:) real(kind=kind(1d0)), intent(in), allocatable :: WeightV (:,:) real(kind=kind(1d0)), intent(in), allocatable :: OrbTab (:,:) real(kind=kind(1d0)), intent(out), allocatable :: R_el (:,:) subroutine AtomicRadius_Bragg_Slater_Becke (atom_names, nAtom, Radius_BS) Arguments Type Intent Optional Attributes Name character(len=16), intent(in) :: atom_names (:) integer, intent(in) :: nAtom real(kind=kind(1d0)), intent(out), allocatable :: Radius_BS (:) subroutine ComputeAtomicCharges (OrbitalDensity, BeckeMatrix, QchargeVec) Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: OrbitalDensity (:,:) real(kind=kind(1d0)), intent(in) :: BeckeMatrix (:,:,:,:) real(kind=kind(1d0)), intent(out), allocatable :: QchargeVec (:,:) subroutine ComputeOrbitalDensity (zStatRho, TDM, Amat) Build the expansion Matrix where is the solution of a suitable Master equation, starting from Here, we will neglect relaxation and decoherence and hence where Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: zStatRho (:,:) real(kind=kind(1d0)), intent(in) :: TDM (:,:,:,:) real(kind=kind(1d0)), intent(out), allocatable :: Amat (:,:) subroutine ComputeAtomicWeights (nPts, gridv, nAtoms, AtCoord, WeightV, Radius_BS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPts real(kind=kind(1d0)), intent(in) :: gridv (:,:) integer, intent(in) :: nAtoms real(kind=kind(1d0)), intent(in) :: AtCoord (:,:) real(kind=kind(1d0)), intent(out), allocatable :: WeightV (:,:) real(kind=kind(1d0)), intent(in) :: Radius_BS (:) subroutine TabulateChargeDensity (Amat, OrbTab, ChDen) Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: Amat (:,:) real(kind=kind(1d0)), intent(in) :: OrbTab (:,:) real(kind=kind(1d0)), intent(out) :: ChDen (:) subroutine ComputeBeckeMatrix (WeightV, OrbTab, BeckeMatrix, Bary_center) Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: WeightV (:,:) real(kind=kind(1d0)), intent(in) :: OrbTab (:,:) real(kind=kind(1d0)), intent(out), allocatable :: BeckeMatrix (:,:,:,:) real(kind=kind(1d0)), intent(in) :: Bary_center (:,:)","tags":"","loc":"program/chargemigration.html"},{"title":"ChargeMigrationFT – Charge Migration","text":"Uses iso_fortran_env ModuleDiagonalize ModuleConstants Module_CMFT_RTP ModulePulses_3D ModuleErrorHandling ModuleSystemUtils ModuleString Module_CMFT_CD_IO ModuleIO program~~chargemigrationft~~UsesGraph program~chargemigrationft ChargeMigrationFT ModuleConstants ModuleConstants program~chargemigrationft->ModuleConstants ModuleDiagonalize ModuleDiagonalize program~chargemigrationft->ModuleDiagonalize ModuleErrorHandling ModuleErrorHandling program~chargemigrationft->ModuleErrorHandling ModuleIO ModuleIO program~chargemigrationft->ModuleIO ModulePulses_3D ModulePulses_3D program~chargemigrationft->ModulePulses_3D ModuleString ModuleString program~chargemigrationft->ModuleString ModuleSystemUtils ModuleSystemUtils program~chargemigrationft->ModuleSystemUtils iso_fortran_env iso_fortran_env program~chargemigrationft->iso_fortran_env module~module_cmft_cd_io Module_CMFT_CD_IO program~chargemigrationft->module~module_cmft_cd_io module~module_cmft_rtp Module_CMFT_RTP program~chargemigrationft->module~module_cmft_rtp module~module_cmft_cd_io->ModuleConstants module~module_cmft_cd_io->ModuleErrorHandling module~module_cmft_cd_io->ModulePulses_3D module~module_cmft_cd_io->iso_fortran_env Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Calls program~~chargemigrationft~~CallsGraph program~chargemigrationft ChargeMigrationFT parse_simulation_file parse_simulation_file program~chargemigrationft->parse_simulation_file proc~appenddipole2ftallfile Module_CMFT_CD_IO::AppendDipole2FTAllFile program~chargemigrationft->proc~appenddipole2ftallfile proc~compute_ftcharge_withtimedelay ChargeMigrationFT::Compute_FTCharge_withTimeDelay program~chargemigrationft->proc~compute_ftcharge_withtimedelay proc~compute_ftofdipole_withrespectto_time ChargeMigrationFT::Compute_FTofDipole_withRespectto_Time program~chargemigrationft->proc~compute_ftofdipole_withrespectto_time proc~computeft_dipole_and_atomiccharges ChargeMigrationFT::ComputeFT_Dipole_and_AtomicCharges program~chargemigrationft->proc~computeft_dipole_and_atomiccharges proc~determinenumberoftimes ChargeMigrationFT::DetermineNumberOfTimes program~chargemigrationft->proc~determinenumberoftimes proc~getruntimeparameters Module_CMFT_RTP::GetRunTimeParameters program~chargemigrationft->proc~getruntimeparameters proc~load_dipole Module_CMFT_CD_IO::Load_Dipole program~chargemigrationft->proc~load_dipole proc~load_q_charge_and_write2all Module_CMFT_CD_IO::Load_Q_Charge_and_Write2ALL program~chargemigrationft->proc~load_q_charge_and_write2all proc~load_xuvatomiccharge Module_CMFT_CD_IO::Load_XUVAtomicCharge program~chargemigrationft->proc~load_xuvatomiccharge proc~loadenergies~2 Module_CMFT_CD_IO::LoadEnergies program~chargemigrationft->proc~loadenergies~2 proc~loadftdipole_asfuncitonof_timedelay Module_CMFT_CD_IO::LoadFTDipole_asfuncitonof_TimeDelay program~chargemigrationft->proc~loadftdipole_asfuncitonof_timedelay proc~loadftofchargeasfuncoftimedelay Module_CMFT_CD_IO::LoadFTofChargeasFuncofTimeDelay program~chargemigrationft->proc~loadftofchargeasfuncoftimedelay proc~loadgeometry~3 Module_CMFT_CD_IO::LoadGeometry program~chargemigrationft->proc~loadgeometry~3 proc~regularize_charge_withtimedelay ChargeMigrationFT::Regularize_Charge_withtimedelay program~chargemigrationft->proc~regularize_charge_withtimedelay proc~regularize_dipole_and_atomiccharge1 ChargeMigrationFT::Regularize_Dipole_and_AtomicCharge1 program~chargemigrationft->proc~regularize_dipole_and_atomiccharge1 proc~regularize_dipole_withrespectto_timedelay ChargeMigrationFT::Regularize_Dipole_withRespectto_TimeDelay program~chargemigrationft->proc~regularize_dipole_withrespectto_timedelay proc~regularize_xuvatomiccharge ChargeMigrationFT::Regularize_XUVAtomicCharge program~chargemigrationft->proc~regularize_xuvatomiccharge proc~regularize_xuvdipole ChargeMigrationFT::Regularize_XUVDipole program~chargemigrationft->proc~regularize_xuvdipole proc~savebidimentioal_dipole_spectrum Module_CMFT_CD_IO::SaveBidimentioal_Dipole_Spectrum program~chargemigrationft->proc~savebidimentioal_dipole_spectrum proc~set_cd_io_verbous~3 Module_CMFT_CD_IO::Set_CD_IO_Verbous program~chargemigrationft->proc~set_cd_io_verbous~3 proc~write_bidimentionalchargeftww Module_CMFT_CD_IO::Write_BidimentionalChargeFTww program~chargemigrationft->proc~write_bidimentionalchargeftww proc~writeallatomicchargefttosinglefile Module_CMFT_CD_IO::WriteAllAtomicChargeFTtoSingleFile program~chargemigrationft->proc~writeallatomicchargefttosinglefile proc~writeatomicchargeft Module_CMFT_CD_IO::WriteAtomicChargeFT program~chargemigrationft->proc~writeatomicchargeft proc~writedipoleftfile Module_CMFT_CD_IO::WriteDipoleFTFile program~chargemigrationft->proc~writedipoleftfile p p proc~appenddipole2ftallfile->p add add proc~getruntimeparameters->add get get proc~getruntimeparameters->get parse parse proc~getruntimeparameters->parse printusage printusage proc~getruntimeparameters->printusage setdescription setdescription proc~getruntimeparameters->setdescription errormessage errormessage proc~loadenergies~2->errormessage ncd_phi ncd_phi proc~regularize_charge_withtimedelay->ncd_phi proc~regularize_dipole_and_atomiccharge1->ncd_phi proc~regularize_dipole_withrespectto_timedelay->ncd_phi proc~regularize_xuvatomiccharge->ncd_phi proc~regularize_xuvdipole->ncd_phi proc~writeallatomicchargefttosinglefile->p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Attributes Name Initial character(len=:), allocatable :: InpDir character(len=:), allocatable :: OutDir character(len=:), allocatable :: FileGeometry real(kind=kind(1d0)) :: StepTime real(kind=kind(1d0)) :: StepWidth character(len=:), allocatable :: Ext_field_file logical :: Verbous integer :: nOmegas integer :: nTauOmegas real(kind=kind(1d0)) :: OmegaMin real(kind=kind(1d0)) :: OmegaMax real(kind=kind(1d0)) :: TauOmegaMin real(kind=kind(1d0)) :: TauOmegaMax complex(kind=kind(1d0)), allocatable :: DipoleFTtotal (:,:) complex(kind=kind(1d0)), allocatable :: DipoleFTminus (:,:) complex(kind=kind(1d0)), allocatable :: DipoleFTplus (:,:) complex(kind=kind(1d0)), allocatable :: DipoleFTwt (:,:,:) complex(kind=kind(1d0)), allocatable :: DipoleFTww (:,:,:) complex(kind=kind(1d0)), allocatable :: AtomicChargeFT (:,:,:) complex(kind=kind(1d0)), allocatable :: ChargeFTwt (:,:,:,:) complex(kind=kind(1d0)), allocatable :: ChargeFTww (:,:,:,:) complex(kind=kind(1d0)), allocatable :: XUVCharge (:,:,:) real(kind=kind(1d0)), allocatable :: OmegaVec (:) real(kind=kind(1d0)), allocatable :: TauOmegaVec (:) real(kind=kind(1d0)), allocatable :: tvec (:) integer :: iOmega integer :: ntimes integer :: i real(kind=kind(1d0)) :: tmin real(kind=kind(1d0)) :: tmax character(len=*), parameter :: DIPOLE_FT_PATH_ALL = \"/Dipole/DipoleFT_ALL.csv\" character(len=*), parameter :: CHARGE_FT_PATH_ALL = \"/AtomicCharge/AtomicChargeFT_ALL.csv\" integer, parameter :: GS_IDX = 1 integer :: nStates integer :: uid_AtomicChargeALL integer :: uid real(kind=kind(1d0)), allocatable :: Evec (:) complex(kind=kind(1d0)), allocatable :: zMuEV (:,:) integer :: nAtoms real(kind=kind(1d0)), allocatable :: AtCoord (:,:) character(len=16), allocatable :: AtomName (:) real(kind=kind(1d0)) :: dt integer :: iSim integer :: N_Simulations character(len=64), pointer :: Simulation_Tagv (:) type(pulse_train), pointer :: train (:) complex(kind=kind(1d0)), allocatable :: XUVDipole (:,:) complex(kind=kind(1d0)), allocatable :: XUVDipoleFT (:,:) real(kind=kind(1d0)), allocatable :: AtomicChargeEvolution (:,:,:) complex(kind=kind(1d0)), allocatable :: Debug (:,:,:) integer :: iPol integer :: iAtom integer :: it integer :: iCoord Subroutines subroutine DetermineNumberOfTimes (FileName, tmin, tmax, nTimes) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(out) :: tmin real(kind=kind(1d0)), intent(out) :: tmax integer, intent(out) :: nTimes subroutine Regularize_XUVDipole (XUVDipole, tmin, dt, nTimes, StepTime, StepWidth) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(inout) :: XUVDipole (:,:) real(kind=kind(1d0)), intent(in) :: tmin real(kind=kind(1d0)), intent(in) :: dt integer, intent(in) :: nTimes real(kind=kind(1d0)), intent(in) :: StepTime real(kind=kind(1d0)), intent(in) :: StepWidth subroutine Regularize_XUVAtomicCharge (Charge, tmin, dt, nTimes, StepTime, StepWidth) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(inout) :: Charge (:,:,:) real(kind=kind(1d0)), intent(in) :: tmin real(kind=kind(1d0)), intent(in) :: dt integer, intent(in) :: nTimes real(kind=kind(1d0)), intent(in) :: StepTime real(kind=kind(1d0)), intent(in) :: StepWidth subroutine Regularize_Dipole_and_AtomicCharge1 (Dipole, Charge, tmin, dt, nTimes, StepTime, StepWidth) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(inout) :: Dipole (:,:) real(kind=kind(1d0)), intent(inout) :: Charge (:,:,:) real(kind=kind(1d0)), intent(in) :: tmin real(kind=kind(1d0)), intent(in) :: dt integer, intent(in) :: nTimes real(kind=kind(1d0)), intent(in) :: StepTime real(kind=kind(1d0)), intent(in) :: StepWidth subroutine ComputeFT_Dipole_and_AtomicCharges (DipoleFTminus, AtomicChargeFT, Dipole, OmegaVec, AtomicChargeEvolution, tmin, dt, nTimes, nOmegas) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(out) :: DipoleFTminus (:,:) complex(kind=kind(1d0)), intent(out), allocatable :: AtomicChargeFT (:,:,:) complex(kind=kind(1d0)), intent(in) :: Dipole (:,:) real(kind=kind(1d0)), intent(in) :: OmegaVec (:) real(kind=kind(1d0)), intent(in) :: AtomicChargeEvolution (:,:,:) real(kind=kind(1d0)), intent(in) :: tmin real(kind=kind(1d0)), intent(in) :: dt integer, intent(in) :: nTimes integer, intent(in) :: nOmegas subroutine Regularize_Dipole_withRespectto_TimeDelay (DipoleFTwt, tvec, N_Simulations) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(inout) :: DipoleFTwt (:,:,:) real(kind=kind(1d0)), intent(in) :: tvec (:) integer, intent(in) :: N_Simulations subroutine Compute_FTofDipole_withRespectto_Time (DipoleFTwt, DipoleFTww, tvec, TauOmegaVec, N_Simulations, nTauOmegas) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: DipoleFTwt (:,:,:) complex(kind=kind(1d0)), intent(out), allocatable :: DipoleFTww (:,:,:) real(kind=kind(1d0)), intent(in) :: tvec (:) real(kind=kind(1d0)), intent(in) :: TauOmegaVec (:) integer, intent(in) :: N_Simulations integer, intent(in) :: nTauOmegas subroutine Regularize_Charge_withtimedelay (ChargeFTwt, tvec, nAtoms, N_Simulations) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(inout) :: ChargeFTwt (:,:,:,:) real(kind=kind(1d0)), intent(in) :: tvec (:) integer, intent(in) :: nAtoms integer, intent(in) :: N_Simulations subroutine Compute_FTCharge_withTimeDelay (ChargeFTwt, tvec, ChargeFTww, N_simulations, nOmegas, nAtoms, nTauOmegas, TauOmegaVec) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: ChargeFTwt (:,:,:,:) real(kind=kind(1d0)), intent(in) :: tvec (:) complex(kind=kind(1d0)), intent(out), allocatable :: ChargeFTww (:,:,:,:) integer, intent(in) :: N_simulations integer, intent(in) :: nOmegas integer, intent(in) :: nAtoms integer, intent(in) :: nTauOmegas real(kind=kind(1d0)), intent(in) :: TauOmegaVec (:)","tags":"","loc":"program/chargemigrationft.html"},{"title":"main.f90 – Charge Migration","text":"This file depends on sourcefile~~main.f90~~EfferentGraph sourcefile~main.f90 main.f90 sourcefile~module_becke.f90 Module_Becke.f90 sourcefile~main.f90->sourcefile~module_becke.f90 sourcefile~module_cd_io.f90 Module_CD_IO.f90 sourcefile~main.f90->sourcefile~module_cd_io.f90 sourcefile~modulertp.f90 ModuleRTP.f90 sourcefile~main.f90->sourcefile~modulertp.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code program ChargeMigration !! !! Synopsis: Simulates charge migration in molecular systems under external fields, relaxations, and dephasing effects using the Lindblad master equation. !! !! ------------ !! Key Subroutines: !! ------------ !! * LiouvillianPropagator: This central routine simulates the dynamics of a quantum system subject to an external field. It updates the state density matrix zStatRho using the eigenvalues L0_Eval and eigenvectors L0_LEvec, L0_REvec of the Liouvillian operator. !! !! * ComputeLiouvillian_0: Calculates the time-independent Lindblad superoperator (Liouvillian), crucial in describing the time evolution of the density matrix in an open quantum system. It uses system energy eigenvalues Evec, dipole moment matrix Dmat, and parameters like bath_temperature, dephasing_factor, and relaxation_factor. !! !! * DiagonalizeLindblad_0: Performs diagonalization of the Lindblad superoperator Liouvillian0, determining its eigenvalues L0_Eval and eigenvectors L0_LEvec and L0_REvec. !! !! * HilbertToLiouvilleMatrix and LiouvilleToHilbertMatrix: These subroutines transform between Hilbert space matrices and Liouville space vectors. They are crucial for applying the Liouville operator in the simulations. !! !! * ComputeOrbitalDensity: Builds the orbital density matrix Amat from the state density matrix zStatRho and transition density matrices TDM. !! !! * ComputeAtomicCharges: Calculates new atomic charges QchargeVec from the orbital density OrbitalDensity and Becke matrix BeckeMatrix. !! !! * TabulateChargeDensity: Generates charge density ChDen from the orbital density matrix Amat and orbital table OrbTab. !! !! * ComputeBeckeMatrix: Constructs the Becke matrix BeckeMatrix using weights WeightV, orbital table OrbTab, and barycenter coordinates Bary_center. !! !! * ComputeAtomicWeights: Calculates atomic weights WeightV for a given set of points gridv, atomic coordinates AtCoord, and radii Radius_BS. !! use , intrinsic :: ISO_FORTRAN_ENV use ModuleErrorHandling use ModuleSystemUtils use ModuleString use ModuleIO use ModuleConstants use ModuleDiagonalize use ModulePulses_3D ! !.. Local modules use Module_CM_RTP use Module_CM_CD_IO use Module_Becke use omp_lib implicit none external zgemm , zgemv , system !Explicit declaration of the EXTERNAL attribute is required. !.. Run-time parameters !.. character ( len = :), allocatable :: input_directory character ( len = :), allocatable :: output_directory character ( len = :), allocatable :: molecular_geometry_file integer :: n_times real ( kind ( 1 d0 )) :: t_min real ( kind ( 1 d0 )) :: t_max character ( len = :), allocatable :: Ext_field_file character ( len = :), allocatable :: Weight_File logical :: Verbous logical :: read_precomputed_weights_flag logical :: save_charge_migration_flag integer , allocatable :: ivorb (:) integer :: counted_number_of_orbitals real ( kind ( 1 d0 )) :: dephasing_factor real ( kind ( 1 d0 )) :: relaxation_factor real ( kind ( 1 d0 )) :: bath_temperature integer , parameter :: GS_IDX = 1 !.. Local parameters integer :: nStates , number_of_orbitals , i real ( kind ( 1 d0 )), allocatable :: Evec (:) !.. Dmat(i,j,alpha) = $ \\langle \\varphi_i | \\hat{\\mu}_\\alpha$ | \\varphi_j \\rangle $ real ( kind ( 1 d0 )), allocatable :: Dmat (:, :, :) !.. TDM(j,i,B,A) = $ \\langle A | \\hat{a}_i&#94;\\dagger \\hat{a}_j | B \\rangle $ real ( kind ( 1 d0 )), allocatable :: TDM (:, :, :, :) !.. Expectation Value of the Dipole Moment (Mu) complex ( kind ( 1 d0 )), allocatable :: zMuEV (:, :), zDmat_t (:, :, :) integer :: npts , nAtoms real ( kind ( 1 d0 )), allocatable :: gridv (:, :), AtCoord (:, :) ! 3 x npts real ( kind ( 1 d0 )), allocatable :: OrbTab (:, :) ! 3 x npts !.. Statistical Density Matrix complex ( kind ( 1 d0 )), allocatable :: zStatRho (:, :) real ( kind ( 1 d0 )) :: t , dt real ( kind ( 1 d0 )), allocatable :: ChDen (:), WEIGHTV (:, :) real ( kind ( 1 d0 )), allocatable :: AtomicChargeVec (:, :), AtomicChargeEvolution (:, :, :) character ( len = 30 ) :: istrn character ( len = 16 ), allocatable :: atom_names (:) integer :: iPts , it , iPol , iAtom complex ( kind ( 1 d0 )), allocatable :: Liouvillian0 (:, :), L0_LEvec (:, :), L0_REvec (:, :), L0_Eval (:) !.. Pulse parameters integer :: iSim , N_Simulations , uid character ( len = 64 ), pointer :: Simulation_Tagv (:) character ( len = 1000 ) :: strn type ( pulse_train ), pointer :: train (:) !.. !  B_{ij}&#94;{\\alpha} = \\int d&#94;3r \\phi_i(\\vec{r})\\phi_j(\\vec{r}) w_\\alpha(\\vec{r}) = BeckeMatrix(i,j,alpha) real ( kind ( 1 d0 )), allocatable :: BeckeMatrix (:, :, :, :) real ( kind ( 1 d0 )), allocatable :: OrbitalDensity (:, :) real ( kind ( 1 d0 )), allocatable :: Radius_BS (:) complex ( kind ( 1 d0 )), external :: zdotu !..Test real ( kind ( 1 d0 )) :: Computed_volume integer :: iOrb , jOrb real ( kind ( 1 d0 )), allocatable :: QchargeVec (:, :), R_el (:, :) call GetRunTimeParameters ( input_directory , output_directory , molecular_geometry_file , & n_times , t_min , t_max , Ext_field_file , Verbous , Weight_File , read_precomputed_weights_flag , & save_charge_migration_flag , ivorb , counted_number_of_orbitals , dephasing_factor , relaxation_factor , bath_temperature ) call system ( \"mkdir -p \" // trim ( output_directory )) call system ( \"mkdir -p \" // output_directory // \"/Dipole\" ) call system ( \"mkdir -p \" // output_directory // \"/AtomicCharge\" ) call system ( \"mkdir -p \" // output_directory // \"/ChargeDensity\" ) call system ( \"mkdir -p \" // output_directory // \"/Pulses\" ) call Set_CD_IO_Verbous ( Verbous ) open ( newunit = uid , & file = Ext_field_file , & form = \"formatted\" , & status = \"old\" ) call Parse_Simulation_File ( uid , OUTPUT_UNIT , N_Simulations , Simulation_Tagv , train ) close ( uid ) write ( * , * ) \"N_Simulations=\" , N_Simulations !.. Write and Print the pulse !.. dt = ( t_max - t_min ) / dble ( n_times ) write ( * , * ) \"fortran t_min=\" , t_min write ( * , * ) \"fortran t_min=\" , t_min write ( * , * ) \"fortran t_max=\" , t_max write ( * , * ) \"fortran n_times=\" , n_times write ( * , * ) \"fortran dble(n_times - 1)=\" , dble ( n_times ) write ( * , * ) \"fortran dt=\" , dt call omp_set_num_threads ( 30 ) ! fixme do not hard code, use number of passed or allowed threads !    call omp_set_nested(.true.) !$OMP PARALLEL DO PRIVATE(strn, i) do i = 1 , N_Simulations write ( * , * ) \"Writing pulse \" // trim ( Simulation_Tagv ( i )) strn = trim ( output_directory ) // \"/Pulses/pulse\" // trim ( Simulation_Tagv ( i )) call train ( i )% Write ( strn , t_min , t_max , dt ) !pulse_trainWrite strn = trim ( output_directory ) // \"/Pulses/FTpulse\" // trim ( Simulation_Tagv ( i )) call train ( i )% WriteFTA ( strn ) !pulse_trainWriteFTA end do !$OMP END PARALLEL DO ! call LoadEnergies ( input_directory // \"/ROOT_ENERGIES\" , nStates , Evec ) !.. At the moment, we assume that the TDM are defined as !   $\\rho&#94;{JI}_{nm} = \\langle J | a_n&#94;\\dagger a_m | I \\rangle $ call LoadTDMs ( input_directory // \"/DENSITY_MATRIX\" , input_directory // \"/TRANSITION_DENSITY_MATRIX\" , nStates , number_of_orbitals , TDM ) !.. Load Dipole matrix elements $\\mu_{IJ}$ call LoadDipoleME ( Dmat , input_directory , nStates ) allocate ( zDmat_t ( nStates , nStates , 3 )) do i = 1 , 3 zDmat_t (:, :, i ) = Z1 * transpose ( Dmat (:, :, i )) enddo if ( number_of_orbitals . ne . counted_number_of_orbitals ) then ! TODO change to assert method of ASTRA write ( * , * ) \"Number of orbitals given by '-iOrb' do not match number of orbitals in active the active space\" stop endif !.. Load Geometry,volume, Grid and Orbitals call LoadGeometry ( nAtoms , AtCoord , molecular_geometry_file , atom_names ) call LoadGrid ( input_directory // \"/gridcoord.csv\" , npts , gridv ) ! $G=\\{\\vec{r}_i, i=1,\\ldots,N_{G}\\}$ call Computevolume ( nPts , Computed_volume , gridv ) ! Should probably check that this computed volume is the same as the one given in the input file !.. Load Orbitals call LoadOrbitals ( input_directory , number_of_orbitals , npts , OrbTab ) ! $\\varphi_n(\\vec{r}_i)$ !.. Compute and Write | or Read Becke's Weights ! call AtomicRadius_Bragg_Slater_Becke ( atom_names , nAtoms , Radius_BS ) if ( read_precomputed_weights_flag == . True .) then call Read_Weights ( Weight_File , WEIGHTV , nAtoms , nPts ) else call ComputeAtomicWeights ( nPts , gridv , nAtoms , AtCoord , WeightV , Radius_BS ) call Write_Weights ( output_directory // \"/\" // Weight_File // \"_\" // output_directory // \".csv\" , & WEIGHTV , gridv , nAtoms , nPts , atom_names ) endif !.. Compute Berycenter of Atmoic Charges call Compute_R_el ( gridv , WeightV , OrbTab , R_el ) call Write_R_el_bc ( output_directory , atom_names , nAtoms , R_el ) !.. Compute Becke's Matrix call ComputeBeckeMatrix ( WeightV , OrbTab , BeckeMatrix , AtCoord ) !using electronic barycenter or AtCoord for the nuclear barycenter write ( * , * ) \"allocating Atomic Charge matrixes\" allocate ( AtomicChargeEvolution ( 3 , nAtoms , n_times )) !.. Compute Liouvillian and Diagonalizes it write ( * , * ) \"Computing Liouvillian\" call ComputeLiouvillian_0 ( Evec , Dmat , Liouvillian0 , bath_temperature , dephasing_factor , relaxation_factor ) call DiagonalizeLindblad_0 ( Liouvillian0 , L0_Eval , L0_LEvec , L0_REvec ) allocate ( zStatRho ( nStates , nStates )) allocate ( ChDen ( nPts )) allocate ( zMuEV ( 3 , n_times )) zMuEV = Z0 write ( * , * ) \"Starting Sim Loop\" Sim_loop : do iSim = 1 , N_Simulations ! Lets keep a percentage write of the simulation only 2 digits after the decimal point write ( * , '(A, F0.2, A, I0, A)' ) \"Simulation progress: \" , 10 0.d0 * iSim / ( N_Simulations ) if ( save_charge_migration_flag ) then write ( * , * ) \"Computing Charge Migration for simulation \" , iSim , trim ( Simulation_tagv ( iSim )) end if !.. Load Initial State zStatRho = Z0 zStatRho ( GS_IDX , GS_IDX ) = 1.d0 !.. Time cycle time_loop : do it = 1 , n_times ! t = t_min + dt * dble ( it - 1 ) !.. Computes the excitation density wrt ground state zStatRho ( GS_IDX , GS_IDX ) = zStatRho ( GS_IDX , GS_IDX ) - 1.d0 !.. Evaluates the expectation value of the dipole as a function of time !            write(*, *) it, iSim, 100.d0 * iSim / (N_Simulations) do iPol = 1 , 3 zMuEV ( iPol , it ) = zdotu ( nStates * nStates , zStatRho , 1 , zDmat_t ( 1 , 1 , iPol ), 1 ) enddo ! call ComputeOrbitalDensity ( zStatRho , TDM , OrbitalDensity ) ! call ComputeAtomicCharges ( OrbitalDensity , BeckeMatrix , AtomicChargeVec ) AtomicChargeVec = AtomicChargeVec * Computed_volume AtomicChargeEvolution (:, :, it ) = AtomicChargeVec !$> this needs to be be moved outside of this module or loop since is costly and can be computed when needed if ( save_charge_migration_flag ) then call TabulateChargeDensity ( OrbitalDensity , OrbTab , ChDen ) write ( istrn , \"(f12.4)\" ) t !..Makes new directory inside of ChargeDensity directory for each simulation call system ( \"mkdir -p \" // output_directory // \"/ChargeDensity/ChDenSim\" // trim ( Simulation_tagv ( iSim ))) call Write_Charge_Density (& output_directory // \"/ChargeDensity/ChDenSim\" // trim ( Simulation_tagv ( iSim )) & // \"/ChDen\" // trim ( adjustl ( istrn )) // \".csv\" , & nPts , gridv , ChDen , Weightv , nAtoms , atom_names ) endif ! zStatRho ( GS_IDX , GS_IDX ) = zStatRho ( GS_IDX , GS_IDX ) + 1.d0 ! if ( it == n_times ) exit time_loop ! call LiouvillianPropagator ( L0_Eval , L0_LEvec , L0_REvec , zStatRho ) ! enddo time_loop !.. Save Dipole to filerc call Write_Dipole ( output_directory // \"/Dipole/Dipole\" // trim ( Simulation_tagv ( iSim )) // \".csv\" , zMuEV , n_times , t_min , dt ) !.. Save Q_Charge call Write_Q_Charge ( output_directory // \"/AtomicCharge/AtomicCharge\" // trim ( Simulation_tagv ( iSim )) // \".csv\" , & AtomicChargeEvolution , n_times , t_min , dt , nAtoms , atom_names ) end do Sim_loop ! call Write_Summary ( output_directory // \"/Simulation_Summary\" , nPts , nAtoms , Computed_volume , n_times , t_min , t_max , atom_names , Radius_BS , number_of_orbitals , OrbTab ) stop contains ! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ! Lindblad Equation - LiouvillianPropagator: ! ---------------------------------------------------- subroutine LiouvillianPropagator ( L0_Eval , L0_LEvec , L0_REvec , zStatRho ) !! The central routine in simulating the dynamics of a quantum system subject to an external field, describing the time evolution of the system in Liouville space. !! Build the time-independent Lindblad superoperator !! \\begin{equation} !!\\dot{\\rho}(t) = -i[H, \\rho(t)] + \\sum_{mn} \\Bigl( L_{mn} \\rho(t) L_{mn}&#94;\\dagger - \\frac{1}{2} L_{mn}&#94;\\dagger L_{mn} \\rho(t) - \\frac{1}{2} \\rho(t) L_{mn}&#94;\\dagger L_{mn} \\Bigr) !!\\end{equation} !! !!Where: !! !! *  \\dot{\\rho}(t)  is the time derivative of the density matrix. !! *  [H, \\rho(t)]  represents the commutator of the Hamiltonian H and the density matrix \\rho(t), which is the standard von Neumann equation describing the unitary evolution of the system, the Liouvillian. !! * (L_{mn} are the Lindblad (or jump) operators. These represent the different ways the environment can affect the system, leading to decoherence and relaxation. !! * The terms with L_{mn} \\rho(t) L_{mn}&#94;\\dagger describe the action of the environment on the system, and thus are responsible for transitions induced by the bath. !! * The terms with L_{mn}&#94;\\dagger L_{mn} \\rho(t) and \\rho(t) L_{mn}&#94;\\dagger L_{mn} subtract off double-counted terms and ensure the trace of the density matrix remains equal to 1. Behaving as \"decoherence\" processes where the system's off-diagonal elements (coherences) are diminished due to interactions with the environment. !! *  H = H_0 + (\\hat{\\epsilon}\\cdot\\vec{\\mu}) E(t) !! !! For pure dephasing without relaxation: !!   L_{nm} = \\delta_{mn} \\sqrt{\\gamma_m/2} | m \\rangle \\langle m | !! !! For relaxation without pure dephasing: !!   L_{mn} = (1-\\delta_{nm}) \\sqrt{\\gamma_{mn}} |m\\rangle \\langle n| !!   subject to the constraint \\gamma_{mn} = e&#94;{-\\beta \\omega_{mn}} \\gamma_{nm} !!   where \\beta = 1/(k_B T) !! !! Key steps in the subroutine: !! !!   * Transform the initial density matrix zStatRho into Liouville space. !!   * Propagate the transformed matrix in the absence of external fields for a time interval dt/2. !!   * Convert the propagated matrix back into Hilbert space. !!   * Consider the system's interaction with an external electric field by applying rotations in the Hilbert space. !!   * Diagonalize the density matrix to determine the pure states it comprises. !!   * Propagate each individual state under the influence of the external field. !!   * Re-form the density matrix from the propagated pure states. !!   * Repeat steps 1-3 for the re-formed density matrix to complete the propagation process over the time interval dt. !! !! Notes: !! !!   * This subroutine heavily relies on various matrix operations and makes use of other subroutines such as HilbertToLiouvilleMatrix, ZGEMV, LiouvilleToHilbertMatrix, DiagonalizeDipole, ZGEMM, Short_ZHEEV, and ExternalElectricFieldCart, which are not defined within this subroutine and are expected to be defined elsewhere. !!   * Important to note is that certain variables used within this subroutine, such as dt, t, iSim, train, Z1, Zi, Z0, nStates, and Dmat, are not defined or passed as arguments, implying that they are either global variables or passed from a higher-level routine that calls this function. !!   * The FIRST_CALL logical variable is used to execute certain lines of code only during the first invocation of the subroutine, primarily for the allocation and initialization of arrays. !!   * This subroutine effectively encapsulates a single iteration or time step of the simulation. For a complete simulation over a given time period, this subroutine would typically be called repeatedly in a loop. ! complex ( kind ( 1 d0 )), intent ( in ) :: L0_LEvec (:, :) !! a complex array holding the left eigenvectors of the Liouville operator. complex ( kind ( 1 d0 )), intent ( in ) :: L0_REvec (:, :) !! a complex array holding the right eigenvectors of the Liouville operator. complex ( kind ( 1 d0 )), intent ( in ) :: L0_Eval (:) !! a complex array holding the eigenvalues of the Liouville operator. complex ( kind ( 1 d0 )), intent ( inout ) :: zStatRho (:, :) !! a complex array holding the initial state density matrix of the quantum system. The array is updated within the subroutine, and hence is an input/output parameter. logical , save :: FIRST_CALL = . TRUE . integer :: nLiou !! the size of the L0_Eval array, which represents the dimension of the Liouville space. integer :: i_state , j real ( kind ( 1 d0 )) :: EFieldX , EFieldY , EFieldZ !!real numbers representing the components of the external electric field at time t + dt/2. complex ( kind ( 1 d0 )), allocatable , save :: zmat1 (:, :), zmat2 (:, :) complex ( kind ( 1 d0 )), allocatable , save :: zPureMat (:, :) real ( kind ( 1 d0 )), allocatable , save :: Epure (:) complex ( kind ( 1 d0 )), allocatable , save :: zUMAT_DX (:, :), zUMAT_DY (:, :), zUMAT_DZ (:, :) complex ( kind ( 1 d0 )), allocatable , save :: zUMAT_DYs_DX (:, :), zUMAT_DZs_DY (:, :) complex ( kind ( 1 d0 )), allocatable , save :: RhoVec2 (:), RhoVec (:) real ( kind ( 1 d0 )), allocatable , save :: EVEC_DX (:), EVEC_DY (:), EVEC_DZ (:) nLiou = size ( L0_Eval , 1 ) if ( FIRST_CALL ) then allocate ( RhoVec ( nLiou )) allocate ( RhoVec2 ( nLiou )) RhoVec = Z0 RhoVec2 = Z0 endif call HilbertToLiouvilleMatrix ( zStatRho , RhoVec ) !.. First half of the field-free propagation in Liouville Space across an interval dt/2 call ZGEMV ( \"C\" , nLiou , nLiou , Z1 , L0_LEvec , nLiou , RhoVec , 1 , Z0 , RhoVec2 , 1 ) RhoVec2 = RhoVec2 * exp ( - Zi * L0_Eval * dt / 2.d0 ) call ZGEMV ( \"N\" , nLiou , nLiou , Z1 , L0_REvec , nLiou , RhoVec2 , 1 , Z0 , RhoVec , 1 ) call LiouvilleToHilbertMatrix ( RhoVec , zStatRho ) nStates = size ( zStatRho , 1 ) if ( FIRST_CALL ) then allocate ( zmat1 ( nStates , nStates ), zmat2 ( nStates , nStates ), Epure ( nStates ), zPureMat ( nStates , nStates )) zmat1 = 0.d0 zmat2 = 0.d0 Epure = 0.d0 zPureMat = 0.d0 !.. Diagonalizes the dipole matrices call DiagonalizeDipole ( Dmat , & EVEC_DX , zUMAT_DX , & EVEC_DY , zUMAT_DY , & EVEC_DZ , zUMAT_DZ ) ! !.. Computes combined matrices allocate ( zUMAT_DYs_DX ( nStates , nStates )) zUMAT_DYs_DX = Z0 call ZGEMM ( \"C\" , \"N\" , nStates , nStates , nStates , Z1 , zUMAT_DY , nStates , & zUMAT_DX , nStates , Z0 , zUMAT_DYs_DX , nStates ) allocate ( zUMAT_DZs_DY ( nStates , nStates )) zUMAT_DZs_DY = Z0 call ZGEMM ( \"C\" , \"N\" , nStates , nStates , nStates , Z1 , zUMAT_DZ , nStates , & zUMAT_DY , nStates , Z0 , zUMAT_DZs_DY , nStates ) FIRST_CALL = . FALSE . endif !.. Diagonalizes the density matrix to determine the pure states it is composed of zPureMat = zStatRho call Short_ZHEEV ( nStates , zPureMat , EPure ) ! !.. Propagates the individual states in the presence of the field EFieldX = ExternalElectricFieldCart ( t + dt / 2.d0 , train ( iSim ), 1 ) EFieldY = ExternalElectricFieldCart ( t + dt / 2.d0 , train ( iSim ), 2 ) EFieldZ = ExternalElectricFieldCart ( t + dt / 2.d0 , train ( iSim ), 3 ) zmat1 = Z0 zmat2 = Z0 call ZGEMM ( \"C\" , \"N\" , nStates , nStates , nStates , Z1 , zUMAT_DX , nStates , zPureMat , nStates , Z0 , zmat1 , nStates ) do i = 1 , nStates zmat1 ( i , :) = exp ( - Zi * EfieldX * EVEC_DX ( i ) * dt / 2.d0 ) * zmat1 ( i , :) enddo call ZGEMM ( \"N\" , \"N\" , nStates , nStates , nStates , Z1 , zUMAT_DYs_DX , nStates , zmat1 , nStates , Z0 , zmat2 , nStates ) do i = 1 , nStates zmat2 ( i , :) = exp ( - Zi * EfieldY * EVEC_DY ( i ) * dt / 2.d0 ) * zmat2 ( i , :) enddo call ZGEMM ( \"N\" , \"N\" , nStates , nStates , nStates , Z1 , zUMAT_DZs_DY , nStates , zmat2 , nStates , Z0 , zmat1 , nStates ) do i = 1 , nStates zmat1 ( i , :) = exp ( - Zi * EfieldZ * EVEC_DZ ( i ) * dt ) * zmat1 ( i , :) enddo call ZGEMM ( \"C\" , \"N\" , nStates , nStates , nStates , Z1 , zUMAT_DZs_DY , nStates , zmat1 , nStates , Z0 , zmat2 , nStates ) do i = 1 , nStates zmat2 ( i , :) = exp ( - Zi * EfieldY * EVEC_DY ( i ) * dt / 2.d0 ) * zmat2 ( i , :) enddo call ZGEMM ( \"C\" , \"N\" , nStates , nStates , nStates , Z1 , zUMAT_DYs_DX , nStates , zmat2 , nStates , Z0 , zmat1 , nStates ) do i = 1 , nStates zmat1 ( i , :) = exp ( - Zi * EfieldX * EVEC_DX ( i ) * dt / 2.d0 ) * zmat1 ( i , :) enddo call ZGEMM ( \"N\" , \"N\" , nStates , nStates , nStates , Z1 , zUMAT_DX , nStates , zmat1 , nStates , Z0 , zPureMat , nStates ) !LiouvillianPropagator !.. Form the density matrix again zStatRho = Z0 do i_state = 1 , nStates do j = 1 , nStates zStatRho (:, j ) = zStatRho (:, j ) + EPure ( i_state ) * zPureMat (:, i_state ) * conjg ( zPureMat ( j , i_state )) enddo enddo call HilbertToLiouvilleMatrix ( zStatRho , RhoVec ) !.. Second half of the field-free propagation in Liouville Space across an interval dt/2 call ZGEMV ( \"C\" , nLiou , nLiou , Z1 , L0_LEvec , nLiou , RhoVec , 1 , Z0 , RhoVec2 , 1 ) RhoVec2 = RhoVec2 * exp ( - Zi * L0_Eval * dt / 2.d0 ) call ZGEMV ( \"N\" , nLiou , nLiou , Z1 , L0_REvec , nLiou , RhoVec2 , 1 , Z0 , RhoVec , 1 ) call LiouvilleToHilbertMatrix ( RhoVec , zStatRho ) end subroutine LiouvillianPropagator ! subroutine ComputeLiouvillian_0 ( Evec , Dmat , Liouvillian0 , bath_temperature , dephasing_factor , relaxation_factor ) !! Calculates the time-independent Lindblad superoperator (Liouvillian), a crucial element in the Lindblad master equation, used for describing the time evolution of the density matrix of a quantum system in an open quantum system framework. !! !! Key steps in the subroutine: !! * First, the subroutine initializes parameters and allocates space for the Liouvillian. !! * The unitary part of the Liouvillian is computed, based on the system Hamiltonian eigenvalues. !! * The subroutine calculates the pair relaxation rates and the dephasing rates for all pairs of states, taking into account the energy levels, dipole moment matrix, and input parameters related to dephasing and relaxation. !! * The total relaxation rate for each state is computed as the sum of the pair relaxation rates involving the state. !! * Finally, the dissipative part of the Liouvillian, capturing the effects of the interaction of the system with its environment, is computed based on these relaxation rates. !! !! Note: Please note that this subroutine computes the Lindblad superoperator for a specific case where the relaxation and dephasing rates are assumed to be constants and the Lindblad operators are assumed to be proportional to the dipole moment operator. real ( kind ( 1 d0 )), intent ( in ) :: Evec (:) !! The array of energy eigenvalues of the system's Hamiltonian. real ( kind ( 1 d0 )), intent ( in ) :: Dmat (:, :, :) !! The dipole moment matrix of the system. complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: Liouvillian0 (:, :) !! The computed Liouvillian superoperator. It's an output parameter that's updated in the subroutine. real ( kind ( 1 d0 )), intent ( in ) :: dephasing_factor !! The factor representing dephasing effects in the system. real ( kind ( 1 d0 )), intent ( in ) :: relaxation_factor !! The factor representing relaxation effects in the system. real ( kind ( 1 d0 )), intent ( in ) :: bath_temperature !! The temperature of the bath or environment interacting with the quantum system. integer :: nLiou , nStates , i , j , iLiou , i1 , i2 , iLiou1 , iLiou2 !.. Dephasing and Relaxation Constants real ( kind ( 1 d0 )), allocatable :: PairGamma (:, :), TotalGamma (:) !! The arrays containing the pair relaxation rates and the total relaxation rates, respectively. real ( kind ( 1 d0 )) :: AverageDipole , dBuf real ( kind ( 1 d0 )) :: BETA !! The inverse temperature factor (1/kT) with k being the Boltzmann constant and T being the temperature. BETA = 1.d0 / ( BOLTZMANN_CONSTANT_auK * bath_temperature ) nStates = size ( Evec , 1 ) nLiou = nStates ** 2 allocate ( Liouvillian0 ( nLiou , nLiou )) Liouvillian0 = Z0 ! !.. Unitary component do iLiou = 1 , nLiou call LiouvilleToHilbertIndexes ( iLiou , i , j ) Liouvillian0 ( iLiou , iLiou ) = Evec ( i ) - Evec ( j ) end do ! !.. Determine the factors \\gamma_{mn} allocate ( PairGamma ( nStates , nStates )) PairGamma = 0.d0 do i = 1 , nStates ! dBuf = 0.d0 do j = 1 , nStates if ( j == i ) cycle ! AverageDipole = sqrt ( sum ( Dmat ( i , j , :) ** 2 ) / 3.d0 ) dBuf = dBuf + AverageDipole ! !.. Relaxation Factor PairGamma ( i , j ) = relaxation_factor * AverageDipole if ( Evec ( i ) > Evec ( j )) PairGamma ( i , j ) = PairGamma ( i , j ) * exp ( - BETA * ( Evec ( i ) - Evec ( j ))) ! enddo ! !.. Dephasing Factor PairGamma ( i , i ) = dephasing_factor * sqrt ( dBuf ) ! enddo ! !.. Determines \\Gamma_i = \\sum_m \\gamma_{mi} allocate ( TotalGamma ( nStates )) do i = 1 , nStates TotalGamma ( i ) = sum ( PairGamma (:, i )) enddo ! !.. Dissipative component do iLiou = 1 , nLiou call LiouvilleToHilbertIndexes ( iLiou , i , j ) Liouvillian0 ( iLiou , iLiou ) = Liouvillian0 ( iLiou , iLiou ) - Zi * ( TotalGamma ( i ) + TotalGamma ( j )) / 2.d0 enddo do i1 = 1 , nStates call HilbertToLiouvilleIndexes ( i1 , i1 , iLiou1 ) do i2 = 1 , nStates call HilbertToLiouvilleIndexes ( i2 , i2 , iLiou2 ) Liouvillian0 ( iLiou1 , iLiou2 ) = Liouvillian0 ( iLiou1 , iLiou2 ) + Zi * PairGamma ( i1 , i2 ) enddo enddo end subroutine ComputeLiouvillian_0 ! subroutine DiagonalizeLindblad_0 ( Liouvillian0 , L0_Eval , L0_LEvec , L0_REvec ) !! Performs the diagonalization of the time-independent !! Lindblad superoperator (Liouvillian0). The diagonalization is performed using the !! Short_Diag subroutine, and the results are printed to the standard output. !! This routine also checks that the product of right and conjugate transpose of left eigenvectors !! is an identity matrix (a necessary condition for a valid diagonalization). !! !! Note: The input matrix Liouvillian0 is also modified during the execution of this subroutine. complex ( kind ( 1 d0 )), intent ( inout ) :: Liouvillian0 (:, :) !! A complex square matrix representing the Lindblad superoperator to be diagonalized. complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: L0_LEvec (:, :) !! A complex square matrix that will hold the left eigenvectors of Liouvillian0. complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: L0_REvec (:, :) !! A complex square matrix that will hold the right eigenvectors of Liouvillian0. complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: L0_Eval (:) !! A complex vector that will hold the eigenvalues of Liouvillian0. complex ( kind ( 1 d0 )), allocatable :: zmat (:, :) integer :: nLiou , iLiou , n , i , j nLiou = size ( Liouvillian0 , 1 ) allocate ( L0_LEvec ( nLiou , nLiou )) allocate ( L0_REvec ( nLiou , nLiou )) allocate ( L0_Eval ( nLiou )) L0_LEvec = Z0 L0_REvec = Z0 L0_Eval = Z0 call Short_Diag ( nLiou , Liouvillian0 , L0_Eval , L0_LEvec , L0_REvec ) do iLiou = 1 , nLiou write ( * , * ) iLiou , L0_Eval ( iLiou ) enddo !.. Test that U_R U_L&#94;\\dagger is indeed the identity n = nLiou allocate ( zmat ( n , n )) zmat = Z0 call ZGEMM ( \"N\" , \"T\" , n , n , n , Z1 , L0_REvec , n , L0_LEvec , n , Z0 , zmat , n ) do i = 1 , n zmat ( i , i ) = zmat ( i , i ) - Z1 enddo write ( * , * ) \"|U_R U_L&#94;+ -1|_1 = \" , sum ( abs ( zmat )) end subroutine DiagonalizeLindblad_0 ! !<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ! Hilbert and Liouville space transformations subroutines ! ---------------------------------------------------- subroutine HilbertToLiouvilleMatrix ( RhoMat , RhoVec ) !! Transforms a matrix from Hilbert space into a vector !! in Liouville space. The transformation is performed by looping through each element of the input !! matrix and mapping it to the corresponding position in the output vector using the subroutine !! HilbertToLiouvilleIndexes. This transformation is required for the application of the Liouville operator. !! complex ( kind ( 1 d0 )), intent ( in ) :: RhoMat (:, :) !! A complex matrix representing the state in Hilbert space. complex ( kind ( 1 d0 )), intent ( out ) :: RhoVec (:) !! A complex vector representing the transformed state in Liouville space. integer :: i , j , n , iPair n = size ( RhoMat , 1 ) do i = 1 , n do j = 1 , n call HilbertToLiouvilleIndexes ( i , j , iPair ) RhoVec ( iPair ) = RhoMat ( i , j ) enddo enddo end subroutine HilbertToLiouvilleMatrix ! subroutine LiouvilleToHilbertMatrix ( RhoVec , RhoMat ) !! Performs the inverse transformation of !! HilbertToLiouvilleMatrix, transforming a vector in Liouville space back into a matrix in !! Hilbert space. The transformation is performed by looping through each element of the output matrix !! and assigning it the corresponding value from the input vector using the subroutine !! HilbertToLiouvilleIndexes. !! complex ( kind ( 1 d0 )), intent ( in ) :: RhoVec (:) !! A complex vector representing the state in Liouville space. complex ( kind ( 1 d0 )), intent ( out ) :: RhoMat (:, :) !! A complex matrix representing the transformed state in Hilbert space. integer :: i , j , n , iPair n = size ( RhoMat , 1 ) RhoMat = Z0 do j = 1 , n do i = 1 , n call HilbertToLiouvilleIndexes ( i , j , iPair ) RhoMat ( i , j ) = RhoVec ( iPair ) enddo enddo end subroutine LiouvilleToHilbertMatrix ! subroutine HilbertToLiouvilleIndexes ( i , j , iPair ) !! Transforms matrix indices in Hilbert space into a !! single index in Liouville space. The transformation is dependent on the relative values of the !! input indices. The resulting single index is required for the transformation from Hilbert to !! Liouville space. !! integer , intent ( in ) :: i , j !! Integers representing the indices in Hilbert space. integer , intent ( out ) :: iPair !! An integer representing the corresponding single index in Liouville space. if ( i == j ) then iPair = i ** 2 elseif ( i < j ) then iPair = ( j - 1 ) ** 2 + i else iPair = ( i - 1 ) * i + j endif end subroutine HilbertToLiouvilleIndexes ! subroutine LiouvilleToHilbertIndexes ( iPair , i , j ) !! Takes in a single integer index in Liouville space !! and converts it into a pair of matrix indices in Hilbert space. The indices are calculated by !! decomposing the given Liouville index into a square plus a remainder, which are then used to !! calculate the corresponding Hilbert indices. !! integer , intent ( in ) :: iPair !! An integer representing a single index in Liouville space. integer , intent ( out ) :: i , j !! Integers representing the corresponding indices in Hilbert space. ! Intermediate variables to hold the square root and square of iPair integer :: n , n2 ! Calculate the integer square root of iPair n = int ( sqrt ( 1.d0 * iPair )) ! Calculate the square of the integer square root n2 = n ** 2 ! Check if iPair is a perfect square if ( n2 == iPair ) then i = n j = n ! Check if the difference between iPair and n2 is less than or equal to n elseif ( iPair - n2 <= n ) then i = iPair - n2 j = n + 1 ! Otherwise, the difference is greater than n else i = n + 1 j = iPair - n2 - n endif end subroutine LiouvilleToHilbertIndexes !<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ! Called ... rn not going to organize these yet ... figure out what module they go to ! ---------------------------------------------------- subroutine DiagonalizeDipole ( Dmat , EVEC_DX , zUMAT_DX , EVEC_DY , zUMAT_DY , EVEC_DZ , zUMAT_DZ ) !! Purpose: Diagonalizes the dipole matrices in the X, Y, and Z directions. Takes the dipole moment matrix as !! input and computes the diagonalized matrices and their eigenvalues. !! !! Internal Operations: Allocation of matrices, diagonalization using Short_Diag, and assignment of the resultant matrices and eigenvalues. real ( kind ( 1 d0 )), intent ( in ) :: Dmat (:, :, :) !!  Real 3D array representing the dipole moment matrix. complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: zUMAT_DX (:, :), zUMAT_DY (:, :), zUMAT_DZ (:, :) !! Complex 2D arrays for the diagonalized matrices in X, Y, and Z directions, respectively. real ( kind ( 1 d0 )), allocatable , intent ( out ) :: EVEC_DX (:), EVEC_DY (:), EVEC_DZ (:) !! Real 1D arrays for the eigenvalues of the dipoles in X, Y, and Z directions. ! real ( kind ( 1 d0 )), allocatable :: rmat (:, :) integer :: nStates nStates = size ( Dmat , 1 ) allocate ( rmat ( nStates , nStates )) ! !.. X dipole if ( allocated ( zUMAT_DX )) deallocate ( zUMAT_DX ) if ( allocated ( EVEC_DX )) deallocate ( EVEC_DX ) allocate ( zUMAT_DX ( nStates , nStates ), EVEC_DX ( nStates )) rmat = Dmat (:, :, 1 ) EVEC_DX = 0.d0 call Short_Diag ( nStates , rmat , EVEC_DX ) zUMAT_DX = Z1 * rmat ! !.. Y dipole if ( allocated ( zUMAT_DY )) deallocate ( zUMAT_DY ) if ( allocated ( EVEC_DY )) deallocate ( EVEC_DY ) allocate ( zUMAT_DY ( nStates , nStates ), EVEC_DY ( nStates )) rmat = Dmat (:, :, 2 ) EVEC_DY = 0.d0 call Short_Diag ( nStates , rmat , EVEC_DY ) zUMAT_DY = Z1 * rmat ! !.. Z dipole if ( allocated ( zUMAT_DZ )) deallocate ( zUMAT_DZ ) if ( allocated ( EVEC_DZ )) deallocate ( EVEC_DZ ) allocate ( zUMAT_DZ ( nStates , nStates ), EVEC_DZ ( nStates )) rmat = Dmat (:, :, 3 ) EVEC_DZ = 0.d0 call Short_Diag ( nStates , rmat , EVEC_DZ ) zUMAT_DZ = Z1 * rmat ! deallocate ( rmat ) end subroutine DiagonalizeDipole subroutine Computevolume ( nPts , volume , gridv ) integer , intent ( in ) :: nPts real ( kind ( 1 d0 )), intent ( out ) :: volume real ( kind ( 1 d0 )), allocatable , intent ( in ) :: gridv (:, :) real ( kind ( 1 d0 )) :: coord1 , coord2 , delta real ( kind ( 1 d0 )), parameter :: threshold = 1 d - 10 integer :: iPts , iCoord volume = 1.d0 do iCoord = 1 , 3 coord1 = gridv ( iCoord , 1 ) delta = 1 d10 do iPts = 2 , nPts coord2 = gridv ( iCoord , iPts ) if ( abs ( coord1 - coord2 ) > threshold ) then delta = min ( delta , abs ( coord1 - coord2 )) endif enddo volume = volume * delta enddo end subroutine Computevolume subroutine Compute_R_el ( gridv , WeightV , OrbTab , R_el ) real ( kind ( 1 d0 )), allocatable , intent ( in ) :: OrbTab (:, :), gridv (:, :), WeightV (:, :) real ( kind ( 1 d0 )), allocatable , intent ( out ) :: R_el (:, :) real ( kind ( 1 d0 )) :: sum , m , r , sum1 integer :: nAtoms , nPts , number_of_orbitals , iOrb , jOrb , uid nAtoms = size ( WeightV , 2 ) nPts = size ( WeightV , 1 ) number_of_orbitals = size ( OrbTab , 2 ) ! write ( * , \"(a)\" ) \"Computing Barycenters of the Atomic Charges\" ! allocate ( R_el ( 3 , nAtoms )) do iAtom = 1 , nAtoms do iPol = 1 , 3 sum = 0.d0 sum1 = 0.d0 do iOrb = 1 , number_of_orbitals do jOrb = 1 , number_of_orbitals do iPts = 1 , nPts m = WeightV ( iPts , iAtom ) * OrbTab ( iPts , iOrb ) * OrbTab ( iPts , jOrb ) r = gridv ( iPol , iPts ) sum = sum + (( m * r )) sum1 = sum1 + m end do end do end do ! R_el ( iPol , iAtom ) = sum / sum1 end do end do end subroutine Compute_R_el subroutine AtomicRadius_Bragg_Slater_Becke ( atom_names , nAtom , Radius_BS ) real ( kind ( 1 d0 )), allocatable , intent ( out ) :: Radius_BS (:) integer , intent ( in ) :: nAtom character ( len = 16 ), intent ( in ) :: atom_names (:) integer :: iAtom allocate ( Radius_BS ( nAtom )) do iAtom = 1 , nAtom Radius_BS ( iAtom ) = Radius_Table ( atom_names ( iAtom )) end do end subroutine AtomicRadius_Bragg_Slater_Becke subroutine ComputeAtomicCharges ( OrbitalDensity , BeckeMatrix , QchargeVec ) real ( kind ( 1 d0 )), intent ( in ) :: OrbitalDensity (:, :) real ( kind ( 1 d0 )), intent ( in ) :: BeckeMatrix (:, :, :, :) real ( kind ( 1 d0 )), allocatable , intent ( out ) :: QchargeVec (:, :) integer :: iAtom , nAtoms , number_of_orbitals , jOrb , iOrb , iPol real ( kind ( 1 d0 )), external :: DDOT real ( kind ( 1 d0 )) :: dsum number_of_orbitals = size ( BeckeMatrix , 2 ) nAtoms = size ( BeckeMatrix , 4 ) allocate ( QchargeVec ( 3 , nAtoms )) QchargeVec = 0.d0 do iPol = 1 , 3 do iAtom = 1 , nAtoms do jOrb = 1 , number_of_orbitals do iOrb = 1 , number_of_orbitals QchargeVec ( iPol , iAtom ) = QchargeVec ( iPol , iAtom ) + OrbitalDensity ( iOrb , jOrb ) & * BeckeMatrix ( iPol , iOrb , jOrb , iAtom ) end do end do enddo end do end subroutine ComputeAtomicCharges subroutine ComputeOrbitalDensity ( zStatRho , TDM , Amat ) !! Build the expansion Matrix !!   A_{nm}(t) = \\sum_{IJ} P_{IJ}(t) \\rho&#94;{JI}_{nm} !!   where P_{IJ}(t) is the solution of a suitable Master equation, starting from P_{IJ}(0) !!   Here, we will neglect relaxation and decoherence and hence P_{IJ}(t) = P_{IJ}(0) e&#94;{-i\\omega_{IJ}t} !!   where \\omega_{IJ}=E_I-E_J complex ( kind ( 1 d0 )), intent ( in ) :: zStatRho (:, :) real ( kind ( 1 d0 )), intent ( in ) :: TDM (:, :, :, :) real ( kind ( 1 d0 )), allocatable , intent ( out ) :: Amat (:, :) integer :: number_of_orbitals , ii_orb , ij_orb , ii_state , ij_state number_of_orbitals = size ( TDM , 1 ) if ( allocated ( Amat )) then if ( abs ( size ( Amat , 1 ) - number_of_orbitals ) + abs ( size ( Amat , 2 ) - number_of_orbitals ) > 0 ) then deallocate ( Amat ) allocate ( Amat ( number_of_orbitals , number_of_orbitals )) endif else allocate ( Amat ( number_of_orbitals , number_of_orbitals )) endif ! Amat = 0.d0 do ii_orb = 1 , number_of_orbitals do ij_orb = 1 , number_of_orbitals ! do ii_state = 1 , nStates do ij_state = 1 , nStates Amat ( ii_orb , ij_orb ) = Amat ( ii_orb , ij_orb ) + & dble ( zStatRho ( ii_state , ij_state ) * TDM ( ii_orb , ij_orb , ij_state , ii_state )) enddo enddo ! enddo enddo end subroutine ComputeOrbitalDensity subroutine ComputeAtomicWeights ( nPts , gridv , nAtoms , AtCoord , WeightV , Radius_BS ) integer , intent ( in ) :: nPts , nAtoms real ( kind ( 1 d0 )), intent ( in ) :: gridv (:, :), AtCoord (:, :), Radius_BS (:) real ( kind ( 1 d0 )), allocatable , intent ( out ) :: WeightV (:, :) integer , parameter :: k = 4 integer :: iPts , iAtom real ( kind ( 1 d0 )) :: rvec ( 3 ) write ( * , \"(a)\" ) \"Computing Weights\" allocate ( WEIGHTV ( nPts , nAtoms )) !$OMP PARALLEL DO PRIVATE(iPts, rvec, iAtom) do iPts = 1 , nPts rvec = gridv (:, iPts ) do iAtom = 1 , nAtoms WeightV ( iPts , iAtom ) = wkfun ( rvec , iAtom , AtCoord , nAtoms , k , Radius_BS ) enddo enddo !$OMP END PARALLEL DO end subroutine ComputeAtomicWeights subroutine TabulateChargeDensity ( Amat , OrbTab , ChDen ) real ( kind ( 1 d0 )), intent ( in ) :: Amat (:, :) real ( kind ( 1 d0 )), intent ( in ) :: OrbTab (:, :) real ( kind ( 1 d0 )), intent ( out ) :: ChDen (:) integer :: number_of_orbitals , ii_orb , ij_orb number_of_orbitals = size ( OrbTab , 2 ) !.. Tabulate Charge Density ChDen = 0.d0 !$OMP PARALLEL DO PRIVATE(iPts, ii_orb, ij_orb) do iPts = 1 , nPts do ii_orb = 1 , number_of_orbitals do ij_orb = 1 , number_of_orbitals ChDen ( iPts ) = ChDen ( iPts ) + OrbTab ( iPts , ii_orb ) * Amat ( ii_orb , ij_orb ) * OrbTab ( iPts , ij_orb ) enddo enddo enddo !$OMP END PARALLEL DO end subroutine TabulateChargeDensity subroutine ComputeBeckeMatrix ( WeightV , OrbTab , BeckeMatrix , Bary_center ) real ( kind ( 1 d0 )), intent ( in ) :: WeightV (:, :) real ( kind ( 1 d0 )), intent ( in ) :: OrbTab (:, :) real ( kind ( 1 d0 )), allocatable , intent ( out ) :: BeckeMatrix (:, :, :, :) real ( kind ( 1 d0 )), intent ( in ) :: Bary_center (:, :) integer :: nPts , number_of_orbitals , nAtoms integer :: iPts , iOrb1 , iOrb2 , iAtom , iPol real ( kind ( 1 d0 )) :: dsum ! write ( * , \"(a)\" ) \"Computing Becke's Matrix\" ! nAtoms = size ( WeightV , 2 ) nPts = size ( WeightV , 1 ) number_of_orbitals = size ( OrbTab , 2 ) allocate ( BeckeMatrix ( 3 , number_of_orbitals , number_of_orbitals , nAtoms )) BeckeMatrix = 0.d0 !$omp parallel do private(iOrb2, iOrb1, iPts) shared(BeckeMatrix, WeightV, OrbTab, Bary_center) do iPol = 1 , 3 do iAtom = 1 , nAtoms do iOrb2 = 1 , number_of_orbitals do iOrb1 = 1 , number_of_orbitals do iPts = 1 , nPts BeckeMatrix ( iPol , iOrb1 , iOrb2 , iAtom ) = BeckeMatrix ( iPol , iOrb1 , iOrb2 , iAtom ) + & WeightV ( iPts , iAtom ) * OrbTab ( iPts , iOrb1 ) * OrbTab ( iPts , iOrb2 ) * & Bary_center ( iPol , iAtom ) ! fixme???? end do end do end do end do end do !$omp end parallel do end subroutine ComputeBeckeMatrix ! <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ! Not used in the code ...? ! ---------------------------------------------------- complex ( kind ( 1 d0 )) function zTraceFunction ( zA ) result ( zTrace ) integer :: i complex ( kind ( 1 d0 )), intent ( in ) :: zA (:, :) zTrace = 0.d0 do i = 1 , size ( zA , 1 ) zTrace = zTrace + zA ( i , i ) enddo end function zTraceFunction ! <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< end program ChargeMigration","tags":"","loc":"sourcefile/main.f90.html"},{"title":"Module_Becke.f90 – Charge Migration","text":"Files dependent on this one sourcefile~~module_becke.f90~~AfferentGraph sourcefile~module_becke.f90 Module_Becke.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~module_becke.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code Module Module_Becke use , intrinsic :: ISO_FORTRAN_ENV implicit none private logical :: Verbous public :: & EuclDist , & EllipticalCoord , & Radius_Table , & get_param_a , & new_mu_transformation , & fkfun , & skfun , & skfunab , & Pkfuna , & PkFunTot , & wkfun contains ! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> !! This code is a Fortran implementation of the Becke partitioning scheme based on the following papers: !! !! H. Gharibnejad, N. Douguet, B.I. Schneider, J. Olsen, L. Argenti, !!  A multi-center quadrature scheme for the molecular continuum, !!  Computer Physics Communications, Volume 263, 2021, 107889, ISSN 0010-4655, !!  https://doi.org/10.1016/j.cpc.2021.107889. !! !! and !! !! A. D. Becke; A multicenter numerical integration scheme for polyatomic molecules. !!  J. Chem. Phys. 15 February 1988; 88 (4): 2547–2553. https://doi.org/10.1063/1.454033 !! !! ---------------------------------------------------- !!Result = P_a(\\vec{r})/\\sum_bP_b(\\vec{r})  !! ---------------------------------------------------- !! !! Quick Notes: !! !!Radius_Table: Given the name of an atom, returns its atomic radius. Only supports H, C, N, O, and Mg. !! !!get_param_a: Given two radii R_i and R_j, returns a transformed parameter a_ij. If the absolute value of a_{ij} is greater than 0.5, it's set to 0.5. !! !!new_mu_transformation: Returns a new mu parameter, given the original mu and a_{ij}. !! !!wkfun: Calculates a weighted function for atom i. !! !!PkFunTot: Sums up the function Pkfuna over all atoms. !! !!Pkfuna: Calculates a product of skfunab over all atoms excluding atom i. !! !!skfunab: Transforms an elliptical coordinate to a new mu, then returns the result of skfun with this new mu. !! !!skfun: Transforms a mu parameter into a step function. !! !!fkfun: Recursively calculates a function of mu. !! !!EllipticalCoord: Given coordinates rvec, avec, and bvec, calculates an elliptical coordinate. !! !!EuclDist: Given two points in space, calculates their Euclidean distance. !! !!The main considerations: !!This code does not handle the case where the input atomic name does not match one of the provided options in Radius_Table. This could lead to an error or unexpected behavior. !!The recursion in fkfun does not seem to have a base case when k is less than 1, which could potentially lead to a stack overflow error. !!There are no checks for zero or negative distances in EuclDist which might cause issues if not handled properly upstream. !!The input values are not validated for possible errors. Adding error handling and input validation could make the code more robust. !!The functions are tightly coupled, which might make modifications and debugging more difficult. !.. Euclidean distance real ( kind ( 1 d0 )) function EuclDist ( avec , bvec ) result ( res ) !! This function calculates the Euclidean distance between two points in 3D space. The inputs are two 3-component vectors representing the coordinates of the points, and the output is a scalar representing the distance between them. real ( kind ( 1 d0 )), intent ( in ) :: avec ( 3 ), bvec ( 3 ) real ( kind ( 1 d0 )) :: cvec ( 3 ) cvec = ( avec - bvec ) res = sqrt ( sum ( cvec * cvec )) end function EuclDist ! ---------------------------------------------------- !.. Elliptical coordinate real ( kind ( 1 d0 )) function EllipticalCoord ( rvec , avec , bvec ) result ( res ) !! Eq. 1  \\mu_{ab}(\\vec{r})  !! This function calculates the elliptical coordinate (\\mu_{ab}) of a point relative to two other points (defined as atoms 'a' and 'b'). This coordinate is a measure of how much closer the point is to atom 'a' compared to atom 'b'. real ( kind ( 1 d0 )), intent ( in ) :: rvec ( 3 ), avec ( 3 ), bvec ( 3 ) real ( kind ( 1 d0 )) :: r_a , r_b , R_ab ! $r_a$, $r_b$, $R_ab$ r_a = EuclDist ( rvec , avec ) r_b = EuclDist ( rvec , bvec ) R_ab = EuclDist ( avec , bvec ) res = ( r_a - r_b ) / R_ab end function EllipticalCoord ! ---------------------------------------------------- !..Radius_Table real ( kind ( 1 d0 )) function Radius_Table ( Atomic_Name ) result ( Atomic_Radius ) !!Radius_Table for atomic radius based on atomic name !!This function provides the atomic radius based on the atomic name. The input is a string representing the atomic name and the output is the corresponding atomic radius. This is useful for defining the size of atoms in molecular modelling. character ( len = 16 ), intent ( in ) :: Atomic_Name if ( Atomic_Name == \"H\" ) then Atomic_Radius = 0.35 elseif ( Atomic_Name == \"C\" ) then Atomic_Radius = 0.70 elseif ( Atomic_Name == \"N\" ) then Atomic_Radius = 0.65 elseif ( Atomic_Name == \"O\" ) then Atomic_Radius = 0.60 elseif ( Atomic_Name == \"Mg\" ) then Atomic_Radius = 1.50 end if end function Radius_Table ! ---------------------------------------------------- !..get_param_aij real ( kind ( 1 d0 )) function get_param_a ( R_i , R_j ) result ( a_ij ) !! This function calculates the parameter 'a' (a_{ij}) which depends on the radii of two atoms. This parameter is used in the transformation of the elliptical coordinate. real ( kind ( 1 d0 )), intent ( in ) :: R_i , R_j real ( kind ( 1 d0 )) :: Chi Chi = R_i / R_j a_ij = ( Chi - 1 ) / ( Chi + 1 ) if ( abs ( a_ij ) > ( 0.5d0 )) then a_ij = 0.5d0 endif end function get_param_a ! ---------------------------------------------------- !..new_mu_transformation real ( kind ( 1 d0 )) function new_mu_transformation ( mu , a_ij ) result ( res ) !! This function transforms the elliptical coordinate using the parameter 'a' (a_{ij}). This transformation is used to handle cases where the point is much closer to one atom than the other. real ( kind ( 1 d0 )), intent ( in ) :: mu , a_ij res = mu + a_ij * ( 1 - mu ** 2 ) end function new_mu_transformation ! ---------------------------------------------------- real ( kind ( 1 d0 )) recursive function fkfun ( mu , k ) result ( res ) !! Eq. 4 Recursive   f_k(\\mu)  !! This function calculates a recursive function of the transformed elliptical coordinate. The output of this function will be used in the calculation of the step function skfun. implicit none real ( kind ( 1 d0 )), intent ( in ) :: mu integer , intent ( in ) :: k res = 0.5d0 * mu * ( 3.d0 - mu ** 2 ) if ( k == 1 ) return res = fkfun ( res , k - 1 ) end function fkfun ! ---------------------------------------------------- real ( kind ( 1 d0 )) function skfun ( mu , k ) result ( res ) !!  s(\\mu): [-1,1]  \\rightarrow [0,1]   (Step Function) !! This function calculates a step function of the transformed elliptical coordinate. This function maps the transformed elliptical coordinate from the range [-1,1] to [0,1]. implicit none real ( kind ( 1 d0 )), intent ( in ) :: mu integer , intent ( in ) :: k real ( kind ( 1 d0 )) :: r_m res = 0.5d0 * ( 1.d0 - fkfun ( mu , k )) end function skfun ! ---------------------------------------------------- real ( kind ( 1 d0 )) function skfunab ( rvec , avec , bvec , k , a_ij ) result ( res ) !! This function combines the calculations of the transformed elliptical coordinate and the step function. The output of this function will be used in the calculation of the partial partition function Pkfuna. real ( kind ( 1 d0 )), intent ( in ) :: rvec ( 3 ), avec ( 3 ), bvec ( 3 ) integer , intent ( in ) :: k real ( kind ( 1 d0 )) :: mu_old , mu_new , a_ij mu_old = EllipticalCoord ( rvec , avec , bvec ) mu_new = new_mu_transformation ( mu_old , a_ij ) res = skfun ( mu_new , k ) end function skfunab ! ---------------------------------------------------- real ( kind ( 1 d0 )) function Pkfuna ( rvec , iAtom , AtCoord , nAtoms , k , Radius_BS ) result ( res ) !! Eq. 2   P_a(\\vec{r}) , nominator of Eq. 3 !! This function calculates the partial partition function for a specific atom. The output of this function represents the contribution of a specific atom to the total partition function. integer , intent ( in ) :: nAtoms , iAtom real ( kind ( 1 d0 )), intent ( in ) :: rvec ( 3 ), AtCoord ( 3 , nAtoms ), Radius_BS (:) integer , intent ( in ) :: k integer :: jAtom real ( kind ( 1 d0 )) :: a_ij , R_i , R_j res = 1.d0 !$OMP PARALLEL DO REDUCTION(*:res) PRIVATE(jAtom, R_i, R_j, a_ij) do jAtom = 1 , nAtoms if ( jAtom == iAtom ) cycle R_i = Radius_BS ( iAtom ) R_j = Radius_BS ( jAtom ) a_ij = get_param_a ( R_i , R_j ) res = res * skfunab ( rvec , AtCoord (:, iAtom ), AtCoord (:, jAtom ), k , a_ij ) end do !$OMP END PARALLEL DO end function Pkfuna ! ---------------------------------------------------- real ( kind ( 1 d0 )) function PkFunTot ( rvec , AtCoord , nAtoms , k , Radius_BS ) result ( res ) !! Eq. 3  \\sum_bP_b(\\vec{r})  in the denominator !! This function calculates the total partition function. This is done by summing the partial partition functions for all atoms. integer , intent ( in ) :: nAtoms real ( kind ( 1 d0 )), intent ( in ) :: rvec ( 3 ), AtCoord ( 3 , nAtoms ), Radius_BS (:) integer , intent ( in ) :: k integer :: iAtom res = 0.d0 !$OMP PARALLEL DO REDUCTION(+:res) PRIVATE(iAtom) do iAtom = 1 , nAtoms res = res + Pkfuna ( rvec , iAtom , AtCoord , nAtoms , k , Radius_BS ) end do !$OMP END PARALLEL DO end function PkFunTot ! ---------------------------------------------------- real ( kind ( 1 d0 )) function wkfun ( rvec , iAtom , AtCoord , nAtoms , k , Radius_BS ) result ( res ) !! Eq. 3 $w_a \\vec(r)$  (WEIGHTS) !! This function calculates the weight of an atom. The weight is defined as the ratio of the partial partition function of the atom to the total partition function. This weight represents the relative importance of the atom. integer , intent ( in ) :: iAtom , k , nAtoms real ( kind ( 1 d0 )), intent ( in ) :: rvec ( 3 ), AtCoord ( 3 , nAtoms ), Radius_BS (:) ! res = Pkfuna ( rvec , iAtom , AtCoord , nAtoms , k , Radius_BS ) / PkfunTot ( rvec , AtCoord , nAtoms , k , Radius_BS ) end function wkfun ! ---------------------------------------------------- ! <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< End Module Module_Becke","tags":"","loc":"sourcefile/module_becke.f90.html"},{"title":"Module_CD_IO.f90 – Charge Migration","text":"Files dependent on this one sourcefile~~module_cd_io.f90~~AfferentGraph sourcefile~module_cd_io.f90 Module_CD_IO.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~module_cd_io.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code Module Module_CM_CD_IO use , intrinsic :: ISO_FORTRAN_ENV use ModuleErrorHandling use ModuleString implicit none private logical :: Verbous public :: & Set_CD_IO_Verbous , & LoadGeometry , & LoadEnergies , & LoadGrid , & LoadOrbitals , & LoadDipoleME , & LoadTDMs , & LoadDipoleMO , & Write_R_el_bc , & Write_Dipole , & Write_Q_Charge , & Write_Charge_Density , & Write_Weights , & Read_Weights , & Write_Summary contains !>> Commons <<! subroutine Set_CD_IO_Verbous ( logi ) logical , intent ( in ) :: logi Verbous = logi end subroutine Set_CD_IO_Verbous subroutine replace_char ( strn , ch1 , ch2 ) character ( len = * ), intent ( inout ) :: strn character , intent ( in ) :: ch1 , ch2 integer :: i do i = index ( strn , ch1 ) if ( i <= 0 ) exit strn ( i : i ) = ch2 enddo end subroutine replace_char subroutine Write_Summary ( FileName , nPts , nAtoms , Computed_volume , n_times , t_min , t_max , atom_names , Radius_BS , number_of_orbitals , OrbTab ) integer , intent ( in ) :: nPts , nAtoms , n_times , number_of_orbitals real ( kind ( 1 d0 )), intent ( in ) :: Computed_volume , t_min , t_max , Radius_BS (:), OrbTab (:, :) character ( len = 16 ), intent ( in ) :: atom_names (:) character ( len = * ), intent ( in ) :: FileName real ( kind ( 1 d0 )) :: self_overlap , other_overlap integer :: uid , atom_idx , orbital_idx1 , orbital_idx2 , point_idx , ierr ! Call the new subroutine to write the summary to the screen and the file open ( newunit = uid , file = FileName , form = \"formatted\" , status = \"unknown\" , action = \"write\" , iostat = ierr ) if ( ierr /= 0 ) then call assert ( \"Write_Summary: Failed to open file for writing: \" // FileName , Assertion % LEVEL_SEVERE ) return end if write ( uid , \"(a)\" ) \"SUMMARY\" write ( uid , \"(a,i0)\" ) \"    Number of Points=\" , nPts write ( uid , \"(a,i0)\" ) \"    Number of Atoms=\" , nAtoms write ( uid , \"(a,e14.6,a,e14.6)\" ) \"    Computed volume =\" , Computed_volume write ( uid , \"(a,i0,e14.6,e14.6)\" ) \"    n_times, t_min, t_max=\" , n_times , t_min , t_max write ( uid , \"(a)\" ) \"    Bragg-Slater radii for Becke's Weights\" do atom_idx = 1 , nAtoms if ( atom_idx . ne . 1 ) then if ( atom_names ( atom_idx ) == atom_names ( atom_idx - 1 )) cycle end if write ( uid , \"(a,a,a,e14.4)\" ) \"        \" , atom_names ( atom_idx ), \"=\" , Radius_BS ( atom_idx ) !write Bragg-Slater radii end do write ( uid , * ) do orbital_idx1 = 1 , number_of_orbitals self_overlap = calculate_overlap ( OrbTab , nPts , orbital_idx1 , orbital_idx1 ) * Computed_volume other_overlap = 0.d0 do orbital_idx2 = 1 , number_of_orbitals if ( orbital_idx2 == orbital_idx1 ) cycle other_overlap = other_overlap + calculate_overlap ( OrbTab , nPts , orbital_idx1 , orbital_idx2 ) end do other_overlap = other_overlap * Computed_volume write ( uid , \"(a,i0,a,e14.6,a,e14.6)\" ) \"    Norm(\" , orbital_idx1 , \") =\" , self_overlap , \"    Overlap other =\" , other_overlap end do close ( uid ) ! Write to screen as well - calculte_overlap is only computed once, returning a value after 1st run write ( * , \"(a)\" ) \"SUMMARY\" write ( * , \"(a,i0)\" ) \"    Number of Points=\" , nPts write ( * , \"(a,i0)\" ) \"    Number of Atoms=\" , nAtoms write ( * , \"(a,e14.6,a,e14.6)\" ) \"    Computed volume =\" , Computed_volume write ( * , \"(a,i0,e14.6,e14.6)\" ) \"    n_times, t_min, t_max=\" , n_times , t_min , t_max write ( * , \"(a)\" ) \"    Bragg-Slater radii for Becke's Weights\" do atom_idx = 1 , nAtoms if ( atom_idx . ne . 1 ) then if ( atom_names ( atom_idx ) == atom_names ( atom_idx - 1 )) cycle end if write ( * , \"(a,a,a,e14.4)\" ) \"        \" , atom_names ( atom_idx ), \"=\" , Radius_BS ( atom_idx ) !write Bragg-Slater radii end do write ( * , * ) do orbital_idx1 = 1 , number_of_orbitals self_overlap = calculate_overlap ( OrbTab , nPts , orbital_idx1 , orbital_idx1 ) * Computed_volume other_overlap = 0.d0 do orbital_idx2 = 1 , number_of_orbitals if ( orbital_idx2 == orbital_idx1 ) cycle other_overlap = other_overlap + calculate_overlap ( OrbTab , nPts , orbital_idx1 , orbital_idx2 ) end do other_overlap = other_overlap * Computed_volume write ( * , \"(a,i0,a,e14.6,a,e14.6)\" ) \"    Norm(\" , orbital_idx1 , \") =\" , self_overlap , \"    Overlap other =\" , other_overlap end do contains real function calculate_overlap ( OrbTab , nPts , orbital_idx1 , orbital_idx2 ) real ( kind ( 1 d0 )), intent ( in ) :: OrbTab (:, :) ! 3 x npts integer , intent ( in ) :: nPts , orbital_idx1 , orbital_idx2 integer :: point_idx calculate_overlap = 0.d0 do point_idx = 1 , nPts calculate_overlap = calculate_overlap + OrbTab ( point_idx , orbital_idx1 ) * OrbTab ( point_idx , orbital_idx2 ) end do end function calculate_overlap end subroutine Write_Summary !>> Load Subroutines <<! !> Load the position of the atomic nuclei subroutine LoadGeometry ( nAtoms , AtCoord , FileName , atom_names ) ! integer , intent ( out ) :: nAtoms real ( kind ( 1 d0 )), allocatable , intent ( out ) :: AtCoord (:, :) character ( len = * ), intent ( in ) :: FileName ! integer :: iAtom , iCoord , uid character ( len = 16 ), allocatable , intent ( out ) :: atom_names (:) ! write ( * , \"(a)\" ) \"Loading Geometry\" !.. Open file with geometry open ( newunit = uid , file = trim ( FileName ), form = \"formatted\" , status = \"old\" ) !*** Skip to the line specifying the number of atoms ! determine the number of atoms read ( uid , * ) nAtoms ! Skip to the line where the coordinates start to be listed !allocate the matrix of coordinates read ( uid , * ) allocate ( AtCoord ( 3 , nAtoms )) allocate ( atom_names ( nAtoms )) do iAtom = 1 , nAtoms read ( uid , * ) atom_names ( iAtom ), ( AtCoord ( iCoord , iAtom ), iCoord = 1 , 3 ) enddo close ( uid ) write ( * , * ) \"nAtoms\" , nAtoms end subroutine LoadGeometry ! !> Loads the Energies found inside the input_directory subroutine LoadEnergies ( FileName , nStates , Evec ) ! use ModuleErrorHandling use ModuleString ! implicit none ! character ( len = * ), intent ( in ) :: FileName integer , intent ( out ) :: nStates real ( kind ( 1 d0 )), allocatable , intent ( out ) :: Evec (:) integer :: uid , iostat character ( len = 1000 ) :: iomsg real ( kind ( 1 d0 )) :: E integer :: i write ( * , \"(a)\" ) \"Loading Energies\" open (& newunit = uid , & file = FileName , & form = \"formatted\" , & status = \"old\" , & action = \"read\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call errormessage ( trim ( iomsg )) stop endif nStates = 0 do read ( uid , * , iostat = iostat ) E if ( iostat /= 0 ) exit nStates = nStates + 1 enddo rewind ( uid ) allocate ( Evec ( nStates )) write ( * , \"(a)\" ) \" State Energies \" do i = 1 , nStates read ( uid , * ) Evec ( i ) write ( * , * ) i , Evec ( i ) enddo write ( * , * ) close ( uid ) ! end subroutine LoadEnergies ! !> Loads the Grid found inside the input_directory subroutine LoadGrid ( FileName , npts , gridv ) ! use ModuleErrorHandling use ModuleString ! implicit none ! character ( len = * ), intent ( in ) :: FileName integer , intent ( out ) :: npts real ( kind ( 1 d0 )), allocatable , intent ( out ) :: gridv (:, :) integer :: uid , iostat character ( len = 1000 ) :: iomsg real ( kind ( 1 d0 )) :: x , y , z character ( len = 100 ) :: line integer :: i , j write ( * , \"(a)\" ) \"Loading Grid\" open (& newunit = uid , & file = FileName , & form = \"formatted\" , & status = \"old\" , & action = \"read\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call errormessage ( trim ( iomsg )) stop endif ! Skip the header line read ( uid , '(A)' ) line npts = 0 do read ( uid , '(A)' , iostat = iostat ) line if ( iostat /= 0 ) exit read ( line , * , iostat = iostat ) x , y , z if ( iostat /= 0 ) exit npts = npts + 1 enddo rewind ( uid ) ! Skip the header line again read ( uid , '(A)' ) line allocate ( gridv ( 3 , npts )) do i = 1 , npts read ( uid , '(A)' , iostat = iostat ) line read ( line , * ) x , y , z gridv (:, i ) = [ x , y , z ] enddo close ( uid ) end subroutine LoadGrid ! !> Loads the Orbitals found inside the input_directory !> Loads the Orbitals from the grid_density.csv file inside the input_directory subroutine LoadOrbitals ( Dir , number_of_orbitals , npts , OrbTab ) ! use ModuleErrorHandling use ModuleString ! implicit none ! character ( len = * ), intent ( in ) :: Dir integer , intent ( in ) :: number_of_orbitals , npts real ( kind ( 1 d0 )), allocatable , intent ( out ) :: OrbTab (:, :) integer :: uid , iostat , i , iOrb character ( len = 1000 ) :: iomsg character ( len = 1000 ) :: headerLine , dataLine ! write ( * , \"(a)\" ) \"Loading Orbitals\" ! allocate ( OrbTab ( npts , number_of_orbitals )) ! Make sure that OrbTab is filled open (& newunit = uid , & file = Dir // \"/grid_density.csv\" , & form = \"formatted\" , & status = \"old\" , & action = \"read\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call Assert ( trim ( iomsg ), Assertion % LEVEL_SEVERE ) call StopExecution () endif ! Skip the header line read ( uid , '(a)' ) headerLine do i = 1 , npts read ( uid , '(a)' ) dataLine read ( dataLine , * , iostat = iostat ) ( OrbTab ( i , iOrb ), iOrb = 1 , number_of_orbitals ) if ( iostat /= 0 ) then call errormessage ( \"Error reading row \" // ConvertToStrn ( i ) // \" from grid_density.csv.\" ) stop endif enddo close ( uid ) ! Make sure that OrbTab is filled do iOrb = 1 , number_of_orbitals do i = 1 , npts if ( OrbTab ( i , iOrb ) == 0 ) then call errormessage ( \"Error in row \" // ConvertToStrn ( i ) // \" of OrbTab. Not filled properly.\" ) stop endif enddo end do ! end subroutine LoadOrbitals ! !> Loads all the Dipoles found inside the input_directory subroutine LoadDipoleME ( Dmat , input_directory , nStates ) use ModuleErrorHandling implicit none real ( kind ( 1 d0 )), allocatable , intent ( out ) :: Dmat (:, :, :) character ( len = * ), intent ( in ) :: input_directory integer , intent ( in ) :: nStates real ( kind ( 1 d0 )), allocatable :: dBufM (:, :) integer :: i write ( * , \"(a)\" ) \"Loading Dipole Matrices for XYZ components\" if ( nStates <= 0 ) then call ErrorMessage ( \"Invalid nStates in LoadDipoleME\" ) stop endif if ( allocated ( Dmat )) deallocate ( Dmat ) allocate ( Dmat ( nStates , nStates , 3 ), dBufM ( nStates , nStates )) call LoadDipoles ( input_directory // \"/X_DIPOLE.csv\" , nStates , dBufM ) Dmat (:, :, 1 ) = dBufM call LoadDipoles ( input_directory // \"/Y_DIPOLE.csv\" , nStates , dBufM ) Dmat (:, :, 2 ) = dBufM call LoadDipoles ( input_directory // \"/Z_DIPOLE.csv\" , nStates , dBufM ) Dmat (:, :, 3 ) = dBufM end subroutine LoadDipoleME ! !> Loads the Dipoles found inside the input_directory subroutine LoadDipoles ( FileName , nStates , Dmat ) use ModuleErrorHandling use ModuleString implicit none character ( len = * ), intent ( in ) :: FileName integer , intent ( in ) :: nStates real ( kind ( 1 d0 )), intent ( inout ) :: Dmat (:, :) integer :: uid , iostat character ( len = 1000 ) :: iomsg integer :: i , j character ( len = 10 ) :: StateStr character ( len = 20 ) :: iStr open (& newunit = uid , & file = FileName , & form = \"formatted\" , & status = \"old\" , & action = \"read\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call ErrorMessage ( trim ( iomsg )) stop endif write ( * , * ) write ( * , \"(a)\" ) trim ( FileName ) ! Read and ignore header read ( uid , * , iostat = iostat , iomsg = iomsg ) StateStr if ( iostat /= 0 ) then call ErrorMessage ( \"Error reading header: \" // trim ( iomsg )) close ( uid ) return endif do i = 1 , nStates read ( uid , * , iostat = iostat , iomsg = iomsg ) StateStr , ( Dmat ( i , j ), j = 1 , nStates ) if ( iostat /= 0 ) then write ( iStr , '(I20)' ) i call ErrorMessage ( \"Error reading row \" // trim ( iStr ) // \": \" // trim ( iomsg )) close ( uid ) return endif write ( * , \"(*(x,e14.6))\" ) ( Dmat ( i , j ), j = 1 , nStates ) enddo close ( uid ) end subroutine LoadDipoles ! !> Loads the TDM found inside the input_directory !--------------------------------------------------------------------- ! LoadTDMs Subroutine !--------------------------------------------------------------------- ! ! Description: ! This subroutine reads in two files, one containing the density matrix (DM) ! and the other containing off-diagonal elements of the transition density matrix (TDM). ! The DM values are used for the diagonal blocks of the TDM, representing transitions ! from a state to itself. ! ! Linear Algebra Context: ! The density matrix, rho, for a quantum state |psi> is defined as: ! rho = |psi><psi| ! The diagonal elements of rho provide the probability of the system being in ! each of the basis states. ! ! The transition density matrix, D, for an initial state |psi_i> and a final state |psi_f> is: ! D = |psi_f><psi_i| ! When the initial and final states are the same (i.e., |psi_i> = |psi_f>), ! the TDM reduces to the DM. ! ! In this subroutine: ! - Diagonal blocks of TDM (from the file FileNameDM) correspond to the DM !   (i.e., transitions from a state to itself). ! - Off-diagonal blocks of TDM (from the file FileNameTDM) represent transitions !   between different states. ! ! Inputs: ! FileNameDM     - File containing the density matrix (DM) values. ! FileNameTDM    - File containing the off-diagonal elements of the TDM. ! nStates        - Number of quantum states. ! ! Outputs: ! number_of_orbitals - Total number of active orbitals read from the DM file. ! TDM               - 4D array containing the transition density matrix. ! ! Usage: ! call LoadTDMs(FileNameDM, FileNameTDM, nStates, number_of_orbitals, TDM) ! !--------------------------------------------------------------------- subroutine LoadTDMs ( FileNameDM , FileNameTDM , nStates , number_of_orbitals , TDM ) ! The density matrix (DM) is used as the diagonal blocks of the transition density matrix (TDM). This actually !   makes sense when you think about it. The diagonal blocks of the TDM refer to transitions from a state to !   itself. For electronic systems, the transition density matrix's diagonal blocks can be equivalent to the !   ground state density matrix, especially when considering transitions between ground states or reference !   states to excited states. ! During External Perturbations: If the system is under the influence of an external field or perturbation, !   the diagonal elements of the TDM might contain additional terms or corrections that differ from the DM??? ! use ModuleErrorHandling use ModuleString ! implicit none ! character ( len = * ), intent ( in ) :: FileNameDM character ( len = * ), intent ( in ) :: FileNameTDM integer , intent ( in ) :: nStates integer , intent ( out ) :: number_of_orbitals real ( kind ( 1 d0 )), allocatable , intent ( out ) :: TDM (:, :, :, :) integer :: uid , iostat character ( len = 1000 ) :: iomsg character ( len = 10000 ) :: line integer :: i_state , ii_state , ij_state , ii_orb , ij_orb , nlines write ( * , \"(a)\" ) \"Loading Transition Density Matrix\" ! !.. Open the file with the Diagonal part of TDM, i.e., the \"DM\" open (& newunit = uid , & file = FileNameDM , & form = \"formatted\" , & status = \"old\" , & action = \"read\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call errormessage ( trim ( iomsg )) stop endif !.. Determines the number of orbitals nlines = 0 do read ( uid , \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) exit line = adjustl ( trim ( line )) ! This removes leading and trailing spaces if ( len_trim ( line ) == 0 ) cycle nlines = nlines + 1 enddo if ( mod ( nlines , nStates ) /= 0 ) then call ErrorMessage ( \"Inconsistent number of lines in \" // FileNameDM ) endif number_of_orbitals = nlines / nStates write ( * , \"(a, i0)\" ) \"Number of Active Orbitals: \" , number_of_orbitals !.. Allocate the whole TDM array allocate ( TDM ( number_of_orbitals , number_of_orbitals , nStates , nStates )) TDM = 0.d0 !.. Reads the diagonal blocks of TDM rewind ( uid ) i_state = 0 ii_orb = 0 do read ( uid , \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) exit if ( len_trim ( line ) == 0 ) cycle if ( ii_orb == 0 ) then i_state = i_state + 1 ii_orb = 1 else ii_orb = ii_orb + 1 endif call replace_char ( line , \",\" , \" \" ) read ( line , * ) ( TDM ( ii_orb , ij_orb , i_state , i_state ), ij_orb = 1 , number_of_orbitals ) if ( ii_orb == number_of_orbitals ) ii_orb = 0 enddo close ( uid ) ! !.. Open the file with the Off-Diagonal part of TDM, i.e., the \"TDM\" open (& newunit = uid , & file = FileNameTDM , & form = \"formatted\" , & status = \"old\" , & action = \"read\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call errormessage ( trim ( iomsg )) stop endif !.. Reads the diagonal blocks of TDM do ij_state = 2 , nStates do ii_state = 1 , ij_state - 1 do ii_orb = 1 , number_of_orbitals read ( uid , \"(a)\" ) line call replace_char ( line , \",\" , \" \" ) read ( line , * ) ( TDM ( ii_orb , ij_orb , ii_state , ij_state ), ij_orb = 1 , number_of_orbitals ) enddo TDM (:, :, ij_state , ii_state ) = transpose ( TDM (:, :, ii_state , ij_state )) enddo enddo close ( uid ) ! if ( Verbous ) then write ( * , * ) \"number_of_orbitals = \" , number_of_orbitals do ii_state = 1 , nStates do ij_state = 1 , nStates write ( * , * ) \"STATES \" , ii_state , \" \" , ij_state do ii_orb = 1 , number_of_orbitals write ( * , \"(*(x,e14.6))\" ) ( TDM ( ii_orb , ij_orb , ii_state , ij_state ), ij_orb = 1 , number_of_orbitals ) enddo if ( i_state < nStates ) write ( * , * ) enddo enddo endif end subroutine LoadTDMs ! !> Loads Dipole Matrix Elements between molecular orbitals subroutine LoadDipoleMO ( input_directory , number_of_orbitals , ivOrb , MuOrb ) !! IDEALLY, SHOULD COMPUTE THE DIPOLE FROM THE AO - AO DIPOLES. ! use ModuleErrorHandling use ModuleString ! implicit none ! character ( len = * ), intent ( in ) :: input_directory integer , intent ( in ) :: number_of_orbitals integer , intent ( in ) :: ivOrb (:) real ( kind ( 1 d0 )), allocatable , intent ( out ) :: MuOrb (:, :) character ( len = * ), parameter :: FILE_AO_DIPOLE_X = \"AO_MLTPL_X\" character ( len = * ), parameter :: FILE_MO_VECTORS = \"MO_VECTORS\" integer :: uid , iostat character ( len = 1000 ) :: iomsg character ( len = 10000 ) :: line integer :: iAOi , iAOj , iAO , nAO integer :: iMO integer :: ii_orb , ij_orb real ( kind ( 1 d0 )), allocatable :: MuAO (:, :), dBufv (:) real ( kind ( 1 d0 )), allocatable :: MoVec (:, :) !.. Read file dipole between AOs open (& newunit = uid , & file = input_directory // \"/\" // FILE_AO_DIPOLE_X , & form = \"formatted\" , & status = \"old\" , & action = \"read\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call errormessage ( trim ( iomsg )) stop endif !.. Determines the number of AOs nAO = 0 do read ( uid , \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) exit nAO = nAO + 1 enddo write ( * , * ) \"nAO : \" , nAO !.. Reads the Dipole between AOs allocate ( MuAO ( nAO , nAO )) MuAO = 0.d0 rewind ( uid ) do iAOi = 1 , nAO read ( uid , \"(a)\" , iostat = iostat ) line call replace_char ( line , \",\" , \" \" ) read ( line , * ) ( MuAO ( iAOi , iAOj ), iAOj = 1 , nAO ) enddo close ( uid ) !.. Read file MO coefficients open (& newunit = uid , & file = input_directory // \"/\" // FILE_MO_VECTORS , & form = \"formatted\" , & status = \"old\" , & action = \"read\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call errormessage ( trim ( iomsg )) stop endif read ( uid , * ) allocate ( MOVec ( nAO , nAO )) MOVec = 0.d0 do iMO = 1 , nAO do iAO = 1 , nAO read ( uid , * ) MOVec ( iAO , iMO ) enddo enddo close ( uid ) write ( * , * ) \"MOVec check:\" , sum ( abs ( MOVec )) write ( * , \"(a,*(x,i4))\" ) \"ivOrb:\" , ivOrb allocate ( dBufv ( nAO )) allocate ( MuOrb ( number_of_orbitals , number_of_orbitals )) dBufv = 0.d0 MuOrb = 0.d0 do ij_orb = 1 , number_of_orbitals dBufv = matmul ( MuAO , MOVec (:, ivOrb ( ij_orb ))) do ii_orb = 1 , number_of_orbitals MuOrb ( ii_orb , ij_orb ) = dot_product ( MOVec (:, ivOrb ( ii_orb )), dBufv ) enddo enddo deallocate ( MOVec , dBufv , MuAO ) write ( * , * ) write ( * , * ) \"MO DIPOLE X\" do ii_orb = 1 , number_of_orbitals write ( * , \"(*(x,e14.6))\" ) ( MuOrb ( ii_orb , ij_orb ), ij_orb = 1 , number_of_orbitals ) enddo end subroutine LoadDipoleMO !>> Save Subroutines subroutine Write_R_el_bc ( output_directory , atom_names , nAtoms , R_el ) ! Inputs: character ( len = * ), intent ( in ) :: output_directory ! Directory path to save the file character ( len = 16 ), allocatable , intent ( in ) :: atom_names (:) integer , intent ( in ) :: nAtoms ! Number of atoms real ( kind ( 1 d0 )), allocatable , intent ( in ) :: R_el (:, :) ! Local variables: integer :: uid ! File unit identifier integer :: iAtom , iPol ! Loop counters ! Attempt to open the file for writing open ( newunit = uid , file = output_directory // \"/\" // \"R_el_bc.csv\" , form = \"formatted\" , status = \"unknown\" , action = \"write\" ) ! Write headers with fixed-width format write ( uid , \"(a)\" ) '\"Atom_Index\",\"Atom_Name\",\"X_Position\",\"Y_Position\",\"Z_Position\"' ! Loop over atoms and write their positions to the file do iAtom = 1 , nAtoms write ( uid , \"(i5,',',A20,2(',',f20.14),',',f20.14)\" ) iAtom , trim ( atom_names ( iAtom )), ( R_el ( iPol , iAtom ), iPol = 1 , 3 ) end do ! Close the file after writing close ( uid ) end subroutine Write_R_el_bc subroutine Write_Dipole ( FileName , Dipole , n_times , t_min , dt ) character ( len = * ), intent ( in ) :: FileName complex ( kind ( 1 d0 )), intent ( in ) :: Dipole (:, :) real ( kind ( 1 d0 )), intent ( in ) :: t_min , dt integer , intent ( in ) :: n_times real ( kind ( 1 d0 )) :: t integer :: uid_dipole , iPol , it open ( newunit = uid_dipole , & file = FileName , & form = \"formatted\" , & status = \"unknown\" , & action = \"write\" ) ! Write Headers write ( uid_dipole , '(a)' ) '\"itime\",\"Time\",\"DipoleX_Re\",\"DipoleX_Im\",\"DipoleY_Re\",\"DipoleY_Im\",\"DipoleZ_Re\",\"DipoleZ_Im\"' ! Write Data do it = 1 , n_times t = t_min + dt * dble ( it - 1 ) write ( uid_dipole , \"(i4,6(',',E24.16),',',E24.16)\" ) & it , t , & dble ( Dipole ( 1 , it )), aimag ( Dipole ( 1 , it )), & dble ( Dipole ( 2 , it )), aimag ( Dipole ( 2 , it )), & dble ( Dipole ( 3 , it )), aimag ( Dipole ( 3 , it )) enddo close ( uid_dipole ) end subroutine Write_Dipole subroutine Write_Q_Charge ( FileName , Charge , n_times , t_min , dt , nAtoms , atom_names ) character ( len = * ), intent ( in ) :: FileName real ( kind ( 1 d0 )), intent ( in ) :: Charge (:, :, :) real ( kind ( 1 d0 )), intent ( in ) :: t_min , dt integer , intent ( in ) :: n_times , nAtoms character ( len = 16 ), intent ( in ) :: atom_names (:) CHARACTER ( LEN = 1000 ) :: formatString real ( kind ( 1 d0 )) :: t integer :: uid_AtomicCharge , iPol , it , iAtom open ( newunit = uid_AtomicCharge , & file = FileName , & form = \"formatted\" , & status = \"unknown\" , & action = \"write\" ) ! Start of the header write ( uid_AtomicCharge , '(a)' , advance = \"no\" ) '\"itime\",\"Time\",\"TotalCharge\",' ! Headers for the individual atomic charges do iAtom = 1 , nAtoms - 1 write ( uid_AtomicCharge , \"(a)\" , advance = \"no\" ) \"\" & // '\"Atom_' // trim ( atom_names ( iAtom )) // '_ChargeX\",' & // '\"Atom_' // trim ( atom_names ( iAtom )) // '_ChargeY\",' & // '\"Atom_' // trim ( atom_names ( iAtom )) // '_ChargeZ\",' end do ! Last atomic charge header write ( uid_AtomicCharge , '(a)' ) '' & // '\"Atom_' // trim ( atom_names ( nAtoms )) // '_ChargeX\",' & // '\"Atom_' // trim ( atom_names ( nAtoms )) // '_ChargeY\",' & // '\"Atom_' // trim ( atom_names ( nAtoms )) // '_ChargeZ\"' ! Write Data do it = 1 , n_times t = t_min + dt * dble ( it - 1 ) ! Write initial data: iteration number, time, and the sum of charges at that time step. write ( uid_AtomicCharge , \"(i4,2(',',E24.16))\" , advance = 'no' ) it , t , sum ( Charge (:, :, it )) ! For the first atom in each time step, skip the comma. write ( uid_AtomicCharge , \"(',', E24.16, ',', E24.16, ',', E24.16)\" , advance = \"no\" ) & Charge ( 1 , 1 , it ), Charge ( 2 , 1 , it ), Charge ( 3 , 1 , it ) ! For all other atoms except the iAtom=nAtoms, prefix the charges with a comma do iAtom = 2 , nAtoms - 1 ! For all other atoms, prefix the charges with a comma and do not advance to the next line write ( uid_AtomicCharge , \"(',', E24.16, ',', E24.16, ',', E24.16)\" , advance = \"no\" ) & Charge ( 1 , iAtom , it ), Charge ( 2 , iAtom , it ), Charge ( 3 , iAtom , it ) end do ! For the last atom, suffix the charges with a newline write ( uid_AtomicCharge , \"(',', E24.16, ',', E24.16, ',', E24.16)\" ) & Charge ( 1 , nAtoms , it ), Charge ( 2 , nAtoms , it ), Charge ( 3 , nAtoms , it ) enddo close ( uid_AtomicCharge ) end subroutine Write_Q_Charge subroutine Write_Charge_Density ( FileName , npts , gridv , ChDen , Weightv , nAtoms , atom_names ) use ModuleErrorHandling use ModuleString implicit none character ( len = * ), intent ( in ) :: FileName integer , intent ( in ) :: nPts , nAtoms real ( kind ( 1 d0 )), allocatable , intent ( in ) :: gridv (:, :) real ( kind ( 1 d0 )), allocatable , intent ( in ) :: ChDen (:) real ( kind ( 1 d0 )), allocatable , intent ( in ) :: Weightv (:, :) character ( len = 16 ), intent ( in ) :: atom_names (:) integer :: uid , iostat character ( len = 1000 ) :: iomsg integer :: iPts , iAtom , j open (& newunit = uid , & file = FileName , & form = \"formatted\" , & status = \"unknown\" , & action = \"write\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call errormessage ( trim ( iomsg )) stop endif ! Start of the header write ( uid , \"(a)\" , advance = \"no\" ) '\"x\",\"y\",\"z\",\"ChargeDensity\",' ! Headers for the individual atomic charges do iAtom = 1 , nAtoms - 1 write ( uid , \"(a)\" , advance = \"no\" ) '\"Atom_' // trim ( atom_names ( iAtom )) // '_ChargeDensity\",' end do ! Header for the last atom write ( uid , '(a)' ) '\"Atom_' // trim ( atom_names ( nAtoms )) // '_ChargeDensity\"' ! Write the data do iPts = 1 , nPts ! Writing the first set of values without a comma at the beginning write ( uid , \"(E24.14E3, ',', E24.14E3, ',', E24.14E3, ',', E24.14E3)\" , advance = \"no\" ) ( gridv ( j , iPts ), j = 1 , 3 ), ChDen ( iPts ) ! Writing the next sets of values with a comma at the beginning do iAtom = 1 , nAtoms - 1 write ( uid , \"(',', E24.14E3)\" , advance = \"no\" ) ChDen ( iPts ) * Weightv ( iPts , iAtom ) end do ! For the last value, write without appending another comma write ( uid , \"(',', E24.14E3)\" ) ChDen ( iPts ) * Weightv ( iPts , nAtoms ) enddo close ( uid ) end subroutine Write_Charge_Density !> Write Weights Subroutine subroutine Write_Weights ( FileName , WEIGHTV , gridv , nAtoms , nPts , atom_names ) character ( len = * ), intent ( in ) :: FileName real ( kind ( 1 d0 )), intent ( in ) :: gridv (:, :) integer , intent ( in ) :: nPts , nAtoms real ( kind ( 1 d0 )), intent ( in ) :: WEIGHTV (:, :) character ( len = 16 ), intent ( in ) :: atom_names (:) integer :: uid , iPts , iAtom , i ! write ( * , \"(a)\" ) \"Writing Weights to File\" !..Write Weights to File open ( newunit = uid , file = FileName , form = \"formatted\" , status = \"unknown\" , action = \"write\" ) ! Start of the header write ( uid , \"(a)\" , advance = \"no\" ) '\"x\",\"y\",\"z\",' ! Headers for the individual atomic charges do iAtom = 1 , nAtoms - 1 write ( uid , \"(a)\" , advance = \"no\" ) '\"Atom_' // trim ( atom_names ( iAtom )) // '_ChargeDensity\",' end do ! Header for the last atom write ( uid , '(a)' ) '\"Atom_' // trim ( atom_names ( nAtoms )) // '_ChargeDensity\"' ! Write the data do iPts = 1 , nPts ! Writing the first set of values without a comma at the beginning write ( uid , \"(E24.14E3, ',', E24.14E3, ',', E24.14E3)\" , advance = \"no\" ) ( gridv ( i , iPts ), i = 1 , 3 ) ! Writing the next sets of values with a comma at the beginning do iAtom = 1 , nAtoms - 1 write ( uid , \"(',', E24.14E3)\" , advance = \"no\" ) WEIGHTV ( iPts , iAtom ) end do ! For the last value, write without appending another comma write ( uid , \"(',', E24.14E3)\" ) WEIGHTV ( iPts , nAtoms ) end do close ( uid ) end subroutine Write_Weights !> Read Weights Subroutine subroutine Read_Weights ( FileName , WEIGHTV , nAtoms , nPts ) character ( len = * ), intent ( in ) :: FileName integer , intent ( in ) :: nPts , nAtoms real ( kind ( 1 d0 )), allocatable , intent ( out ) :: WEIGHTV (:, :) real ( kind ( 1 d0 )) :: dBuf ( 3 ) integer :: uid , iPts , iAtom , i character ( len = 100 ) :: headerLine allocate ( WEIGHTV ( nPts , nAtoms )) ! write ( * , \"(a)\" ) \"Reading Weights from File\" ! !..Read Weights from File open ( newunit = uid , file = FileName , form = \"formatted\" , status = \"old\" , action = \"read\" ) ! Skip the header read ( uid , \"(a)\" ) headerLine ! Read the data do iPts = 1 , nPts read ( uid , \"(E24.14E3, ',', E24.14E3, ',', E24.14E3)\" , advance = \"no\" ) ( dBuf ( i ), i = 1 , 3 ) do iAtom = 1 , nAtoms - 1 read ( uid , \"(',', E24.14E3)\" , advance = \"no\" ) WEIGHTV ( iPts , iAtom ) end do read ( uid , \"(',', E24.14E3)\" ) WEIGHTV ( iPts , nAtoms ) end do ! Close the file close ( uid ) end subroutine Read_Weights end Module Module_CM_CD_IO","tags":"","loc":"sourcefile/module_cd_io.f90.html"},{"title":"Module_CD_IO.f90 – Charge Migration","text":"Source Code Module Module_SR_CD_IO use , intrinsic :: ISO_FORTRAN_ENV use ModulePulses_3D use ModuleConstants implicit none private logical :: Verbous public :: & Set_CD_IO_Verbous , & LoadGeometry , & LoadBidimentioal_Dipole_Spectrum , & Write_2DReconstructDipole , & Load_BidimentionalChargeFTww contains subroutine Set_CD_IO_Verbous ( logi ) logical , intent ( in ) :: logi Verbous = logi end subroutine Set_CD_IO_Verbous subroutine LoadGeometry ( nAtoms , AtCoord , FileName , atom_names ) ! integer , intent ( out ) :: nAtoms real ( kind ( 1 d0 )), allocatable , intent ( out ) :: AtCoord (:, :) character ( len = * ), intent ( in ) :: FileName ! integer :: iAtom , iCoord , uid character ( len = 16 ), allocatable , intent ( out ) :: atom_names (:) ! write ( * , \"(a)\" ) \"Loading Geometry\" !.. Open file with geometry open ( newunit = uid , file = trim ( FileName ), form = \"formatted\" , status = \"old\" ) !*** Skip to the line specifying the number of atoms ! determine the number of atoms read ( uid , * ) nAtoms !*** Skip to the line where the coordinates start to be listed !allocate the matrix of coordinates read ( uid , * ) allocate ( AtCoord ( 3 , nAtoms )) allocate ( atom_names ( nAtoms )) do iAtom = 1 , nAtoms read ( uid , * ) atom_names ( iAtom ), ( AtCoord ( iCoord , iAtom ), iCoord = 1 , 3 ) enddo close ( uid ) write ( * , * ) \"nAtoms\" , nAtoms end subroutine LoadGeometry subroutine replace_char ( strn , ch1 , ch2 ) character ( len = * ), intent ( inout ) :: strn character , intent ( in ) :: ch1 , ch2 integer :: i do i = index ( strn , ch1 ) if ( i <= 0 ) exit strn ( i : i ) = ch2 enddo end subroutine replace_char subroutine LoadBidimentioal_Dipole_Spectrum ( FileName , DipoleFTww , TauOmegaVec , OmegaVec , nTauOmegas , nOmegas ) character ( len = * ), intent ( in ) :: FileName complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: DipoleFTww (:, :, :) real ( kind ( 1 d0 )), intent ( in ) :: TauOmegaVec (:), OmegaVec (:) integer , intent ( in ) :: nTauOmegas , nOmegas real ( kind ( 1 d0 )) :: dBuf integer :: iOmegaTau , iOmega , iPol , uid_dipoleFT character ( 200 ) :: line ! buffer to read the header allocate ( DipoleFTww ( 3 , nOmegas , nTauOmegas )) open ( newunit = uid_dipoleFT , & file = FileName , & form = \"formatted\" , & status = \"old\" , & action = \"read\" ) read ( uid_dipoleFT , '(a)' ) line do iOmegaTau = 1 , nTauOmegas do iOmega = 1 , nOmegas read ( uid_dipoleFT , \"(*(x,e24.16))\" ) dBuf , dBuf , & ((( DipoleFTww ( iPol , iOmega , iOmegaTau ))), iPol = 1 , 3 ) !                        dble(DipoleFTww(1, iOmega, iOmegaTau)), aimag(DipoleFTww(1, iOmega, iOmegaTau)), & !                        dble(DipoleFTww(2, iOmega, iOmegaTau)), aimag(DipoleFTww(2, iOmega, iOmegaTau)), & !                        dble(DipoleFTww(3, iOmega, iOmegaTau)), aimag(DipoleFTww(3, iOmega, iOmegaTau)) end do enddo close ( uid_dipoleFT ) end subroutine LoadBidimentioal_Dipole_Spectrum subroutine Write_2DReconstructDipole ( FileName , Dipole , TauOmegaVec , OmegaVec , nTauOmegas , nOmegas ) character ( len = * ), intent ( in ) :: FileName complex ( kind ( 1 d0 )), intent ( in ) :: Dipole (:, :, :) real ( kind ( 1 d0 )), intent ( in ) :: TauOmegaVec (:), OmegaVec (:) integer , intent ( in ) :: nTauOmegas , nOmegas integer :: uid_AtomicChargeFT , iOmegaTau , iOmega , iAtom , iCoord open ( newunit = uid_AtomicChargeFT , & file = FileName , & form = \"formatted\" , & status = \"unknown\" , & action = \"write\" ) ! Write Header !        write(uid_AtomicChargeFT, *) \"OmegaVec,TauOmegaVec\", \"2DDipoleX_Re\", \"2DDipoleX_Im\", \"2DDipoleY_Re\", \"2DDipoleY_Im\", \"2DDipoleZ_Re\", \"2DDipoleZ_Im\" write ( uid_AtomicChargeFT , \"(a)\" ) \"OmegaVec,TauOmegaVec,2DDipoleX_Re,2DDipoleX_Im,2DDipoleY_Re,2DDipoleY_Im,2DDipoleZ_Re,2DDipoleZ_Im\" do iOmegaTau = 1 , nTauOmegas do iOmega = 1 , nOmegas write ( uid_AtomicChargeFT , \"(*(x,e24.16,','))\" , advance = \"no\" ) OmegaVec ( iOmega ), TauOmegaVec ( iOmegaTau ), & dble ( Dipole ( 1 , iOmega , iOmegaTau )), aimag ( Dipole ( 1 , iOmega , iOmegaTau )), & dble ( Dipole ( 2 , iOmega , iOmegaTau )), aimag ( Dipole ( 2 , iOmega , iOmegaTau )) write ( uid_AtomicChargeFT , \"(E24.16,',',E24.16)\" ) & dble ( Dipole ( 3 , iOmega , iOmegaTau )), aimag ( Dipole ( 3 , iOmega , iOmegaTau )) end do enddo close ( uid_AtomicChargeFT ) end subroutine Write_2DReconstructDipole subroutine Write_ReconstructedBidimentionalDipole ( FileName , Dipole , TauOmegaVec , OmegaVec , nTauOmegas , nOmegas ) character ( len = * ), intent ( in ) :: FileName complex ( kind ( 1 d0 )), intent ( in ) :: Dipole (:, :, :) real ( kind ( 1 d0 )), intent ( in ) :: TauOmegaVec (:), OmegaVec (:) integer , intent ( in ) :: nTauOmegas , nOmegas integer :: uid_AtomicChargeFT , iOmegaTau , iOmega , iCoord open ( newunit = uid_AtomicChargeFT , & file = FileName , & form = \"formatted\" , & status = \"unknown\" , & action = \"write\" ) do iOmegaTau = 1 , nTauOmegas do iOmega = 1 , nOmegas write ( uid_AtomicChargeFT , \"(*(x,e24.16))\" ) OmegaVec ( iOmega ), TauOmegaVec ( iOmegaTau ), & (( dble ( Dipole ( iCoord , iOmega , iOmegaTau )), & ( aimag ( Dipole ( iCoord , iOmega , iOmegaTau )))), iCoord = 1 , 3 ) end do !            write(uid_AtomicChargeFT, *) enddo close ( uid_AtomicChargeFT ) end subroutine Write_ReconstructedBidimentionalDipole subroutine Load_BidimentionalChargeFTww ( FileName , ChargeFTww_new , TauOmegaVec , OmegaVec , nTauOmegas , nOmegas , nAtoms ) character ( len = * ), intent ( in ) :: FileName complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: ChargeFTww_new (:, :, :, :) real ( kind ( 1 d0 )), intent ( in ) :: TauOmegaVec (:), OmegaVec (:) integer , intent ( in ) :: nTauOmegas , nOmegas , nAtoms real ( kind ( 1 d0 )) :: dBuf real ( kind ( 1 d0 )), allocatable :: dvec1 (:), dvec2 (:) integer :: uid_AtomicChargeFT , iOmegaTau , iOmega , iAtom , iCoord , iPol character ( 200 ) :: line ! buffer to read the header integer :: ioerr allocate ( ChargeFTww_new ( 3 , nOmegas , nTauOmegas , nAtoms )) open ( newunit = uid_AtomicChargeFT , & file = FileName , & form = \"formatted\" , & status = \"old\" , & action = \"read\" ) read ( uid_AtomicChargeFT , * ) line do iOmegaTau = 1 , nTauOmegas do iOmega = 1 , nOmegas !                read(uid_AtomicChargeFT, '(a)') line read ( uid_AtomicChargeFT , \"(*(x,e24.16))\" , IOSTAT = ioerr ) dBuf , dBuf , & (( ChargeFTww_new ( iPol , iOmega , iOmegaTau , iAtom ), iPol = 1 , 3 ), iAtom = 1 , nAtoms ) end do enddo close ( uid_AtomicChargeFT ) end subroutine Load_BidimentionalChargeFTww subroutine Load_BidimentionalChargeFTww2 ( FileName , ChargeFTww_new , TauOmegaVec , OmegaVec , nTauOmegas , nOmegas , nAtoms ) character ( len = * ), intent ( in ) :: FileName complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: ChargeFTww_new (:, :, :, :) real ( kind ( 1 d0 )), allocatable , intent ( inout ) :: OmegaVec (:), TauOmegaVec (:) integer , intent ( in ) :: nTauOmegas , nOmegas , nAtoms integer :: uid_AtomicChargeFT , iOmegaTau , iOmega , iAtom , iCoord , iError real ( kind ( 1 d0 )) :: rePart , imPart character ( len = 200 ) :: headerLine ! Open the file for reading open ( newunit = uid_AtomicChargeFT , file = FileName , form = \"formatted\" , status = \"old\" , action = \"read\" , iostat = iError ) if ( iError /= 0 ) then print * , \"Error opening file:\" , FileName return endif ! Read the header line read ( uid_AtomicChargeFT , \"(a)\" , iostat = iError ) headerLine if ( iError /= 0 ) then print * , \"Error reading header from file:\" , FileName close ( uid_AtomicChargeFT ) return endif ! Allocate the ChargeFTww_new array allocate ( ChargeFTww_new ( 3 , nOmegas , nTauOmegas , nAtoms )) ! Read the data do iOmegaTau = 1 , nTauOmegas do iOmega = 1 , nOmegas read ( uid_AtomicChargeFT , \"(*(x,e24.16,','))\" , iostat = iError ) OmegaVec ( iOmega ), TauOmegaVec ( iOmegaTau ) if ( iError /= 0 ) exit do iAtom = 1 , nAtoms do iCoord = 1 , 3 read ( uid_AtomicChargeFT , \"(*(x,e24.16,','))\" , iostat = iError ) rePart , imPart if ( iError /= 0 ) exit ChargeFTww_new ( iCoord , iOmega , iOmegaTau , iAtom ) = cmplx ( rePart , imPart ) end do end do end do if ( iError /= 0 ) then print * , \"Error reading data from file:\" , FileName exit endif end do close ( uid_AtomicChargeFT ) end subroutine Load_BidimentionalChargeFTww2 end Module Module_SR_CD_IO","tags":"","loc":"sourcefile/module_cd_io.f90~2.html"},{"title":"Module_RTP.f90 – Charge Migration","text":"Files dependent on this one sourcefile~~module_rtp.f90~~AfferentGraph sourcefile~module_rtp.f90 Module_RTP.f90 sourcefile~main.f90~2 main.f90 sourcefile~main.f90~2->sourcefile~module_rtp.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module Module_CMFT_RTP implicit none private public :: GetRunTimeParameters contains !> Reads the run time parameters specified in the command line. subroutine GetRunTimeParameters ( InpDir , OutDir , FileGeometry , & StepTime , StepWidth , FieldFile , Verbous , & nOmegas , OmegaMin , OmegaMax , nTauOmegas , TauOmegaMin , TauOmegaMax ) ! use ModuleErrorHandling use ModuleCommandLineParameterList use ModuleString ! implicit none ! character ( len = :), allocatable , intent ( out ) :: InpDir character ( len = :), allocatable , intent ( out ) :: OutDir character ( len = :), allocatable , intent ( out ) :: FileGeometry real ( kind ( 1 d0 )) , intent ( out ) :: StepTime real ( kind ( 1 d0 )) , intent ( out ) :: StepWidth character ( len = :), allocatable , intent ( out ) :: FieldFile logical , intent ( out ) :: Verbous integer , intent ( out ) :: nOmegas real ( kind ( 1 d0 )) , intent ( out ) :: OmegaMin real ( kind ( 1 d0 )) , intent ( out ) :: OmegaMax integer , intent ( out ) :: nTauOmegas real ( kind ( 1 d0 )) , intent ( out ) :: TauOmegaMin real ( kind ( 1 d0 )) , intent ( out ) :: TauOmegaMax ! character ( len =* ), parameter :: PROGRAM_DESCRIPTION = & \"Computes the FT of the dipole and charge response\" type ( ClassCommandLineParameterList ) :: List character ( len = 512 ) :: strnBuf call List % SetDescription ( PROGRAM_DESCRIPTION ) call List % Add ( \"--help\" , \"Print Command Usage\" ) call List % Add ( \"-i\" , \"Input  Dir\" , \"CD_inp\" , \"optional\" ) call List % Add ( \"-o\" , \"Output Dir\" , \"CD_out\" , \"optional\" ) call List % Add ( \"-xyz\" , \"Mol Geom File in Inp Dir\" , \"geom.xyz\" , \"optional\" ) call List % Add ( \"-stept\" , \"step time\" , 10 0.d0 , \"optional\" ) call List % Add ( \"-stepw\" , \"step width\" , 1 0.d0 , \"optional\" ) call List % Add ( \"-field\" , \"Field File\" , \"Field\" , \"optional\" ) call List % Add ( \"-v\" , \"verbous\" ) call List % Add ( \"-nw\" , \"n  omegas\" , 101 , \"optional\" ) call List % Add ( \"-wmin\" , \"min omega\" , 0.d0 , \"optional\" ) call List % Add ( \"-wmax\" , \"max omega\" , 1.d0 , \"optional\" ) call List % Add ( \"-ntw\" , \"n tau omegas\" , 101 , \"optional\" ) call List % Add ( \"-twmin\" , \"min tau omega\" , 0.d0 , \"optional\" ) call List % Add ( \"-twmax\" , \"max tau omega\" , 1.d0 , \"optional\" ) call List % Add ( \"-xxx\" , \"workaround\" ) call List % Parse () if ( List % Present ( \"--help\" )) then call List % PrintUsage () stop end if call List % Get ( \"-o\" , strnBuf ) allocate ( OutDir , source = trim ( adjustl ( strnBuf ))) call List % Get ( \"-i\" , strnBuf ) allocate ( InpDir , source = trim ( adjustl ( strnBuf ))) call List % Get ( \"-xyz\" , strnBuf ) allocate ( FileGeometry , source = trim ( adjustl ( strnBuf ))) call List % Get ( \"-stept\" , StepTime ) call List % Get ( \"-stepw\" , StepWidth ) Verbous = List % Present ( \"-v\" ) call List % Get ( \"-field\" , strnBuf ) allocate ( FieldFile , source = trim ( adjustl ( strnBuf ))) call List % Get ( \"-nw\" , nOmegas ) call List % Get ( \"-wmin\" , OmegaMin ) call List % Get ( \"-wmax\" , OmegaMax ) call List % Get ( \"-ntw\" , nTauOmegas ) call List % Get ( \"-twmin\" , TauOmegaMin ) call List % Get ( \"-twmax\" , TauOmegaMax ) call List % Free () ! end subroutine GetRunTimeParameters end module Module_CMFT_RTP","tags":"","loc":"sourcefile/module_rtp.f90.html"},{"title":"main.f90 – Charge Migration","text":"This file depends on sourcefile~~main.f90~2~~EfferentGraph sourcefile~main.f90~2 main.f90 sourcefile~module_cd_io.f90~3 Module_CD_IO.f90 sourcefile~main.f90~2->sourcefile~module_cd_io.f90~3 sourcefile~module_rtp.f90 Module_RTP.f90 sourcefile~main.f90~2->sourcefile~module_rtp.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code ! {{{ Detailed description !\\mainpage Program <ProgramName> <Insert here what the program does> ! ! Synopsis: ! --------- ! !     <Program Name> <mandatory run-time parameters (RTP)> [<optional RTP>] ! ! ___ ! Description: ! ------------ ! ! Input parameters:      {#Input_Parameters} ! ================= ! [...Input](@ref ...Input) as specified in the command line. ! ! \\file ! ! ! }}} program ChargeMigrationFT use , intrinsic :: ISO_FORTRAN_ENV use ModuleErrorHandling use ModuleSystemUtils use ModuleString use ModuleIO use ModuleConstants use ModuleDiagonalize use ModulePulses_3D ! !.. Local modules use Module_CMFT_RTP use Module_CMFT_CD_IO implicit none !.. Run-time parameters !.. character ( len = :), allocatable :: InpDir , OutDir , FileGeometry real ( kind ( 1 d0 )) :: StepTime , StepWidth character ( len = :), allocatable :: Ext_field_file logical :: Verbous integer :: nOmegas , nTauOmegas real ( kind ( 1 d0 )) :: OmegaMin , OmegaMax , TauOmegaMin , TauOmegaMax !.. Data for FT !.. complex ( kind ( 1 d0 )), allocatable :: DipoleFTtotal (:, :), DipoleFTminus (:, :), DipoleFTplus (:, :) complex ( kind ( 1 d0 )), allocatable :: DipoleFTwt (:, :, :), DipoleFTww (:, :, :) complex ( kind ( 1 d0 )), allocatable :: AtomicChargeFT (:, :, :), ChargeFTwt (:, :, :, :), ChargeFTww (:, :, :, :), XUVCharge (:, :, :) real ( kind ( 1 d0 )), allocatable :: OmegaVec (:), TauOmegaVec (:) real ( kind ( 1 d0 )), allocatable :: tvec (:) integer :: iOmega , ntimes , i real ( kind ( 1 d0 )) :: tmin , tmax !.. Local parameters !.. character ( len = * ), parameter :: DIPOLE_FT_PATH_ALL = \"/Dipole/DipoleFT_ALL.csv\" character ( len = * ), parameter :: CHARGE_FT_PATH_ALL = \"/AtomicCharge/AtomicChargeFT_ALL.csv\" integer , parameter :: GS_IDX = 1 integer :: nStates integer :: uid_AtomicChargeALL , uid real ( kind ( 1 d0 )), allocatable :: Evec (:) real ( kind ( 1 d0 )), external :: NCD_Phi complex ( kind ( 1 d0 )), external :: zdotu !.. Expectation Value of the Dipole Moment (Mu) !.. complex ( kind ( 1 d0 )), allocatable :: zMuEV (:, :) !.. Molecular Geometry !.. integer :: nAtoms real ( kind ( 1 d0 )), allocatable :: AtCoord (:, :) ! 3 x npts character ( len = 16 ), allocatable :: AtomName (:) !.. Statistical Density Matrix !.. real ( kind ( 1 d0 )) :: dt !.. Pulse parameters !.. integer :: iSim , N_Simulations character ( len = 64 ), pointer :: Simulation_Tagv (:) type ( pulse_train ), pointer :: train (:) !.. XUV_Dipole and XUV_Charge !.. complex ( kind ( 1 d0 )), allocatable :: XUVDipole (:, :) complex ( kind ( 1 d0 )), allocatable :: XUVDipoleFT (:, :) !..Test !.. real ( kind ( 1 d0 )), allocatable :: AtomicChargeEvolution (:, :, :) complex ( kind ( 1 d0 )), allocatable :: Debug (:, :, :) external :: system integer :: iPol , iAtom , it , iCoord call GetRunTimeParameters ( InpDir , OutDir , FileGeometry , StepTime , StepWidth , & Ext_field_file , verbous , nOmegas , OmegaMin , OmegaMax , nTauOmegas , TauOmegaMin , TauOmegaMax ) ! These need to be deleted before running the program since they are appended call system ( \"rm \" // OutDir // DIPOLE_FT_PATH_ALL ) call system ( \"rm \" // OutDir // CHARGE_FT_PATH_ALL ) ! These are just deleted for completeness call system ( \"rm \" // OutDir // \"/Dipole/DipoleFT_ww.csv\" ) call system ( \"rm \" // OutDir // \"/AtomicCharge/AtomicChargeFT_ww.csv\" ) allocate ( OmegaVec , source = [( OmegaMin + ( OmegaMax - OmegaMin ) / dble ( nOmegas - 1 ) * dble ( iOmega - 1 ), iOmega = 1 , nOmegas )]) allocate ( TauOmegaVec , source = [( TauOmegaMin + ( TauOmegaMax - TauOmegaMin ) / dble ( nTauOmegas - 1 ) * dble ( iOmega - 1 ), iOmega = 1 , nTauOmegas )]) call Set_CD_IO_Verbous (. FALSE .) open ( newunit = uid , & file = Ext_field_file , & form = \"formatted\" , & status = \"old\" ) call Parse_Simulation_File ( uid , OUTPUT_UNIT , N_Simulations , Simulation_Tagv , train ) close ( uid ) !    write(*, \"(a,i3)\")\"N_Simulations=\", N_Simulations !.. Loads Root Ernergies and Molecular Geometry call LoadEnergies ( InpDir // \"/ROOT_ENERGIES\" , nStates , Evec ) call LoadGeometry ( nAtoms , AtCoord , FileGeometry , AtomName ) !.. Determines the number of times available, as well as the minimum and maximum time call DetermineNumberofTimes ( OutDir // \"/Dipole/Dipole\" // trim ( Simulation_tagv ( 1 )) // '.csv' , tmin , tmax , nTimes ) dt = ( tmax - tmin ) / dble ( nTimes - 1 ) Write ( * , * ) \"tmin=\" , tmin , \"tmax=\" , tmax , \"nTimes=\" , nTimes , \"dt=\" , dt !# !############################################################################################ !.. Load XUVDipole from file, Regularize it and Compute FT of XUVDipole call Load_Dipole ( OutDir // \"/Dipole/Dipole\" // trim ( Simulation_tagv ( N_Simulations )) // '.csv' , XUVDipole , nTimes ) call Regularize_XUVDipole ( XUVDipole , tmin , dt , nTimes , StepTime , StepWidth ) !    call Compute_XUVDipoleFT(XUVDipole, XUVDipoleFT, OmegaVec, tmin, dt, nTimes, nOmegas) !############################################################################################ !# !############################################################################################ !.. Load XUVCharge from file, Regularize it and Compute FT of XUVCharge call Load_XUVAtomicCharge ( OutDir // \"/AtomicCharge/AtomicCharge\" // trim ( Simulation_tagv ( N_Simulations )) // '.csv' , XUVCharge , nTimes , nAtoms ) call Regularize_XUVAtomicCharge ( XUVCharge , tmin , dt , nTimes , StepTime , StepWidth ) !########################################################################################## !# !############################################################################################ !.. Open Q_Charge File open ( newunit = uid_AtomicChargeALL , & file = OutDir // \"/AtomicCharge/AtomicCharge_ALL.csv\" , & form = \"formatted\" , & status = \"unknown\" , & action = \"write\" ) !..Redefine N_Simulatins (Last simulation is the XUV with no IR) N_Simulations = N_Simulations - 1 ! !..Start Sim_loop !.. allocate ( DipoleFTwt ( 3 , nOmegas , N_Simulations )) allocate ( DipoleFTplus ( 3 , nOmegas )) allocate ( DipoleFTminus ( 3 , nOmegas )) allocate ( DipoleFTtotal ( 3 , nOmegas )) allocate ( zMuEV ( 3 , nTimes )) allocate ( AtomicChargeEvolution ( 3 , nAtoms , nTimes )) !delete allocate ( AtomicChargeFT ( 3 , nOmegas , nAtoms )) Sim_loop : do iSim = 1 , N_Simulations write ( * , * ) \"iSim =\" , iSim , \"   N_Simulations =\" , N_Simulations !.. call Load_Dipole ( OutDir // \"/Dipole/Dipole\" // trim ( Simulation_tagv ( iSim )) // '.csv' , zMuEV , nTimes ) call Load_Q_Charge_and_Write2ALL ( OutDir // \"/AtomicCharge/AtomicCharge\" // trim ( Simulation_tagv ( iSim )) // '.csv' , & AtomicChargeEvolution , nTimes , tmin , dt , nAtoms , iSim , AtomName , uid_AtomicChargeALL ) !.. Compute the regularized dipole $\\mu_-(t)$ and Atomic Charges and FT call Regularize_Dipole_and_AtomicCharge1 ( zMuEV , AtomicChargeEvolution , tmin , dt , nTimes , StepTime , StepWidth ) zMuEV = zMuEV - XUVDipole AtomicChargeEvolution = AtomicChargeEvolution - XUVCharge ! call ComputeFT_Dipole_and_AtomicCharges ( DipoleFTminus , AtomicChargeFT , zMuEV , OmegaVec , & AtomicChargeEvolution , tmin , dt , nTimes , nOmegas ) !..Compute DipoleFTtotal DipoleFTplus = Z0 DipoleFTtotal = ( DipoleFTminus + DipoleFTplus ) !.. Save FT of Dipoles call WriteDipoleFTFile ( OutDir // \"/Dipole/DipoleFT\" // trim ( Simulation_tagv ( iSim )) // \".csv\" , & DipoleFTtotal , OmegaVec , nOmegas ) !.. Write the FT of Dipoles to a single file call AppendDipole2FTAllFile ( OutDir // DIPOLE_FT_PATH_ALL , DipoleFTtotal , OmegaVec , & nOmegas , iSim , train ) !.. Save Atomic Charge FT call WriteAtomicChargeFT ( OutDir // \"/AtomicCharge/AtomicChargeFT\" // trim ( Simulation_tagv ( iSim )) // \".csv\" , & AtomicChargeFT , OmegaVec , nOmegas , nAtoms , AtomName ) ! !.. Save Atomic Charge FT in a single file call WriteAllAtomicChargeFTtoSingleFile ( OutDir // CHARGE_FT_PATH_ALL , AtomicChargeFT , OmegaVec , & nOmegas , nAtoms , iSim , train , AtomName ) end do Sim_loop close ( uid_AtomicChargeALL ) !############################################################################################ !# !# !############################################################################################ !.. COMPUTE 2D SPECTRUM DIPOLE ! !.. Load the FT of the dipole, as a function of the time delay call LoadFTDipole_asfuncitonof_TimeDelay ( OutDir // DIPOLE_FT_PATH_ALL , N_simulations , nOmegas , DipoleFTwt , tvec ) ! !.. Regularizes the dipole with respect to the time-delay edges and Compute FT with respect to time call Regularize_Dipole_withRespectto_TimeDelay ( DipoleFTwt , tvec , N_Simulations ) call Compute_FTofDipole_withRespectto_Time ( DipoleFTwt , DipoleFTww , tvec , TauOmegaVec , N_Simulations , nTauOmegas ) ! !.. Write the Bidimensional spectrum to file call SaveBidimentioal_Dipole_Spectrum ( OutDir // \"/Dipole/DipoleFT_ww.csv\" , DipoleFTww , TauOmegaVec , OmegaVec , nTauOmegas , nOmegas ) deallocate ( tvec ) !############################################################################################ !# !# !############################################################################################ !.. COMPUTE 2D SPECTRUM CHARGE !.. !.. Load the FT of the charge, as a functAtomicChargeion of the time delay call LoadFTofChargeasFuncofTimeDelay ( OutDir // CHARGE_FT_PATH_ALL , N_simulations , nOmegas , nAtoms , tvec , ChargeFTwt ) ! !.. Regularizes the charge with respect to the time-delay edges call Regularize_Charge_withtimedelay ( ChargeFTwt , tvec , nAtoms , N_Simulations ) !.. Compute the FT wrt the time delay call Compute_FTCharge_withTimeDelay ( ChargeFTwt , tvec , ChargeFTww , N_simulations , nOmegas , nAtoms , nTauOmegas , TauOmegaVec ) !.. Write the Bidimensional spectrum to file !    call Write_BidimentionalChargeFTww(OutDir // \"/AtomicCharge/AtomicChargeFT_ww\", ChargeFTww, TauOmegaVec, OmegaVec, nTauOmegas, nOmegas, nAtoms) call Write_BidimentionalChargeFTww ( OutDir // \"/AtomicCharge/AtomicChargeFT_ww.csv\" , ChargeFTww , TauOmegaVec , OmegaVec , nTauOmegas , nOmegas , nAtoms , AtomName ) !############################################################################################ !# stop contains subroutine DetermineNumberOfTimes ( FileName , tmin , tmax , nTimes ) character ( len = * ), intent ( in ) :: FileName real ( kind ( 1 d0 )), intent ( out ) :: tmin , tmax integer , intent ( out ) :: nTimes real ( kind ( 1 d0 )) :: dBuf integer :: uid_dipole , iostat , iBuf character ( 200 ) :: line ! buffer to read the header open ( newunit = uid_dipole , & file = FileName , & form = \"formatted\" , & status = \"old\" , & action = \"read\" ) ! Read header line and ignore it read ( uid_dipole , '(a)' ) line read ( uid_dipole , * , iostat = iostat ) iBuf , dBuf if ( iostat /= 0 ) then write ( * , * ) FileName // \" IS EMPTY\" stop end if tmin = dBuf tmax = tmin nTimes = 1 do read ( uid_dipole , * , iostat = iostat ) iBuf , dBuf if ( iostat /= 0 ) exit tmax = dBuf nTimes = nTimes + 1 end do close ( uid_dipole ) write ( * , * ) \"nTimes = \" , nTimes end subroutine DetermineNumberOfTimes subroutine Regularize_XUVDipole ( XUVDipole , tmin , dt , nTimes , StepTime , StepWidth ) complex ( kind ( 1 d0 )), intent ( inout ) :: XUVDipole (:, :) real ( kind ( 1 d0 )), intent ( in ) :: tmin , dt , StepTime , StepWidth integer , intent ( in ) :: nTimes real ( kind ( 1 d0 )), external :: NCD_Phi integer :: it real ( kind ( 1 d0 )) :: dstep , t , StepT do it = 1 , nTimes t = tmin + dt * dble ( it - 1 ) StepT = StepTime if ( abs ( t - StepTime ) <= dt / 2.d0 ) then StepT = t endif dstep = 1.d0 - NCD_Phi ( t , StepT , StepWidth ) XUVDipole (:, it ) = XUVDipole (:, it ) * dstep enddo end subroutine Regularize_XUVDipole subroutine Regularize_XUVAtomicCharge ( Charge , tmin , dt , nTimes , StepTime , StepWidth ) complex ( kind ( 1 d0 )), intent ( inout ) :: Charge (:, :, :) real ( kind ( 1 d0 )), intent ( in ) :: tmin , dt , StepTime , StepWidth integer , intent ( in ) :: nTimes real ( kind ( 1 d0 )), external :: NCD_Phi integer :: it real ( kind ( 1 d0 )) :: dstep , t , StepT do it = 1 , nTimes t = tmin + dt * dble ( it - 1 ) StepT = StepTime if ( abs ( t - StepTime ) <= dt / 2.d0 ) then StepT = t endif dstep = 1.d0 - NCD_Phi ( t , StepT , StepWidth ) do iPol = 1 , 3 Charge ( iPol , :, it ) = Charge ( iPol , :, it ) * dstep end do enddo end subroutine Regularize_XUVAtomicCharge subroutine Regularize_Dipole_and_AtomicCharge1 ( Dipole , Charge , tmin , dt , nTimes , StepTime , StepWidth ) complex ( kind ( 1 d0 )), intent ( inout ) :: Dipole (:, :) real ( kind ( 1 d0 )), intent ( inout ) :: Charge (:, :, :) real ( kind ( 1 d0 )), intent ( in ) :: tmin , dt , StepTime , StepWidth integer , intent ( in ) :: nTimes real ( kind ( 1 d0 )), external :: NCD_Phi integer :: it real ( kind ( 1 d0 )) :: dstep , t , StepT do it = 1 , nTimes t = tmin + dt * dble ( it - 1 ) StepT = StepTime if ( abs ( t - StepTime ) <= dt / 2.d0 ) then StepT = t endif dstep = 1.d0 - NCD_Phi ( t , StepT , StepWidth ) Dipole (:, it ) = Dipole (:, it ) * dstep do iPol = 1 , 3 Charge ( iPol , :, it ) = Charge ( iPol , :, it ) * dstep enddo end do end subroutine Regularize_Dipole_and_AtomicCharge1 subroutine ComputeFT_Dipole_and_AtomicCharges ( DipoleFTminus , AtomicChargeFT , Dipole , OmegaVec , & AtomicChargeEvolution , tmin , dt , nTimes , nOmegas ) complex ( kind ( 1 d0 )), intent ( out ) :: DipoleFTminus (:, :) complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: AtomicChargeFT (:, :, :) complex ( kind ( 1 d0 )), intent ( in ) :: Dipole (:, :) real ( kind ( 1 d0 )), intent ( in ) :: OmegaVec (:), AtomicChargeEvolution (:, :, :) real ( kind ( 1 d0 )), intent ( in ) :: tmin , dt integer , intent ( in ) :: nTimes , nOmegas complex ( kind ( 1 d0 )) :: zExpFact real ( kind ( 1 d0 )) :: t , w integer :: iOmega , it , iPol if (. not . allocated ( AtomicChargeFT )) allocate ( AtomicChargeFT ( 3 , nOmegas , nAtoms )) DipoleFTminus = Z0 AtomicChargeFT = Z0 do iOmega = 1 , nOmegas w = OmegaVec ( iOmega ) do it = 1 , nTimes t = tmin + dt * dble ( it - 1 ) zexpFact = exp ( Zi * w * t ) DipoleFTminus (:, iOmega ) = DipoleFTminus (:, iOmega ) + zExpFact * Dipole (:, it ) do iPol = 1 , 3 AtomicChargeFT ( iPol , iOmega , :) = AtomicChargeFT ( iPol , iOmega , :) + & zExpFact * AtomicChargeEvolution ( iPol , :, it ) end do !            WRITE(*, *) \"AtomicChargeEvolution(iPol, :, it)=\", AtomicChargeEvolution(1, 1, it) enddo end do DipoleFTminus = DipoleFTminus * dt / ( 2.d0 * PI ) !((2.d0 * PI)**(1 / 2)) AtomicChargeFT = AtomicChargeFT * dt / ( 2.d0 * PI ) !((2.d0 * PI)**(1 / 2)) end subroutine ComputeFT_Dipole_and_AtomicCharges ! ! !############################################################################################ !..Bidimentional Spectrum Subroutines subroutine Regularize_Dipole_withRespectto_TimeDelay ( DipoleFTwt , tvec , N_Simulations ) complex ( kind ( 1 d0 )), intent ( inout ) :: DipoleFTwt (:, :, :) real ( kind ( 1 d0 )), intent ( in ) :: tvec (:) integer , intent ( in ) :: N_Simulations real ( kind ( 1 d0 )), external :: NCD_Phi integer :: iSim real ( kind ( 1 d0 )) :: dstep , t , tStep1 , tStep2 , StepWidth !        tStep1 = tvec(N_Simulations / 20) !        tStep2 = tvec(9 * N_Simulations / 20) !        StepWidth = (tvec(N_Simulations) - tvec(1)) / 30.d0 tStep1 = tvec ( max ( nint ( 0.2d0 * dble ( N_Simulations )), 1 )) tStep2 = tvec ( nint ( 8.d0 * N_Simulations / 1 0.d0 )) StepWidth = ( tvec ( N_Simulations ) - tvec ( 1 )) / 1 5.d0 do iSim = 1 , N_Simulations t = tvec ( iSim ) dstep = NCD_Phi ( t , tStep1 , StepWidth ) * ( 1.d0 - NCD_Phi ( t , tStep2 , StepWidth )) DipoleFTwt (:, :, iSim ) = dstep * DipoleFTwt (:, :, iSim ) enddo end subroutine Regularize_Dipole_withRespectto_TimeDelay subroutine Compute_FTofDipole_withRespectto_Time ( DipoleFTwt , DipoleFTww , tvec , TauOmegaVec , N_Simulations , nTauOmegas ) complex ( kind ( 1 d0 )), intent ( in ) :: DipoleFTwt (:, :, :) complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: DipoleFTww (:, :, :) real ( kind ( 1 d0 )), intent ( in ) :: tvec (:) real ( kind ( 1 d0 )), intent ( in ) :: TauOmegaVec (:) integer , intent ( in ) :: N_Simulations , nTauOmegas complex ( kind ( 1 d0 )) :: zExpFact integer :: iOmega , iSim real ( kind ( 1 d0 )) :: t , w , dt allocate ( DipoleFTww ( 3 , nOmegas , nTauOmegas )) DipoleFTww = Z0 dt = tvec ( 2 ) - tvec ( 1 ) do iOmega = 1 , nTauOmegas w = TauOmegaVec ( iOmega ) do iSim = 1 , N_Simulations t = tvec ( iSim ) zexpFact = exp ( Zi * w * t ) DipoleFTww (:, :, iOmega ) = DipoleFTww (:, :, iOmega ) + zExpFact * DipoleFTwt (:, :, iSim ) end do enddo DipoleFTww = DipoleFTww * dt / ( 2.d0 * PI ) !((2.d0 * PI)**(1 / 2)) end subroutine Compute_FTofDipole_withRespectto_Time !.. Regularizes the charge with respect to the time-delay edges !.. subroutine Regularize_Charge_withtimedelay ( ChargeFTwt , tvec , nAtoms , N_Simulations ) complex ( kind ( 1 d0 )), intent ( inout ) :: ChargeFTwt (:, :, :, :) real ( kind ( 1 d0 )), intent ( in ) :: tvec (:) integer , intent ( in ) :: nAtoms , N_Simulations real ( kind ( 1 d0 )), external :: NCD_Phi real ( kind ( 1 d0 )) :: dstep , t , tStep1 , tStep2 , StepWidth integer :: iAtom , iSim tStep1 = tvec ( max ( nint ( 0.2d0 * dble ( N_Simulations )), 1 )) tStep2 = tvec ( nint ( 8.d0 * N_Simulations / 1 0.d0 )) StepWidth = ( tvec ( N_Simulations ) - tvec ( 1 )) / 1 5.d0 do iAtom = 1 , nAtoms do iSim = 1 , N_Simulations t = tvec ( iSim ) dstep = NCD_Phi ( t , tStep1 , StepWidth ) * ( 1.d0 - NCD_Phi ( t , tStep2 , StepWidth )) do iPol = 1 , 3 ChargeFTwt ( iPol , :, iSim , iAtom ) = dstep * ChargeFTwt ( iPol , :, iSim , iAtom ) end do enddo enddo end subroutine Regularize_Charge_withtimedelay subroutine Compute_FTCharge_withTimeDelay ( ChargeFTwt , tvec , ChargeFTww , N_simulations , nOmegas , nAtoms , nTauOmegas , TauOmegaVec ) complex ( kind ( 1 d0 )), intent ( in ) :: ChargeFTwt (:, :, :, :) real ( kind ( 1 d0 )), intent ( in ) :: tvec (:), TauOmegaVec (:) complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: ChargeFTww (:, :, :, :) integer , intent ( in ) :: N_simulations , nOmegas , nAtoms , nTauOmegas complex ( kind ( 1 d0 )) :: zExpFact real ( kind ( 1 d0 )) :: dt , w , t integer :: iAtom , iOmega , iSim allocate ( ChargeFTww ( 3 , nOmegas , nTauOmegas , nAtoms )) dt = ( tvec ( N_simulations ) - tvec ( 1 )) / dble ( N_simulations - 1 ) do iAtom = 1 , nAtoms do iOmega = 1 , nTauOmegas w = TauOmegaVec ( iOmega ) do iSim = 1 , N_Simulations t = tvec ( iSim ) zexpFact = exp ( Zi * w * t ) !          if(iAtom==1)write(*,*) iSim, iOmega, t, w do iPol = 1 , 3 ChargeFTww ( iPol , :, iOmega , iAtom ) = ChargeFTww ( iPol , :, iOmega , iAtom ) + & zExpFact * ChargeFTwt ( iPol , :, iSim , iAtom ) end do end do enddo enddo ChargeFTww = ChargeFTww * dt / ( 2.d0 * PI ) ! ((2.d0 * PI)**(1 / 2)) end subroutine Compute_FTCharge_withTimeDelay end program ChargeMigrationFT !this are notes and aspirations .. :] ! THE FT OF THE DIPOLE FOR LARGE TIME STILL DOES NOT WORK !     DipoleFTplus = Z0 !     call ComputeDipoleFTplus( L0_Eval, L0_LEvec, L0_REvec, & !          OmegaVec, zStatRho0, DipoleFTplus, StepTime, StepWidth ) !     ! !     !*** MUST GO TO A SEPARATE SUBROUTINE !     !.. Save Dipole FT File !     open(newunit = uid_dipoleFT, & !          file    =\"DipoleFT+\"//trim(Simulation_tagv(iSim)), & !          form    =\"formatted\", & !          status  =\"unknown\"  , & !          action  =\"write\"    ) !     do iOmega = 1, nOmegas !        w = OmegaVec( iOmega ) !        write(uid_dipoleFT,\"(i4,*(x,E24.16))\") iOmega, w, & !             ((dble(DipoleFTplus(iPol,iOmega)),aimag(DipoleFTplus(iPol,iOmega))),iPol=1,3) !     end do !     close( uid_dipoleFT ) !     DipoleFTtotal = DipoleFTminus + DipoleFTplus ! APPARENTLY, IT IS NOT WORKING YET! !    subroutine ComputeDipoleFTplus(& !            L0_Eval, L0_LEvec, L0_REvec, & !            OmegaVec, zStatRho0, DipoleFTplus, & !            StepTime, StepWidth) ! !        complex(kind(1d0)), intent(in) :: L0_LEvec(:, :), L0_REvec(:, :), L0_Eval(:), zStatRho0(:, :) !        real   (kind(1d0)), intent(in) :: OmegaVec(:) !        complex(kind(1d0)), intent(out) :: DipoleFTplus(:, :) !        real   (kind(1d0)), intent(in) :: StepTime, StepWidth ! !        real(kind(1d0)), parameter :: DIPOLE_THRESHOLD = 1.d-49 ! !        logical, save :: FIRST_CALL = .TRUE. !        integer, save :: nliou, nStates, nOmegas !        complex(kind(1d0)), allocatable, save :: zmat1(:, :), zmat2(:, :), zvec1(:), zvec2(:), zvec3(:) !        integer :: iPol, iOmega, iLiou, iState !        real(kind(1d0)) :: w, sigma ! !        if(FIRST_CALL)then ! !            nliou = size(L0_Eval, 1) !            nStates = size(zStatRho0, 1) !            nOmegas = size(OmegaVec) !            allocate(zvec1(nLiou)) !            allocate(zvec2(nLiou)) !            allocate(zvec3(nLiou)) !            allocate(zmat1(nStates, nStates)) !            allocate(zmat2(nStates, nStates)) !            zmat1 = Z0 !            zmat2 = Z0 !            zvec1 = Z0 !            zvec2 = Z0 !            zvec3 = Z0 ! !            FIRST_CALL = .FALSE. ! !        endif ! !        sigma = StepWidth / sqrt(2.d0) ! !        do iPol = 1, 3 !            call ZGEMM(\"N\", \"N\", nStates, nStates, nStates, Z1, zStatRho0, nStates, & !                    Dmat(1, 1, iPol), nStates, Z0, zmat1, nStates) !            call HilbertToLiouvilleMatrix(zmat1, zvec1) !            call ZGEMV(\"C\", nLiou, nLiou, Z1, L0_LEvec, nLiou, zvec1, 1, Z0, zvec2, 1) !            do iOmega = 1, nOmegas !                w = OmegaVec(iOmega) !                do iLiou = 1, nLiou !                    !*** CHECK CONSISTENCY OF SIGMA AND STEPWIDTH !                    zvec1(iLiou) = exp(-sigma**2 * (w - L0_Eval(iLiou))**2) / (w - L0_Eval(iLiou)) * zvec2(iLiou) !                    !*** !                enddo !                call ZGEMV(\"N\", nLiou, nLiou, Z1, L0_REvec, nLiou, zvec1, 1, Z0, zvec3, 1) !                call LiouvilleToHilbertMatrix(zvec3, zmat2) !                DipoleFTplus(iPol, iOmega) = 0.d0 !                do iState = 1, nStates !                    DipoleFTplus(iPol, iOmega) = DipoleFTplus(iPol, iOmega) + zmat2(iState, iState) !                enddo !                DipoleFTplus(iPol, iOmega) = DipoleFTplus(iPol, iOmega) * exp(Zi * w * StepTime) / (2.d0 * PI) ! !                if(abs(DipoleFTplus(iPol, iOmega)) < DIPOLE_THRESHOLD) DipoleFTplus(iPol, iOmega) = 0.d0 ! !            enddo !        enddo ! !    end subroutine ComputeDipoleFTplus","tags":"","loc":"sourcefile/main.f90~2.html"},{"title":"ModuleRTP.f90 – Charge Migration","text":"Files dependent on this one sourcefile~~modulertp.f90~~AfferentGraph sourcefile~modulertp.f90 ModuleRTP.f90 sourcefile~main.f90 main.f90 sourcefile~main.f90->sourcefile~modulertp.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code module Module_CM_RTP implicit none private public :: GetRunTimeParameters contains !> Reads the run time parameters specified in the command line. subroutine GetRunTimeParameters ( input_directory , output_directory , molecular_geometry_file , & n_times , t_min , t_max , FieldFile , Verbous , Weight_File , read_precomputed_weights_flag , & save_charge_migration_flag , ivorb , counted_number_of_orbitals , dephasing_factor , relaxation_factor , bath_temperature ) !! Reads the run time parameters specified in the command line. ! use ModuleErrorHandling use ModuleCommandLineParameterList use ModuleString ! implicit none ! character ( len = :), allocatable , intent ( out ) :: input_directory character ( len = :), allocatable , intent ( out ) :: output_directory character ( len = :), allocatable , intent ( out ) :: molecular_geometry_file integer , intent ( out ) :: n_times real ( kind ( 1 d0 )), intent ( out ) :: t_min real ( kind ( 1 d0 )), intent ( out ) :: t_max character ( len = :), allocatable , intent ( out ) :: FieldFile character ( len = :), allocatable , intent ( out ) :: Weight_File logical , intent ( out ) :: read_precomputed_weights_flag logical , intent ( out ) :: Verbous logical , intent ( out ) :: save_charge_migration_flag integer , allocatable , intent ( out ) :: ivorb (:) real ( kind ( 1 d0 )), intent ( out ) :: dephasing_factor real ( kind ( 1 d0 )), intent ( out ) :: relaxation_factor real ( kind ( 1 d0 )), intent ( out ) :: bath_temperature ! character ( len = * ), parameter :: PROGRAM_DESCRIPTION = & \"Computes the Charge Density on a spatial grid from \" // & \"tabulated orbitals, The Density Matrices and Transition Density Matrices\" type ( ClassCommandLineParameterList ) :: List character ( len = 512 ) :: strnBuf CHARACTER ( 10000 ) :: orbital_string integer , intent ( out ) :: counted_number_of_orbitals integer :: pos1 , pos2 , i , number_of_orbitals , ERROR_FLAG call List % SetDescription ( PROGRAM_DESCRIPTION ) call List % Add ( \"--help\" , \"Print Command Usage\" ) call List % Add ( \"-i\" , \"Input  Dir\" , \"CD_inp\" , \"optional\" ) call List % Add ( \"-o\" , \"Output Dir\" , \"CD_out\" , \"optional\" ) call List % Add ( \"-xyz\" , \"Mol Geom File in Inp Dir\" , \"geom.xyz\" , \"optional\" ) call List % Add ( \"-nt\" , \"n times\" , 101 , \"optional\" ) call List % Add ( \"-t_min\" , \"min time\" , 0.d0 , \"optional\" ) call List % Add ( \"-t_max\" , \"max time\" , 20 0.d0 , \"optional\" ) call List % Add ( \"-field\" , \"Field File\" , \"Field\" , \"optional\" ) call List % Add ( \"-w\" , \"Becke's Weights File\" , \"Weights_File\" , \"optional\" ) call List % Add ( \"-v\" , \"verbous\" ) call List % Add ( \"-sden\" , \"Save Charge Density to file (time consuming!)\" ) call List % Add ( \"-iorb\" , \"absolute index active orbitals \" , \"7,8,9,10,11,12,13\" , \"optional\" ) call List % Add ( \"-bath\" , \"BATH TEMPERATURE\" , 32717 5.d-2 , \"optional\" ) call List % Add ( \"-rf\" , \"RELAXATION FACTOR\" , 1.d-3 , \"optional\" ) call List % Add ( \"-df\" , \"DEPHASING FACTOR\" , 1.d-3 , \"optional\" ) call List % Add ( \"-xxx\" , \"workaround\" ) call List % Parse () if ( List % Present ( \"--help\" )) then call List % PrintUsage () stop end if call List % Get ( \"-o\" , strnBuf ) allocate ( output_directory , source = trim ( adjustl ( strnBuf ))) call List % Get ( \"-i\" , strnBuf ) allocate ( input_directory , source = trim ( adjustl ( strnBuf ))) call List % Get ( \"-xyz\" , strnBuf ) allocate ( molecular_geometry_file , source = trim ( adjustl ( strnBuf ))) call List % Get ( \"-nt\" , n_times ) call List % Get ( \"-t_min\" , t_min ) call List % Get ( \"-t_max\" , t_max ) call List % Get ( \"-rf\" , relaxation_factor ) call List % Get ( \"-df\" , dephasing_factor ) call List % Get ( \"-bath\" , bath_temperature ) Verbous = List % Present ( \"-v\" ) save_charge_migration_flag = List % Present ( \"-sden\" ) read_precomputed_weights_flag = List % Present ( \"-w\" ) call List % Get ( \"-w\" , strnBuf ) allocate ( Weight_File , source = trim ( adjustl ( strnBuf ))) call List % Get ( \"-field\" , strnBuf ) allocate ( FieldFile , source = trim ( adjustl ( strnBuf ))) pos1 = 1 number_of_orbitals = 0 call List % Get ( \"-iorb\" , orbital_string ) counted_number_of_orbitals = 1 do pos1 = index ( orbital_string , \",\" ) if ( pos1 <= 0 ) exit counted_number_of_orbitals = counted_number_of_orbitals + 1 orbital_string ( pos1 : pos1 ) = \" \" enddo allocate ( ivorb ( counted_number_of_orbitals )) do i = 1 , counted_number_of_orbitals pos1 = index ( orbital_string , \" \" ) if ( pos1 > 0 ) then read ( orbital_string ( 1 : pos1 - 1 ), * ) ivorb ( i ) orbital_string = orbital_string ( pos1 + 1 :) else read ( orbital_string , * ) ivorb ( i ) endif enddo call List % Free () ! end subroutine GetRunTimeParameters end module Module_CM_RTP","tags":"","loc":"sourcefile/modulertp.f90.html"},{"title":"ModuleRTP.f90 – Charge Migration","text":"Source Code module Module_SR_RTP implicit none private public :: GetRunTimeParameters contains !> Reads the run time parameters specified in the command line. subroutine GetRunTimeParameters ( InpDir , OutDir , FileGeometry , & StepTime , StepWidth , FieldFile , Verbous , & nOmegas , OmegaMin , OmegaMax , nTauOmegas , TauOmegaMin , TauOmegaMax ) ! use ModuleErrorHandling use ModuleCommandLineParameterList use ModuleString ! implicit none ! character ( len = :), allocatable , intent ( out ) :: InpDir character ( len = :), allocatable , intent ( out ) :: OutDir character ( len = :), allocatable , intent ( out ) :: FileGeometry real ( kind ( 1 d0 )) , intent ( out ) :: StepTime real ( kind ( 1 d0 )) , intent ( out ) :: StepWidth character ( len = :), allocatable , intent ( out ) :: FieldFile logical , intent ( out ) :: Verbous integer , intent ( out ) :: nOmegas real ( kind ( 1 d0 )) , intent ( out ) :: OmegaMin real ( kind ( 1 d0 )) , intent ( out ) :: OmegaMax integer , intent ( out ) :: nTauOmegas real ( kind ( 1 d0 )) , intent ( out ) :: TauOmegaMin real ( kind ( 1 d0 )) , intent ( out ) :: TauOmegaMax ! character ( len =* ), parameter :: PROGRAM_DESCRIPTION = & \"Computes the FT of the dipole and charge response\" type ( ClassCommandLineParameterList ) :: List character ( len = 512 ) :: strnBuf call List % SetDescription ( PROGRAM_DESCRIPTION ) call List % Add ( \"--help\" , \"Print Command Usage\" ) call List % Add ( \"-i\" , \"Input  Dir\" , \"CD_inp\" , \"optional\" ) call List % Add ( \"-o\" , \"Output Dir\" , \"CD_out\" , \"optional\" ) call List % Add ( \"-xyz\" , \"Mol Geom File in Inp Dir\" , \"geom.xyz\" , \"optional\" ) call List % Add ( \"-stept\" , \"step time\" , 10 0.d0 , \"optional\" ) call List % Add ( \"-stepw\" , \"step width\" , 1 0.d0 , \"optional\" ) call List % Add ( \"-field\" , \"Field File\" , \"Field\" , \"optional\" ) call List % Add ( \"-v\" , \"verbous\" ) call List % Add ( \"-nw\" , \"n  omegas\" , 101 , \"optional\" ) call List % Add ( \"-wmin\" , \"min omega\" , 0.d0 , \"optional\" ) call List % Add ( \"-wmax\" , \"max omega\" , 1.d0 , \"optional\" ) call List % Add ( \"-ntw\" , \"n tau omegas\" , 101 , \"optional\" ) call List % Add ( \"-twmin\" , \"min tau omega\" , 0.d0 , \"optional\" ) call List % Add ( \"-twmax\" , \"max tau omega\" , 1.d0 , \"optional\" ) call List % Add ( \"-xxx\" , \"workaround\" ) call List % Parse () if ( List % Present ( \"--help\" )) then call List % PrintUsage () stop end if call List % Get ( \"-o\" , strnBuf ) allocate ( OutDir , source = trim ( adjustl ( strnBuf ))) call List % Get ( \"-i\" , strnBuf ) allocate ( InpDir , source = trim ( adjustl ( strnBuf ))) call List % Get ( \"-xyz\" , strnBuf ) allocate ( FileGeometry , source = trim ( adjustl ( strnBuf ))) call List % Get ( \"-stept\" , StepTime ) call List % Get ( \"-stepw\" , StepWidth ) Verbous = List % Present ( \"-v\" ) call List % Get ( \"-field\" , strnBuf ) allocate ( FieldFile , source = trim ( adjustl ( strnBuf ))) call List % Get ( \"-nw\" , nOmegas ) call List % Get ( \"-wmin\" , OmegaMin ) call List % Get ( \"-wmax\" , OmegaMax ) call List % Get ( \"-ntw\" , nTauOmegas ) call List % Get ( \"-twmin\" , TauOmegaMin ) call List % Get ( \"-twmax\" , TauOmegaMax ) call List % Free () ! end subroutine GetRunTimeParameters end module Module_SR_RTP","tags":"","loc":"sourcefile/modulertp.f90~2.html"},{"title":"Module_CD_IO.f90 – Charge Migration","text":"Files dependent on this one sourcefile~~module_cd_io.f90~3~~AfferentGraph sourcefile~module_cd_io.f90~3 Module_CD_IO.f90 sourcefile~main.f90~2 main.f90 sourcefile~main.f90~2->sourcefile~module_cd_io.f90~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code Module Module_CMFT_CD_IO use , intrinsic :: ISO_FORTRAN_ENV use ModulePulses_3D use ModuleConstants use ModuleErrorHandling implicit none private logical :: Verbous public :: & Set_CD_IO_Verbous , & LoadGeometry , & LoadEnergies , & WriteDipoleFTFile , & Load_Q_Charge_and_Write2ALL , & WriteAtomicChargeFT , & AppendDipole2FTAllFile , & WriteAllAtomicChargeFTtoSingleFile , & Load_Dipole , & LoadAtomicCharges , & LoadFTDipole_asfuncitonof_TimeDelay , & SaveBidimentioal_Dipole_Spectrum , & LoadFTofChargeasFuncofTimeDelay , & Write_BidimentionalChargeFTww , & Load_XUVAtomicCharge contains subroutine Set_CD_IO_Verbous ( logi ) logical , intent ( in ) :: logi Verbous = logi end subroutine Set_CD_IO_Verbous subroutine replace_char ( strn , ch1 , ch2 ) character ( len = * ), intent ( inout ) :: strn character , intent ( in ) :: ch1 , ch2 integer :: i do i = index ( strn , ch1 ) if ( i <= 0 ) exit strn ( i : i ) = ch2 enddo end subroutine replace_char function int2strn ( int_num ) result ( strn ) integer , intent ( in ) :: int_num character ( len = 16 ) :: strn write ( strn , \"(i16)\" ) int_num strn = adjustl ( strn ) strn = trim ( strn ) end function int2strn !> Load the position of the atomic nuclei subroutine LoadGeometry ( nAtoms , AtCoord , FileName , AtomName ) ! integer , intent ( out ) :: nAtoms real ( kind ( 1 d0 )), allocatable , intent ( out ) :: AtCoord (:, :) character ( len = * ), intent ( in ) :: FileName ! integer :: iAtom , iCoord , uid character ( len = 16 ), allocatable , intent ( out ) :: AtomName (:) ! !.. Open file with geometry open ( newunit = uid , file = trim ( FileName ), form = \"formatted\" , status = \"old\" ) !*** Skip to the line specifying the number of atoms ! determine the number of atoms read ( uid , * ) nAtoms !*** Skip to the line where the coordinates start to be listed !allocate the matrix of coordinates read ( uid , * ) allocate ( AtCoord ( 3 , nAtoms )) allocate ( AtomName ( nAtoms )) do iAtom = 1 , nAtoms read ( uid , * ) AtomName ( iAtom ), ( AtCoord ( iCoord , iAtom ), iCoord = 1 , 3 ) enddo close ( uid ) end subroutine LoadGeometry !> Loads the Energies found inside the InpDir subroutine LoadEnergies ( FileName , nStates , Evec ) ! use ModuleErrorHandling use ModuleString ! implicit none ! character ( len = * ), intent ( in ) :: FileName integer , intent ( out ) :: nStates real ( kind ( 1 d0 )), allocatable , intent ( out ) :: Evec (:) integer :: uid , iostat character ( len = 1000 ) :: iomsg real ( kind ( 1 d0 )) :: E integer :: i open (& newunit = uid , & file = FileName , & form = \"formatted\" , & status = \"old\" , & action = \"read\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call errormessage ( trim ( iomsg )) stop endif nStates = 0 do read ( uid , * , iostat = iostat ) E if ( iostat /= 0 ) exit nStates = nStates + 1 enddo rewind ( uid ) allocate ( Evec ( nStates )) write ( * , \"(a)\" ) \" State Energies \" do i = 1 , nStates read ( uid , * ) Evec ( i ) !write(*,*) i, Evec(i) enddo write ( * , * ) close ( uid ) ! end subroutine LoadEnergies ! subroutine Load_XUVAtomicCharge ( FileName , Charge , nTimes , nAtoms ) character ( len = * ), intent ( in ) :: FileName integer , intent ( in ) :: nTimes , nAtoms complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: Charge (:, :, :) real ( kind ( 1 d0 )) :: dBuf real ( kind ( 1 d0 )), parameter :: IMAG_THRESHOLD = 1.d-12 integer :: uid , it , iBuf , iAtom , iPol character ( 200 ) :: line ! buffer to read the header allocate ( Charge ( 3 , nAtoms , ntimes )) !..Load dipole from file open ( newunit = uid , & file = FileName , & form = \"formatted\" , & status = \"old\" , & action = \"read\" ) ! Read and ignore the header read ( uid , '(a)' ) line do it = 1 , nTimes read ( uid , * ) iBuf , dBuf , dBuf , (( Charge ( iPol , iAtom , it ), iPol = 1 , 3 ), iAtom = 1 , nAtoms ) enddo close ( uid ) end subroutine Load_XUVAtomicCharge subroutine Load_Dipole ( FileName , Dipole , nTimes ) character ( len = * ), intent ( in ) :: FileName integer , intent ( in ) :: nTimes complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: Dipole (:, :) real ( kind ( 1 d0 )) :: dBuf real ( kind ( 1 d0 )), allocatable :: dvecReal (:), dvecImag (:) real ( kind ( 1 d0 )), parameter :: IMAG_THRESHOLD = 1.d-12 integer :: uid_dipole , it , iBuf , iPol character ( 200 ) :: line ! buffer to read the header allocate ( Dipole ( 3 , nTimes )) Dipole = Z0 allocate ( dvecReal ( 3 ), dvecImag ( 3 )) open ( newunit = uid_dipole , & file = FileName , & form = \"formatted\" , & status = \"old\" , & action = \"read\" ) ! Read and ignore the header read ( uid_dipole , '(a)' ) line do it = 1 , nTimes read ( uid_dipole , * ) iBuf , dBuf , dvecReal ( 1 ), dvecImag ( 1 ), dvecReal ( 2 ), dvecImag ( 2 ), dvecReal ( 3 ), dvecImag ( 3 ) ! Check for significant imaginary components if ( sum ( abs ( dvecImag )) > IMAG_THRESHOLD ) then write ( ERROR_UNIT , \"(a,d14.6)\" ) \"non-zero imaginary dipole\" , sum ( abs ( dvecImag )) endif do iPol = 1 , 3 !   Dipole(iPol, it) = cmplx(dvecReal(iPol), 0.0, kind = 1d0)  ! As the imaginary part is assumed to be negligible Dipole ( iPol , it ) = Z1 * dvecReal ( iPol ) enddo enddo close ( uid_dipole ) end subroutine Load_Dipole subroutine Load_Q_Charge_and_Write2ALL ( FileName , Charge , nTimes , tmin , dt , nAtoms , iSim , atom_names , uid_AtomicChargeALL ) character ( len = * ), intent ( in ) :: FileName real ( kind ( 1 d0 )), allocatable , intent ( out ) :: Charge (:, :, :) real ( kind ( 1 d0 )), intent ( in ) :: tmin , dt character ( len = 16 ), intent ( in ) :: atom_names (:) integer , intent ( in ) :: nTimes , nAtoms , iSim , uid_AtomicChargeALL character ( 200 ) :: line ! buffer to read the header real ( kind ( 1 d0 )) :: t , dBuf integer :: uid_AtomicCharge , iPol , it , iAtom , iBuf if (. not . allocated ( Charge )) allocate ( Charge ( 3 , nAtoms , nTimes )) !.. Save Q_Charge open ( newunit = uid_AtomicCharge , & file = FileName , & form = \"formatted\" , & status = \"old\" , & action = \"read\" ) if ( iSim == 1 ) then write ( uid_AtomicChargeALL , '(a)' , advance = \"no\" ) '\"itime\",\"iSim\",' do iAtom = 1 , nAtoms - 1 write ( uid_AtomicChargeALL , \"(a)\" , advance = \"no\" ) \"\" & // '\"Atom_' // trim ( atom_names ( iAtom )) // '_ChargeX\",' & // '\"Atom_' // trim ( atom_names ( iAtom )) // '_ChargeY\",' & // '\"Atom_' // trim ( atom_names ( iAtom )) // '_ChargeZ\",' end do write ( uid_AtomicChargeALL , '(a)' ) '' & // '\"Atom_' // trim ( atom_names ( nAtoms )) // '_ChargeX\",' & // '\"Atom_' // trim ( atom_names ( nAtoms )) // '_ChargeY\",' & // '\"Atom_' // trim ( atom_names ( nAtoms )) // '_ChargeZ\"' end if ! skip the header read ( uid_AtomicCharge , \"(a)\" ) line !..New do it = 1 , nTimes t = tmin + dt * dble ( it - 1 ) read ( uid_AtomicCharge , * ) iBuf , dBuf , dBuf , (( Charge ( iPol , iAtom , it ), iPol = 1 , 3 ), iAtom = 1 , nAtoms ) !            write(uid_AtomicChargeALL, \"(*(x,e24.16,','))\") t, dble(iSim), ((Charge(iPol, iAtom, it), iPol = 1, 3), iAtom = 1, nAtoms) write ( uid_AtomicChargeALL , \"(*(x,e24.16,','))\" , advance = \"no\" ) t , dble ( iSim ) do iAtom = 1 , nAtoms - 1 write ( uid_AtomicChargeALL , \"(*(x,e24.16,','))\" , advance = \"no\" ) & Charge ( 1 , iAtom , it ), & Charge ( 2 , iAtom , it ), & Charge ( 3 , iAtom , it ) end do write ( uid_AtomicChargeALL , \"(*(x,e24.16,','))\" , advance = \"no\" ) & Charge ( 1 , nAtoms , it ), & Charge ( 2 , nAtoms , it ) write ( uid_AtomicChargeALL , \"(E24.16)\" ) & Charge ( 3 , nAtoms , it ) enddo ! write ( uid_AtomicChargeALL , * ) close ( uid_AtomicCharge ) end subroutine Load_Q_Charge_and_Write2ALL subroutine LoadAtomicCharges ( FileName , AtomicChargeEvolution , nTimes , nAtoms , iSim , tmin , dt , uid_AtomicChargeALL ) real ( kind ( 1 d0 )), intent ( in ) :: tmin , dt character ( len = * ), intent ( in ) :: FileName integer , intent ( in ) :: nTimes , iSim , nAtoms , uid_AtomicChargeALL real ( kind ( 1 d0 )), allocatable , intent ( out ) :: AtomicChargeEvolution (:, :) real ( kind ( 1 d0 )) :: dBuf , t integer :: uid_AtomicCharge , it , iAtom allocate ( AtomicChargeEvolution ( nAtoms , nTimes )) open ( newunit = uid_AtomicCharge , & file = FileName , & form = \"formatted\" , & status = \"old\" , & action = \"read\" ) do it = 1 , nTimes t = tmin + dt * dble ( it - 1 ) read ( uid_AtomicCharge , \"(*(x,e24.16))\" ) dBuf , dBuf , ( AtomicChargeEvolution ( iAtom , it ), iAtom = 1 , nAtoms ) write ( uid_AtomicChargeALL , \"(*(x,e24.16))\" ) t , dble ( iSim ), ( AtomicChargeEvolution ( iAtom , it ), iAtom = 1 , nAtoms ) enddo write ( uid_AtomicChargeALL , * ) close ( uid_AtomicCharge ) end subroutine LoadAtomicCharges subroutine WriteDipoleFTFile ( FileName , DipoleFTtotal , OmegaVec , nOmegas ) complex ( kind ( 1 d0 )), intent ( in ) :: DipoleFTtotal (:, :) character ( len = * ), intent ( in ) :: FileName integer , intent ( in ) :: nOmegas real ( kind ( 1 d0 )), allocatable :: OmegaVec (:) real ( kind ( 1 d0 )) :: w integer :: uid_dipoleFT , iOmega , iPol open ( newunit = uid_dipoleFT , & file = FileName , & form = \"formatted\" , & status = \"unknown\" , & action = \"write\" ) ! Header write ( uid_dipoleFT , \"(a)\" , advance = \"no\" ) '\"iOmega\",\"OmegaVec\",' write ( uid_dipoleFT , \"(a)\" ) '' & // '\"FTDipoleX_Re\",\"FTDipoleX_Im\",' & // '\"FTDipoleY_Re\",\"FTDipoleY_Im\",' & // '\"FTDipoleZ_Re\",\"FTDipoleZ_Im\"' do iOmega = 1 , nOmegas w = OmegaVec ( iOmega ) write ( uid_dipoleFT , \"(i4,',',*(x,E24.16,','))\" , advance = \"no\" ) iOmega , w , & dble ( DipoleFTtotal ( 1 , iOmega )), aimag ( DipoleFTtotal ( 1 , iOmega )), & dble ( DipoleFTtotal ( 2 , iOmega )), aimag ( DipoleFTtotal ( 2 , iOmega )) write ( uid_dipoleFT , \"(E24.16,',',E24.16)\" ) & dble ( DipoleFTtotal ( 3 , iOmega )), aimag ( DipoleFTtotal ( 3 , iOmega )) end do close ( uid_dipoleFT ) end subroutine WriteDipoleFTFile subroutine Write_Pulse_Columns ( train , uid ) class ( pulse_train ), intent ( in ) :: train integer :: uid integer :: iPulse !# todo bug review, in CM-FT CD_IO Module this returns an array not a scalar e.g. train%n = 2 2 2 2 2 1 write ( uid , \"(x,i5,',')\" , advance = \"no\" ) train % n do iPulse = 1 , train % n write ( uid , \"(*(x,e14.6,','))\" , advance = \"no\" ) & train % p ( iPulse )% t , & train % p ( iPulse )% o , & train % p ( iPulse )% f , & train % p ( iPulse )% d , & train % p ( iPulse )% i , & train % p ( iPulse )% a , & train % p ( iPulse )% p enddo end subroutine Write_Pulse_Columns subroutine AppendDipole2FTAllFile ( FileName , DipoleFTtotal , OmegaVec , nOmegas , iSim , train ) complex ( kind ( 1 d0 )), intent ( in ) :: DipoleFTtotal (:, :) character ( len = * ), intent ( in ) :: FileName integer , intent ( in ) :: nOmegas , iSim type ( pulse_train ), pointer , intent ( in ) :: train (:) real ( kind ( 1 d0 )) :: OmegaVec (:) real ( kind ( 1 d0 )) :: w integer :: uid_dipoleALLFT , iOmega , iPol , iPulse character ( len = 16 ) :: iPulseStr character ( len = 32 ) :: header character ( len = 32 ) :: trailing_text open ( newunit = uid_dipoleALLFT , & file = FileName , & form = \"formatted\" , & status = \"unknown\" , & action = \"write\" , & position = \"append\" ) ! Header ... only write the first time, meaning if it is the first line if ( iSim == 1 ) then !    Attribute Symbols  |  Description !    ------------------------------------------ !    n                 |  Not directly found in 'pulse', but in 'pulse_train'. Represents the number of pulses. !    t                 |  Central Time (in atomic units) - The time at which the pulse is centered or reaches its peak. !    o                 |  Carrier Frequency (in atomic units) - The frequency of the carrier wave of the pulse. !    f                 |  Full Width at Half Maximum (FWHM) - The width of the pulse at half its maximum amplitude. !    d                 |  Carrier Envelope Phase (in degrees) - Phase difference between the pulse's carrier frequency and its envelope. !    i                 |  Intensity (in PW/cm&#94;2) - Power of the pulse per unit area. !    a                 |  Amplitude (in atomic units) - Maximum amplitude or height of the pulse. !    p                 |  Period (in atomic units) - Time for one complete cycle of the wave. write ( uid_dipoleALLFT , \"(a)\" , advance = \"no\" ) '\"number_of_pulses\",' do iPulse = 1 , train ( iSim )% n iPulseStr = int2strn ( iPulse ) write ( uid_dipoleALLFT , \"(a)\" , advance = \"no\" ) '\"central_time_' // trim ( iPulseStr ) // '\",' write ( uid_dipoleALLFT , \"(a)\" , advance = \"no\" ) '\"carrier_frequency_' // trim ( iPulseStr ) // '\",' write ( uid_dipoleALLFT , \"(a)\" , advance = \"no\" ) '\"fwhm_' // trim ( iPulseStr ) // '\",' write ( uid_dipoleALLFT , \"(a)\" , advance = \"no\" ) '\"carrier_envelope_phase_' // trim ( iPulseStr ) // '\",' write ( uid_dipoleALLFT , \"(a)\" , advance = \"no\" ) '\"intensity_' // trim ( iPulseStr ) // '\",' write ( uid_dipoleALLFT , \"(a)\" , advance = \"no\" ) '\"amplitude_' // trim ( iPulseStr ) // '\",' write ( uid_dipoleALLFT , \"(a)\" , advance = \"no\" ) '\"period_' // trim ( iPulseStr ) // '\",' end do write ( uid_dipoleALLFT , \"(a)\" , advance = \"no\" ) '\"iOmega\",\"OmegaVec\",' write ( uid_dipoleALLFT , '(a)' ) '' & // '\"FTDipoleX_Re\",\"FTDipoleX_Im\",' & // '\"FTDipoleY_Re\",\"FTDipoleY_Im\",' & // '\"FTDipoleZ_Re\",\"FTDipoleZ_Im\"' end if do iOmega = 1 , nOmegas call Write_Pulse_Columns ( train ( iSim ), uid_dipoleALLFT ) w = OmegaVec ( iOmega ) ! write ( uid_dipoleALLFT , \"(i4,',',*(x,E24.16,','))\" , advance = \"no\" ) iOmega , w , & dble ( DipoleFTtotal ( 1 , iOmega )), aimag ( DipoleFTtotal ( 1 , iOmega )), & dble ( DipoleFTtotal ( 2 , iOmega )), aimag ( DipoleFTtotal ( 2 , iOmega )) write ( uid_dipoleALLFT , \"(E24.16,',',E24.16)\" ) & dble ( DipoleFTtotal ( 3 , iOmega )), aimag ( DipoleFTtotal ( 3 , iOmega )) ! end do close ( uid_dipoleALLFT ) end subroutine AppendDipole2FTAllFile subroutine WriteAtomicChargeFT ( FileName , AtomicChargeFT , OmegaVec , nOmegas , nAtoms , AtomName ) complex ( kind ( 1 d0 )), intent ( in ) :: AtomicChargeFT (:, :, :) character ( len = * ), intent ( in ) :: FileName integer , intent ( in ) :: nOmegas , nAtoms character ( len = 16 ), intent ( in ) :: AtomName (:) real ( kind ( 1 d0 )) :: OmegaVec (:) real ( kind ( 1 d0 )) :: w integer :: uid_AtomicChargeFT , iOmega , iAtom open ( newunit = uid_AtomicChargeFT , & file = FileName , & form = \"formatted\" , & status = \"unknown\" , & action = \"write\" ) write ( uid_AtomicChargeFT , \"(a)\" , advance = \"no\" ) '\"iOmega\",\"OmegaVec\",' do iAtom = 1 , nAtoms - 1 write ( uid_AtomicChargeFT , \"(a)\" , advance = \"no\" ) '' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_FTChargeX_Re\",' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_FTChargeX_Im\",' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_FTChargeY_Re\",' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_FTChargeY_Im\",' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_FTChargeZ_Re\",' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_FTChargeZ_Im\",' end do write ( uid_AtomicChargeFT , '(a)' ) '' & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_FTChargeX_Re\",' & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_FTChargeX_Im\",' & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_FTChargeY_Re\",' & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_FTChargeY_Im\",' & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_FTChargeZ_Re\",' & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_FTChargeZ_Im\"' do iOmega = 1 , nOmegas w = OmegaVec ( iOmega ) write ( uid_AtomicChargeFT , \"(i4,',',*(x,E24.16,','))\" , advance = \"no\" ) iOmega , w do iAtom = 1 , nAtoms - 1 write ( uid_AtomicChargeFT , \"(*(x,e24.16,','))\" , advance = \"no\" ) & dble ( AtomicChargeFT ( 1 , iOmega , iAtom )), & aimag ( AtomicChargeFT ( 1 , iOmega , iAtom )), & dble ( AtomicChargeFT ( 2 , iOmega , iAtom )), & aimag ( AtomicChargeFT ( 2 , iOmega , iAtom )), & dble ( AtomicChargeFT ( 3 , iOmega , iAtom )), & aimag ( AtomicChargeFT ( 3 , iOmega , iAtom )) end do write ( uid_AtomicChargeFT , \"(*(x,e24.16,','))\" , advance = \"no\" ) & dble ( AtomicChargeFT ( 1 , iOmega , nAtoms )), & aimag ( AtomicChargeFT ( 1 , iOmega , nAtoms )), & dble ( AtomicChargeFT ( 2 , iOmega , nAtoms )), & aimag ( AtomicChargeFT ( 2 , iOmega , nAtoms )) write ( uid_AtomicChargeFT , \"(E24.16,',',E24.16)\" ) & dble ( AtomicChargeFT ( 3 , iOmega , nAtoms )), & aimag ( AtomicChargeFT ( 3 , iOmega , nAtoms )) ! end do close ( uid_AtomicChargeFT ) end subroutine WriteAtomicChargeFT subroutine WriteAllAtomicChargeFTtoSingleFile ( FileName , AtomicChargeFT_new , OmegaVec , nOmegas , nAtoms , iSim , train , AtomName ) use ModuleErrorHandling complex ( kind ( 1 d0 )) :: AtomicChargeFT_new (:, :, :) character ( len = * ), intent ( in ) :: FileName integer , intent ( in ) :: nOmegas , nAtoms , iSim type ( pulse_train ), pointer , intent ( in ) :: train (:) character ( len = 16 ), intent ( in ) :: AtomName (:) real ( kind ( 1 d0 )) :: OmegaVec (:) real ( kind ( 1 d0 )) :: w integer :: uid_AtomicChargeFT , iOmega , iAtom , iPol , iPulse character ( len = 16 ) :: iPulseStr open ( newunit = uid_AtomicChargeFT , & file = FileName , & form = \"formatted\" , & status = \"unknown\" , & action = \"write\" , & position = \"append\" ) if ( iSim == 1 ) then write ( uid_AtomicChargeFT , \"(a)\" , advance = \"no\" ) '\"number_of_pulses\",' do iPulse = 1 , train ( iSim )% n iPulseStr = int2strn ( iPulse ) write ( uid_AtomicChargeFT , \"(a)\" , advance = \"no\" ) '\"central_time_' // trim ( iPulseStr ) // '\",' write ( uid_AtomicChargeFT , \"(a)\" , advance = \"no\" ) '\"carrier_frequency_' // trim ( iPulseStr ) // '\",' write ( uid_AtomicChargeFT , \"(a)\" , advance = \"no\" ) '\"fwhm_' // trim ( iPulseStr ) // '\",' write ( uid_AtomicChargeFT , \"(a)\" , advance = \"no\" ) '\"carrier_envelope_phase_' // trim ( iPulseStr ) // '\",' write ( uid_AtomicChargeFT , \"(a)\" , advance = \"no\" ) '\"intensity_' // trim ( iPulseStr ) // '\",' write ( uid_AtomicChargeFT , \"(a)\" , advance = \"no\" ) '\"amplitude_' // trim ( iPulseStr ) // '\",' write ( uid_AtomicChargeFT , \"(a)\" , advance = \"no\" ) '\"period_' // trim ( iPulseStr ) // '\",' end do write ( uid_AtomicChargeFT , \"(a)\" , advance = \"no\" ) '\"iOmega\",\"OmegaVec\",' do iAtom = 1 , nAtoms - 1 write ( uid_AtomicChargeFT , \"(a)\" , advance = \"no\" ) '' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_FTChargeX_Re\",' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_FTChargeX_Im\",' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_FTChargeY_Re\",' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_FTChargeY_Im\",' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_FTChargeZ_Re\",' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_FTChargeZ_Im\",' end do write ( uid_AtomicChargeFT , '(a)' ) '' & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_FTChargeX_Re\",' & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_FTChargeX_Im\",' & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_FTChargeY_Re\",' & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_FTChargeY_Im\",' & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_FTChargeZ_Re\",' & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_FTChargeZ_Im\"' end if do iOmega = 1 , nOmegas call Write_Pulse_Columns ( train ( iSim ), uid_AtomicChargeFT ) w = OmegaVec ( iOmega ) write ( uid_AtomicChargeFT , \"(i4,',',*(x,E24.16,','))\" , advance = \"no\" ) iOmega , w do iAtom = 1 , nAtoms - 1 write ( uid_AtomicChargeFT , \"(*(x,e24.16,','))\" , advance = \"no\" ) & dble ( AtomicChargeFT_new ( 1 , iOmega , iAtom )), & aimag ( AtomicChargeFT_new ( 1 , iOmega , iAtom )), & dble ( AtomicChargeFT_new ( 2 , iOmega , iAtom )), & aimag ( AtomicChargeFT_new ( 2 , iOmega , iAtom )), & dble ( AtomicChargeFT_new ( 3 , iOmega , iAtom )), & aimag ( AtomicChargeFT_new ( 3 , iOmega , iAtom )) end do write ( uid_AtomicChargeFT , \"(*(x,e24.16,','))\" , advance = \"no\" ) & dble ( AtomicChargeFT_new ( 1 , iOmega , nAtoms )), & aimag ( AtomicChargeFT_new ( 1 , iOmega , nAtoms )), & dble ( AtomicChargeFT_new ( 2 , iOmega , nAtoms )), & aimag ( AtomicChargeFT_new ( 2 , iOmega , nAtoms )) write ( uid_AtomicChargeFT , \"(E24.16,',',E24.16)\" ) & dble ( AtomicChargeFT_new ( 3 , iOmega , nAtoms )), & aimag ( AtomicChargeFT_new ( 3 , iOmega , nAtoms )) end do close ( uid_AtomicChargeFT ) end subroutine WriteAllAtomicChargeFTtoSingleFile !############################################################################################ !..Bidimentional Spectrum Subroutines subroutine LoadFTDipole_asfuncitonof_TimeDelay ( FileName , N_simulations , nOmegas , DipoleFTwt , tvec ) character ( len = * ), intent ( in ) :: FileName integer , intent ( in ) :: N_simulations , nOmegas complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: DipoleFTwt (:, :, :) real ( kind ( 1 d0 )), allocatable , intent ( out ) :: tvec (:) real ( kind ( 1 d0 )) :: dBuf , drx , dix , dry , diy , drz , diz integer :: iSim , iOmega , uid_dipoleFT , iBuf , i allocate ( DipoleFTwt ( 3 , nOmegas , N_Simulations )) allocate ( tvec ( N_Simulations )) open ( newunit = uid_dipoleFT , & file = FileName , & form = \"formatted\" , & status = \"old\" , & action = \"read\" ) ! Skip the header read ( uid_dipoleFT , * ) do iSim = 1 , N_simulations do iOmega = 1 , nOmegas read ( uid_dipoleFT , * ) iBuf , ( dBuf , i = 1 , 7 ), tvec ( iSim ), ( dBuf , i = 1 , 6 ), iBuf , dBuf , & drx , dix , dry , diy , drz , diz DipoleFTwt ( 1 , iOmega , iSim ) = Z1 * drx + Zi * dix DipoleFTwt ( 2 , iOmega , iSim ) = Z1 * dry + Zi * diy DipoleFTwt ( 3 , iOmega , iSim ) = Z1 * drz + Zi * diz end do enddo close ( uid_dipoleFT ) end subroutine LoadFTDipole_asfuncitonof_TimeDelay subroutine SaveBidimentioal_Dipole_Spectrum ( FileName , DipoleFTww , TauOmegaVec , OmegaVec , nTauOmegas , nOmegas ) character ( len = * ), intent ( in ) :: FileName complex ( kind ( 1 d0 )), intent ( in ) :: DipoleFTww (:, :, :) real ( kind ( 1 d0 )), intent ( in ) :: TauOmegaVec (:), OmegaVec (:) integer , intent ( in ) :: nTauOmegas , nOmegas integer :: iOmegaTau , iOmega , iPol , uid_dipoleFT open ( newunit = uid_dipoleFT , & file = FileName , & form = \"formatted\" , & status = \"unknown\" , & action = \"write\" ) ! Headers write ( uid_dipoleFT , \"(a)\" ) \"OmegaVec,TauOmegaVec,2DDipoleX_Re,2DDipoleX_Im,2DDipoleY_Re,2DDipoleY_Im,2DDipoleZ_Re,2DDipoleZ_Im\" do iOmegaTau = 1 , nTauOmegas do iOmega = 1 , nOmegas write ( uid_dipoleFT , \"(*(x,E24.16,','))\" , advance = \"no\" ) OmegaVec ( iOmega ), TauOmegaVec ( iOmegaTau ), & dble ( DipoleFTww ( 1 , iOmega , iOmegaTau )), aimag ( DipoleFTww ( 1 , iOmega , iOmegaTau )), & dble ( DipoleFTww ( 2 , iOmega , iOmegaTau )), aimag ( DipoleFTww ( 2 , iOmega , iOmegaTau )) write ( uid_dipoleFT , \"(E24.16,',',E24.16)\" ) & dble ( DipoleFTww ( 3 , iOmega , iOmegaTau )), aimag ( DipoleFTww ( 3 , iOmega , iOmegaTau )) end do enddo close ( uid_dipoleFT ) end subroutine SaveBidimentioal_Dipole_Spectrum !.. Load the FT of the charge, as a function of the time delay subroutine LoadFTofChargeasFuncofTimeDelay ( FileName , N_simulations , nOmegas , nAtoms , tvec , ChargeFTwt_new ) character ( len = * ), intent ( in ) :: FileName integer , intent ( in ) :: N_simulations , nOmegas , nAtoms real ( kind ( 1 d0 )), allocatable , intent ( out ) :: tvec (:) complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: ChargeFTwt_new (:, :, :, :) real ( kind ( 1 d0 )), allocatable :: dAtomFTRe (:, :), dAtomFTIm (:, :) integer :: uid_AtomicChargeFT , iSim , iOmega , iBuf , iAtom , i , iPol real ( kind ( 1 d0 )) :: dBuf allocate ( tvec ( N_simulations )) tvec = 0.d0 allocate ( dAtomFTRe ( 3 , nAtoms )) allocate ( dAtomFTIm ( 3 , nAtoms )) open ( newunit = uid_AtomicChargeFT , & file = FileName , & form = \"formatted\" , & status = \"old\" , & action = \"read\" ) allocate ( ChargeFTwt_new ( 3 , nOmegas , N_Simulations , nAtoms )) ! Skip the header read ( uid_AtomicChargeFT , * ) do iSim = 1 , N_simulations do iOmega = 1 , nOmegas read ( uid_AtomicChargeFT , * ) iBuf , ( dBuf , i = 1 , 7 ), tvec ( iSim ), ( dBuf , i = 1 , 6 ), iBuf , dBuf , & ((( dAtomFTRe ( iPol , iAtom ), dAtomFTIm ( iPol , iAtom )), iPol = 1 , 3 ), iAtom = 1 , nAtoms ) do iPol = 1 , 3 do iAtom = 1 , nAtoms ChargeFTwt_new ( iPol , iOmega , iSim , iAtom ) = Z1 * dAtomFTRe ( iPol , iAtom ) + Zi * dAtomFTIm ( iPol , iAtom ) enddo end do enddo end do deallocate ( dAtomFTRe , dAtomFTIm ) close ( uid_AtomicChargeFT ) end subroutine LoadFTofChargeasFuncofTimeDElay !.. Write the Bidimensional spectrum to file subroutine Write_BidimentionalChargeFTww ( FileName , ChargeFTww_new , TauOmegaVec , OmegaVec , nTauOmegas , nOmegas , nAtoms , AtomName ) character ( len = * ), intent ( in ) :: FileName complex ( kind ( 1 d0 )), intent ( in ) :: ChargeFTww_new (:, :, :, :) real ( kind ( 1 d0 )), intent ( in ) :: TauOmegaVec (:), OmegaVec (:) integer , intent ( in ) :: nTauOmegas , nOmegas , nAtoms character ( len = 16 ), intent ( in ) :: AtomName (:) integer :: uid_AtomicChargeFT , iOmegaTau , iOmega , iAtom , iPol open ( newunit = uid_AtomicChargeFT , & file = FileName , & form = \"formatted\" , & status = \"unknown\" , & action = \"write\" ) write ( uid_AtomicChargeFT , \"(a)\" , advance = \"no\" ) \"OmegaVec,TauOmegaVec,\" do iAtom = 1 , nAtoms - 1 write ( uid_AtomicChargeFT , \"(a)\" , advance = \"no\" ) '' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_2DChargeX_Re\",' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_2DChargeX_Im\",' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_2DChargeY_Re\",' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_2DChargeY_Im\",' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_2DChargeZ_Re\",' & // '\"Atom_' // trim ( AtomName ( iAtom )) // '_2DChargeZ_Im\",' end do write ( uid_AtomicChargeFT , \"(a)\" ) \"\" & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_2DChargeX_Re\",' & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_2DChargeX_Im\",' & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_2DChargeY_Re\",' & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_2DChargeY_Im\",' & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_2DChargeZ_Re\",' & // '\"Atom_' // trim ( AtomName ( nAtoms )) // '_2DChargeZ_Im\"' do iOmegaTau = 1 , nTauOmegas do iOmega = 1 , nOmegas write ( uid_AtomicChargeFT , \"(*(x,e24.16,','))\" , advance = \"no\" ) OmegaVec ( iOmega ), TauOmegaVec ( iOmegaTau ) do iAtom = 1 , nAtoms - 1 write ( uid_AtomicChargeFT , \"(*(x,e24.16,','))\" , advance = \"no\" ) & dble ( ChargeFTww_new ( 1 , iOmega , iOmegaTau , iAtom )), & aimag ( ChargeFTww_new ( 1 , iOmega , iOmegaTau , iAtom )), & dble ( ChargeFTww_new ( 2 , iOmega , iOmegaTau , iAtom )), & aimag ( ChargeFTww_new ( 2 , iOmega , iOmegaTau , iAtom )), & dble ( ChargeFTww_new ( 3 , iOmega , iOmegaTau , iAtom )), & aimag ( ChargeFTww_new ( 3 , iOmega , iOmegaTau , iAtom )) end do write ( uid_AtomicChargeFT , \"(*(x,e24.16,','))\" , advance = \"no\" ) & dble ( ChargeFTww_new ( 1 , iOmega , iOmegaTau , nAtoms )), & aimag ( ChargeFTww_new ( 1 , iOmega , iOmegaTau , nAtoms )), & dble ( ChargeFTww_new ( 2 , iOmega , iOmegaTau , nAtoms )), & aimag ( ChargeFTww_new ( 2 , iOmega , iOmegaTau , nAtoms )) write ( uid_AtomicChargeFT , \"(e24.16,',',e24.16)\" ) & dble ( ChargeFTww_new ( 3 , iOmega , iOmegaTau , nAtoms )), & aimag ( ChargeFTww_new ( 3 , iOmega , iOmegaTau , nAtoms )) end do enddo close ( uid_AtomicChargeFT ) end subroutine Write_BidimentionalChargeFTww end Module Module_CMFT_CD_IO","tags":"","loc":"sourcefile/module_cd_io.f90~3.html"}]}
var tipuesearch = {"pages":[{"title":" Charge Migration ","text":"Charge Migration Fortran code for the calculation of the charge migration in molecules. Interfaced with Python's DensityPy library.","tags":"home","loc":"index.html"},{"title":"Set_CD_IO_Verbous – Charge Migration","text":"public  subroutine Set_CD_IO_Verbous(logi) Commons <<! Arguments Type Intent Optional Attributes Name logical, intent(in) :: logi","tags":"","loc":"proc/set_cd_io_verbous.html"},{"title":"Write_Summary – Charge Migration","text":"public  subroutine Write_Summary(FileName, nPts, nAtoms, volume, Computed_volume, n_times, t_min, t_max, atom_names, Radius_BS, number_of_orbitals, OrbTab) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(in) :: nPts integer, intent(in) :: nAtoms real(kind=kind(1d0)), intent(in) :: volume real(kind=kind(1d0)), intent(in) :: Computed_volume integer, intent(in) :: n_times real(kind=kind(1d0)), intent(in) :: t_min real(kind=kind(1d0)), intent(in) :: t_max character(len=16), intent(in) :: atom_names (:) real(kind=kind(1d0)), intent(in) :: Radius_BS (:) integer, intent(in) :: number_of_orbitals real(kind=kind(1d0)), intent(in) :: OrbTab (:,:)","tags":"","loc":"proc/write_summary.html"},{"title":"LoadGeometry – Charge Migration","text":"public  subroutine LoadGeometry(nAtoms, AtCoord, FileName, atom_names) Load Subroutines <<!\n Load the position of the atomic nuclei ** Skip to the line specifying the number of atoms\n determine the number of atoms Arguments Type Intent Optional Attributes Name integer, intent(out) :: nAtoms real(kind=kind(1d0)), intent(out), allocatable :: AtCoord (:,:) character(len=*), intent(in) :: FileName character(len=16), intent(out), allocatable :: atom_names (:)","tags":"","loc":"proc/loadgeometry.html"},{"title":"LoadEnergies – Charge Migration","text":"public  subroutine LoadEnergies(FileName, nStates, Evec) Uses ModuleString ModuleErrorHandling Loads the Energies found inside the input_directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(out) :: nStates real(kind=kind(1d0)), intent(out), allocatable :: Evec (:)","tags":"","loc":"proc/loadenergies.html"},{"title":"LoadGrid – Charge Migration","text":"public  subroutine LoadGrid(FileName, npts, gridv) Uses ModuleString ModuleErrorHandling Loads the Grid found inside the input_directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(out) :: npts real(kind=kind(1d0)), intent(out), allocatable :: gridv (:,:)","tags":"","loc":"proc/loadgrid.html"},{"title":"LoadOrbitals – Charge Migration","text":"public  subroutine LoadOrbitals(Dir, number_of_orbitals, npts, OrbTab) Uses ModuleString ModuleErrorHandling Loads the Orbitals found inside the input_directory\nLoads the Orbitals from the grid_density.csv file inside the input_directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Dir integer, intent(in) :: number_of_orbitals integer, intent(in) :: npts real(kind=kind(1d0)), intent(out), allocatable :: OrbTab (:,:)","tags":"","loc":"proc/loadorbitals.html"},{"title":"LoadDipoleME – Charge Migration","text":"public  subroutine LoadDipoleME(Dmat, input_directory, nStates) Uses ModuleErrorHandling Loads all the Dipoles found inside the input_directory Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(out), allocatable :: Dmat (:,:,:) character(len=*), intent(in) :: input_directory integer, intent(in) :: nStates","tags":"","loc":"proc/loaddipoleme.html"},{"title":"LoadTDMs – Charge Migration","text":"public  subroutine LoadTDMs(FileNameDM, FileNameTDM, nStates, number_of_orbitals, TDM) Uses ModuleString ModuleErrorHandling Loads the TDM found inside the input_directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileNameDM character(len=*), intent(in) :: FileNameTDM integer, intent(in) :: nStates integer, intent(out) :: number_of_orbitals real(kind=kind(1d0)), intent(out), allocatable :: TDM (:,:,:,:)","tags":"","loc":"proc/loadtdms.html"},{"title":"LoadDipoleMO – Charge Migration","text":"public  subroutine LoadDipoleMO(input_directory, number_of_orbitals, ivOrb, MuOrb) Uses ModuleString ModuleErrorHandling Loads Dipole Matrix Elements between molecular orbitals\nIDEALLY, SHOULD COMPUTE THE DIPOLE FROM THE AO - AO DIPOLES. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_directory integer, intent(in) :: number_of_orbitals integer, intent(in) :: ivOrb (:) real(kind=kind(1d0)), intent(out), allocatable :: MuOrb (:,:)","tags":"","loc":"proc/loaddipolemo.html"},{"title":"Write_R_el_bc – Charge Migration","text":"public  subroutine Write_R_el_bc(output_directory, atom_names, nAtoms, R_el) Save Subroutines Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: output_directory character(len=16), intent(in), allocatable :: atom_names (:) integer, intent(in) :: nAtoms real(kind=kind(1d0)), intent(in), allocatable :: R_el (:,:)","tags":"","loc":"proc/write_r_el_bc.html"},{"title":"Write_Dipole – Charge Migration","text":"public  subroutine Write_Dipole(FileName, Dipole, n_times, t_min, dt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(in) :: Dipole (:,:) integer, intent(in) :: n_times real(kind=kind(1d0)), intent(in) :: t_min real(kind=kind(1d0)), intent(in) :: dt","tags":"","loc":"proc/write_dipole.html"},{"title":"Write_Q_Charge – Charge Migration","text":"public  subroutine Write_Q_Charge(FileName, Charge, n_times, t_min, dt, nAtoms, atom_names) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(in) :: Charge (:,:,:) integer, intent(in) :: n_times real(kind=kind(1d0)), intent(in) :: t_min real(kind=kind(1d0)), intent(in) :: dt integer, intent(in) :: nAtoms character(len=16), intent(in) :: atom_names (:)","tags":"","loc":"proc/write_q_charge.html"},{"title":"Write_Charge_Density – Charge Migration","text":"public  subroutine Write_Charge_Density(FileName, nPts, gridv, ChDen, Weightv, nAtoms, atom_names) Uses ModuleString ModuleErrorHandling Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(in) :: nPts real(kind=kind(1d0)), intent(in), allocatable :: gridv (:,:) real(kind=kind(1d0)), intent(in), allocatable :: ChDen (:) real(kind=kind(1d0)), intent(in), allocatable :: Weightv (:,:) integer, intent(in) :: nAtoms character(len=16), intent(in) :: atom_names (:)","tags":"","loc":"proc/write_charge_density.html"},{"title":"Write_Weights – Charge Migration","text":"public  subroutine Write_Weights(FileName, WEIGHTV, gridv, nAtoms, nPts, atom_names) Write Weights Subroutine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(in) :: WEIGHTV (:,:) real(kind=kind(1d0)), intent(in) :: gridv (:,:) integer, intent(in) :: nAtoms integer, intent(in) :: nPts character(len=16), intent(in) :: atom_names (:)","tags":"","loc":"proc/write_weights.html"},{"title":"Read_Weights – Charge Migration","text":"public  subroutine Read_Weights(FileName, WEIGHTV, nAtoms, nPts) Read Weights Subroutine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(out), allocatable :: WEIGHTV (:,:) integer, intent(in) :: nAtoms integer, intent(in) :: nPts","tags":"","loc":"proc/read_weights.html"},{"title":"GetRunTimeParameters – Charge Migration","text":"public  subroutine GetRunTimeParameters(input_directory, output_directory, molecular_geometry_file, n_times, t_min, t_max, FieldFile, Verbous, Weight_File, read_precomputed_weights_flag, save_charge_migration_flag, ivorb, counted_number_of_orbitals, dephasing_factor, relaxation_factor, bath_temperature) Uses ModuleString ModuleErrorHandling ModuleCommandLineParameterList Reads the run time parameters specified in the command line. Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: input_directory character(len=:), intent(out), allocatable :: output_directory character(len=:), intent(out), allocatable :: molecular_geometry_file integer, intent(out) :: n_times real(kind=kind(1d0)), intent(out) :: t_min real(kind=kind(1d0)), intent(out) :: t_max character(len=:), intent(out), allocatable :: FieldFile logical, intent(out) :: Verbous character(len=:), intent(out), allocatable :: Weight_File logical, intent(out) :: read_precomputed_weights_flag logical, intent(out) :: save_charge_migration_flag integer, intent(out), allocatable :: ivorb (:) integer, intent(out) :: counted_number_of_orbitals real(kind=kind(1d0)), intent(out) :: dephasing_factor real(kind=kind(1d0)), intent(out) :: relaxation_factor real(kind=kind(1d0)), intent(out) :: bath_temperature","tags":"","loc":"proc/getruntimeparameters.html"},{"title":"zTraceFunction – Charge Migration","text":"function zTraceFunction(zA) result(zTrace) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: zA (:,:) Return Value complex(kind=kind(1d0))","tags":"","loc":"proc/ztracefunction.html"},{"title":"LiouvillianPropagator – Charge Migration","text":"subroutine LiouvillianPropagator(L0_Eval, L0_LEvec, L0_REvec, zStatRho) The central routine in simulating the dynamics of a quantum system subject to an external field, describing the time evolution of the system in Liouville space.\n Build the time-independent Lindblad superoperator Where: is the time derivative of the density matrix. represents the commutator of the Hamiltonian and the density matrix , which is the standard von Neumann equation describing the unitary evolution of the system, the Liouvillian. (L_{mn}) are the Lindblad (or jump) operators. These represent the different ways the environment can affect the system, leading to decoherence and relaxation. The terms with describe the action of the environment on the system, and thus are responsible for transitions induced by the bath. The terms with and subtract off double-counted terms and ensure the trace of the density matrix remains equal to 1. Behaving as \"decoherence\" processes where the system's off-diagonal elements (coherences) are diminished due to interactions with the environment. For pure dephasing without relaxation: For relaxation without pure dephasing: subject to the constraint where Key steps in the subroutine: Transform the initial density matrix zStatRho into Liouville space. Propagate the transformed matrix in the absence of external fields for a time interval dt/2. Convert the propagated matrix back into Hilbert space. Consider the system's interaction with an external electric field by applying rotations in the Hilbert space. Diagonalize the density matrix to determine the pure states it comprises. Propagate each individual state under the influence of the external field. Re-form the density matrix from the propagated pure states. Repeat steps 1-3 for the re-formed density matrix to complete the propagation process over the time interval dt. Notes: This subroutine heavily relies on various matrix operations and makes use of other subroutines such as HilbertToLiouvilleMatrix, ZGEMV, LiouvilleToHilbertMatrix, DiagonalizeDipole, ZGEMM, Short_ZHEEV, and ExternalElectricFieldCart, which are not defined within this subroutine and are expected to be defined elsewhere. Important to note is that certain variables used within this subroutine, such as dt, t, iSim, train, Z1, Zi, Z0, nStates, and Dmat, are not defined or passed as arguments, implying that they are either global variables or passed from a higher-level routine that calls this function. The FIRST_CALL logical variable is used to execute certain lines of code only during the first invocation of the subroutine, primarily for the allocation and initialization of arrays. This subroutine effectively encapsulates a single iteration or time step of the simulation. For a complete simulation over a given time period, this subroutine would typically be called repeatedly in a loop. Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: L0_Eval (:) a complex array holding the eigenvalues of the Liouville operator. complex(kind=kind(1d0)), intent(in) :: L0_LEvec (:,:) a complex array holding the left eigenvectors of the Liouville operator. complex(kind=kind(1d0)), intent(in) :: L0_REvec (:,:) a complex array holding the right eigenvectors of the Liouville operator. complex(kind=kind(1d0)), intent(inout) :: zStatRho (:,:) a complex array holding the initial state density matrix of the quantum system. The array is updated within the subroutine, and hence is an input/output parameter.","tags":"","loc":"proc/liouvillianpropagator.html"},{"title":"ComputeLiouvillian_0 – Charge Migration","text":"subroutine ComputeLiouvillian_0(Evec, Dmat, Liouvillian0, bath_temperature, dephasing_factor, relaxation_factor) Calculates the time-independent Lindblad superoperator (Liouvillian), a crucial element in the Lindblad master equation, used for describing the time evolution of the density matrix of a quantum system in an open quantum system framework. Key steps in the subroutine:\n* First, the subroutine initializes parameters and allocates space for the Liouvillian.\n* The unitary part of the Liouvillian is computed, based on the system Hamiltonian eigenvalues.\n* The subroutine calculates the pair relaxation rates and the dephasing rates for all pairs of states, taking into account the energy levels, dipole moment matrix, and input parameters related to dephasing and relaxation.\n* The total relaxation rate for each state is computed as the sum of the pair relaxation rates involving the state.\n* Finally, the dissipative part of the Liouvillian, capturing the effects of the interaction of the system with its environment, is computed based on these relaxation rates. Note: Please note that this subroutine computes the Lindblad superoperator for a specific case where the relaxation and dephasing rates are assumed to be constants and the Lindblad operators are assumed to be proportional to the dipole moment operator. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: Evec (:) The array of energy eigenvalues of the system's Hamiltonian. real(kind=kind(1d0)), intent(in) :: Dmat (:,:,:) The dipole moment matrix of the system. complex(kind=kind(1d0)), intent(out), allocatable :: Liouvillian0 (:,:) The computed Liouvillian superoperator. It's an output parameter that's updated in the subroutine. real(kind=kind(1d0)), intent(in) :: bath_temperature The temperature of the bath or environment interacting with the quantum system. real(kind=kind(1d0)), intent(in) :: dephasing_factor The factor representing dephasing effects in the system. real(kind=kind(1d0)), intent(in) :: relaxation_factor The factor representing relaxation effects in the system.","tags":"","loc":"proc/computeliouvillian_0.html"},{"title":"DiagonalizeLindblad_0 – Charge Migration","text":"subroutine DiagonalizeLindblad_0(Liouvillian0, L0_Eval, L0_LEvec, L0_REvec) Performs the diagonalization of the time-independent\nLindblad superoperator (Liouvillian0). The diagonalization is performed using the\nShort_Diag subroutine, and the results are printed to the standard output.\nThis routine also checks that the product of right and conjugate transpose of left eigenvectors\nis an identity matrix (a necessary condition for a valid diagonalization). Note: The input matrix Liouvillian0 is also modified during the execution of this subroutine. Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(inout) :: Liouvillian0 (:,:) A complex square matrix representing the Lindblad superoperator to be diagonalized. complex(kind=kind(1d0)), intent(out), allocatable :: L0_Eval (:) A complex vector that will hold the eigenvalues of Liouvillian0. complex(kind=kind(1d0)), intent(out), allocatable :: L0_LEvec (:,:) A complex square matrix that will hold the left eigenvectors of Liouvillian0. complex(kind=kind(1d0)), intent(out), allocatable :: L0_REvec (:,:) A complex square matrix that will hold the right eigenvectors of Liouvillian0.","tags":"","loc":"proc/diagonalizelindblad_0.html"},{"title":"HilbertToLiouvilleMatrix – Charge Migration","text":"subroutine HilbertToLiouvilleMatrix(RhoMat, RhoVec) Transforms a matrix from Hilbert space into a vector\nin Liouville space. The transformation is performed by looping through each element of the input\nmatrix and mapping it to the corresponding position in the output vector using the subroutine\nHilbertToLiouvilleIndexes. This transformation is required for the application of the Liouville operator. Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: RhoMat (:,:) A complex matrix representing the state in Hilbert space. complex(kind=kind(1d0)), intent(out) :: RhoVec (:) A complex vector representing the transformed state in Liouville space.","tags":"","loc":"proc/hilberttoliouvillematrix.html"},{"title":"LiouvilleToHilbertMatrix – Charge Migration","text":"subroutine LiouvilleToHilbertMatrix(RhoVec, RhoMat) Performs the inverse transformation of\nHilbertToLiouvilleMatrix, transforming a vector in Liouville space back into a matrix in\nHilbert space. The transformation is performed by looping through each element of the output matrix\nand assigning it the corresponding value from the input vector using the subroutine\nHilbertToLiouvilleIndexes. Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: RhoVec (:) A complex vector representing the state in Liouville space. complex(kind=kind(1d0)), intent(out) :: RhoMat (:,:) A complex matrix representing the transformed state in Hilbert space.","tags":"","loc":"proc/liouvilletohilbertmatrix.html"},{"title":"HilbertToLiouvilleIndexes – Charge Migration","text":"subroutine HilbertToLiouvilleIndexes(i, j, iPair) Transforms matrix indices in Hilbert space into a\nsingle index in Liouville space. The transformation is dependent on the relative values of the\ninput indices. The resulting single index is required for the transformation from Hilbert to\nLiouville space. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Integers representing the indices in Hilbert space. integer, intent(in) :: j Integers representing the indices in Hilbert space. integer, intent(out) :: iPair An integer representing the corresponding single index in Liouville space.","tags":"","loc":"proc/hilberttoliouvilleindexes.html"},{"title":"LiouvilleToHilbertIndexes – Charge Migration","text":"subroutine LiouvilleToHilbertIndexes(iPair, i, j) Takes in a single integer index in Liouville space\nand converts it into a pair of matrix indices in Hilbert space. The indices are calculated by\ndecomposing the given Liouville index into a square plus a remainder, which are then used to\ncalculate the corresponding Hilbert indices. Arguments Type Intent Optional Attributes Name integer, intent(in) :: iPair An integer representing a single index in Liouville space. integer, intent(out) :: i Integers representing the corresponding indices in Hilbert space. integer, intent(out) :: j Integers representing the corresponding indices in Hilbert space.","tags":"","loc":"proc/liouvilletohilbertindexes.html"},{"title":"DiagonalizeDipole – Charge Migration","text":"subroutine DiagonalizeDipole(Dmat, EVEC_DX, zUMAT_DX, EVEC_DY, zUMAT_DY, EVEC_DZ, zUMAT_DZ) input and computes the diagonalized matrices and their eigenvalues. Internal Operations: Allocation of matrices, diagonalization using Short_Diag, and assignment of the resultant matrices and eigenvalues. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: Dmat (:,:,:) Real 3D array representing the dipole moment matrix. real(kind=kind(1d0)), intent(out), allocatable :: EVEC_DX (:) Real 1D arrays for the eigenvalues of the dipoles in X, Y, and Z directions. complex(kind=kind(1d0)), intent(out), allocatable :: zUMAT_DX (:,:) Complex 2D arrays for the diagonalized matrices in X, Y, and Z directions, respectively. real(kind=kind(1d0)), intent(out), allocatable :: EVEC_DY (:) Real 1D arrays for the eigenvalues of the dipoles in X, Y, and Z directions. complex(kind=kind(1d0)), intent(out), allocatable :: zUMAT_DY (:,:) Complex 2D arrays for the diagonalized matrices in X, Y, and Z directions, respectively. real(kind=kind(1d0)), intent(out), allocatable :: EVEC_DZ (:) Real 1D arrays for the eigenvalues of the dipoles in X, Y, and Z directions. complex(kind=kind(1d0)), intent(out), allocatable :: zUMAT_DZ (:,:) Complex 2D arrays for the diagonalized matrices in X, Y, and Z directions, respectively.","tags":"","loc":"proc/diagonalizedipole.html"},{"title":"Computevolume – Charge Migration","text":"subroutine Computevolume(nPts, volume, gridv) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPts real(kind=kind(1d0)), intent(out) :: volume real(kind=kind(1d0)), intent(in), allocatable :: gridv (:,:)","tags":"","loc":"proc/computevolume.html"},{"title":"Compute_R_el – Charge Migration","text":"subroutine Compute_R_el(gridv, WeightV, OrbTab, R_el) Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in), allocatable :: gridv (:,:) real(kind=kind(1d0)), intent(in), allocatable :: WeightV (:,:) real(kind=kind(1d0)), intent(in), allocatable :: OrbTab (:,:) real(kind=kind(1d0)), intent(out), allocatable :: R_el (:,:)","tags":"","loc":"proc/compute_r_el.html"},{"title":"AtomicRadius_Bragg_Slater_Becke – Charge Migration","text":"subroutine AtomicRadius_Bragg_Slater_Becke(atom_names, nAtom, Radius_BS) Arguments Type Intent Optional Attributes Name character(len=16), intent(in) :: atom_names (:) integer, intent(in) :: nAtom real(kind=kind(1d0)), intent(out), allocatable :: Radius_BS (:)","tags":"","loc":"proc/atomicradius_bragg_slater_becke.html"},{"title":"ComputeAtomicCharges – Charge Migration","text":"subroutine ComputeAtomicCharges(OrbitalDensity, BeckeMatrix, QchargeVec) Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: OrbitalDensity (:,:) real(kind=kind(1d0)), intent(in) :: BeckeMatrix (:,:,:,:) real(kind=kind(1d0)), intent(out), allocatable :: QchargeVec (:,:)","tags":"","loc":"proc/computeatomiccharges.html"},{"title":"ComputeOrbitalDensity – Charge Migration","text":"subroutine ComputeOrbitalDensity(zStatRho, TDM, Amat) Build the expansion Matrix where is the solution of a suitable Master equation, starting from Here, we will neglect relaxation and decoherence and hence where Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: zStatRho (:,:) real(kind=kind(1d0)), intent(in) :: TDM (:,:,:,:) real(kind=kind(1d0)), intent(out), allocatable :: Amat (:,:)","tags":"","loc":"proc/computeorbitaldensity.html"},{"title":"ComputeAtomicWeights – Charge Migration","text":"subroutine ComputeAtomicWeights(nPts, gridv, nAtoms, AtCoord, WeightV, Radius_BS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPts real(kind=kind(1d0)), intent(in) :: gridv (:,:) integer, intent(in) :: nAtoms real(kind=kind(1d0)), intent(in) :: AtCoord (:,:) real(kind=kind(1d0)), intent(out), allocatable :: WeightV (:,:) real(kind=kind(1d0)), intent(in) :: Radius_BS (:)","tags":"","loc":"proc/computeatomicweights.html"},{"title":"TabulateChargeDensity – Charge Migration","text":"subroutine TabulateChargeDensity(Amat, OrbTab, ChDen) Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: Amat (:,:) real(kind=kind(1d0)), intent(in) :: OrbTab (:,:) real(kind=kind(1d0)), intent(out) :: ChDen (:)","tags":"","loc":"proc/tabulatechargedensity.html"},{"title":"ComputeBeckeMatrix – Charge Migration","text":"subroutine ComputeBeckeMatrix(WeightV, OrbTab, BeckeMatrix, Bary_center) Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: WeightV (:,:) real(kind=kind(1d0)), intent(in) :: OrbTab (:,:) real(kind=kind(1d0)), intent(out), allocatable :: BeckeMatrix (:,:,:,:) real(kind=kind(1d0)), intent(in) :: Bary_center (:,:)","tags":"","loc":"proc/computebeckematrix.html"},{"title":"EuclDist – Charge Migration","text":"public  function EuclDist(avec, bvec) result(res) This function calculates the Euclidean distance between two points in 3D space. The inputs are two 3-component vectors representing the coordinates of the points, and the output is a scalar representing the distance between them. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: avec (3) real(kind=kind(1d0)), intent(in) :: bvec (3) Return Value real(kind=kind(1d0))","tags":"","loc":"proc/eucldist.html"},{"title":"EllipticalCoord – Charge Migration","text":"public  function EllipticalCoord(rvec, avec, bvec) result(res) Eq. 1 This function calculates the elliptical coordinate ( ) of a point relative to two other points (defined as atoms 'a' and 'b'). This coordinate is a measure of how much closer the point is to atom 'a' compared to atom 'b'. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) real(kind=kind(1d0)), intent(in) :: avec (3) real(kind=kind(1d0)), intent(in) :: bvec (3) Return Value real(kind=kind(1d0))","tags":"","loc":"proc/ellipticalcoord.html"},{"title":"Radius_Table – Charge Migration","text":"public  function Radius_Table(Atomic_Name) result(Atomic_Radius) Radius_Table for atomic radius based on atomic name\nThis function provides the atomic radius based on the atomic name. The input is a string representing the atomic name and the output is the corresponding atomic radius. This is useful for defining the size of atoms in molecular modelling. Arguments Type Intent Optional Attributes Name character(len=16), intent(in) :: Atomic_Name Return Value real(kind=kind(1d0))","tags":"","loc":"proc/radius_table.html"},{"title":"get_param_a – Charge Migration","text":"public  function get_param_a(R_i, R_j) result(a_ij) This function calculates the parameter 'a' ( ) which depends on the radii of two atoms. This parameter is used in the transformation of the elliptical coordinate. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: R_i real(kind=kind(1d0)), intent(in) :: R_j Return Value real(kind=kind(1d0))","tags":"","loc":"proc/get_param_a.html"},{"title":"new_mu_transformation – Charge Migration","text":"public  function new_mu_transformation(mu, a_ij) result(res) This function transforms the elliptical coordinate using the parameter 'a' ( ). This transformation is used to handle cases where the point is much closer to one atom than the other. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: mu real(kind=kind(1d0)), intent(in) :: a_ij Return Value real(kind=kind(1d0))","tags":"","loc":"proc/new_mu_transformation.html"},{"title":"fkfun – Charge Migration","text":"public recursive function fkfun(mu, k) result(res) Eq. 4 Recursive This function calculates a recursive function of the transformed elliptical coordinate. The output of this function will be used in the calculation of the step function skfun. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: mu integer, intent(in) :: k Return Value real(kind=kind(1d0))","tags":"","loc":"proc/fkfun.html"},{"title":"skfun – Charge Migration","text":"public  function skfun(mu, k) result(res) (Step Function)\nThis function calculates a step function of the transformed elliptical coordinate. This function maps the transformed elliptical coordinate from the range [-1,1] to [0,1]. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: mu integer, intent(in) :: k Return Value real(kind=kind(1d0))","tags":"","loc":"proc/skfun.html"},{"title":"skfunab – Charge Migration","text":"public  function skfunab(rvec, avec, bvec, k, a_ij) result(res) This function combines the calculations of the transformed elliptical coordinate and the step function. The output of this function will be used in the calculation of the partial partition function Pkfuna. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) real(kind=kind(1d0)), intent(in) :: avec (3) real(kind=kind(1d0)), intent(in) :: bvec (3) integer, intent(in) :: k real(kind=kind(1d0)) :: a_ij Return Value real(kind=kind(1d0))","tags":"","loc":"proc/skfunab.html"},{"title":"Pkfuna – Charge Migration","text":"public  function Pkfuna(rvec, iAtom, AtCoord, nAtoms, k, Radius_BS) result(res) Eq. 2 , nominator of Eq. 3\nThis function calculates the partial partition function for a specific atom. The output of this function represents the contribution of a specific atom to the total partition function. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) integer, intent(in) :: iAtom real(kind=kind(1d0)), intent(in) :: AtCoord (3,nAtoms) integer, intent(in) :: nAtoms integer, intent(in) :: k real(kind=kind(1d0)), intent(in) :: Radius_BS (:) Return Value real(kind=kind(1d0))","tags":"","loc":"proc/pkfuna.html"},{"title":"PkFunTot – Charge Migration","text":"public  function PkFunTot(rvec, AtCoord, nAtoms, k, Radius_BS) result(res) Eq. 3 in the denominator\nThis function calculates the total partition function. This is done by summing the partial partition functions for all atoms. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) real(kind=kind(1d0)), intent(in) :: AtCoord (3,nAtoms) integer, intent(in) :: nAtoms integer, intent(in) :: k real(kind=kind(1d0)), intent(in) :: Radius_BS (:) Return Value real(kind=kind(1d0))","tags":"","loc":"proc/pkfuntot.html"},{"title":"wkfun – Charge Migration","text":"public  function wkfun(rvec, iAtom, AtCoord, nAtoms, k, Radius_BS) result(res) Eq. 3 $w_a \\vec(r)$  (WEIGHTS)\nThis function calculates the weight of an atom. The weight is defined as the ratio of the partial partition function of the atom to the total partition function. This weight represents the relative importance of the atom. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) integer, intent(in) :: iAtom real(kind=kind(1d0)), intent(in) :: AtCoord (3,nAtoms) integer, intent(in) :: nAtoms integer, intent(in) :: k real(kind=kind(1d0)), intent(in) :: Radius_BS (:) Return Value real(kind=kind(1d0))","tags":"","loc":"proc/wkfun.html"},{"title":"Module_CM_CD_IO – Charge Migration","text":"Uses ModuleString iso_fortran_env ModuleErrorHandling Subroutines public  subroutine Set_CD_IO_Verbous (logi) Commons <<! Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: logi public  subroutine Write_Summary (FileName, nPts, nAtoms, volume, Computed_volume, n_times, t_min, t_max, atom_names, Radius_BS, number_of_orbitals, OrbTab) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(in) :: nPts integer, intent(in) :: nAtoms real(kind=kind(1d0)), intent(in) :: volume real(kind=kind(1d0)), intent(in) :: Computed_volume integer, intent(in) :: n_times real(kind=kind(1d0)), intent(in) :: t_min real(kind=kind(1d0)), intent(in) :: t_max character(len=16), intent(in) :: atom_names (:) real(kind=kind(1d0)), intent(in) :: Radius_BS (:) integer, intent(in) :: number_of_orbitals real(kind=kind(1d0)), intent(in) :: OrbTab (:,:) public  subroutine LoadGeometry (nAtoms, AtCoord, FileName, atom_names) Load Subroutines <<!\n Load the position of the atomic nuclei Read more… Arguments Type Intent Optional Attributes Name integer, intent(out) :: nAtoms real(kind=kind(1d0)), intent(out), allocatable :: AtCoord (:,:) character(len=*), intent(in) :: FileName character(len=16), intent(out), allocatable :: atom_names (:) public  subroutine LoadEnergies (FileName, nStates, Evec) Loads the Energies found inside the input_directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(out) :: nStates real(kind=kind(1d0)), intent(out), allocatable :: Evec (:) public  subroutine LoadGrid (FileName, npts, gridv) Loads the Grid found inside the input_directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(out) :: npts real(kind=kind(1d0)), intent(out), allocatable :: gridv (:,:) public  subroutine LoadOrbitals (Dir, number_of_orbitals, npts, OrbTab) Loads the Orbitals found inside the input_directory\nLoads the Orbitals from the grid_density.csv file inside the input_directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: Dir integer, intent(in) :: number_of_orbitals integer, intent(in) :: npts real(kind=kind(1d0)), intent(out), allocatable :: OrbTab (:,:) public  subroutine LoadDipoleME (Dmat, input_directory, nStates) Loads all the Dipoles found inside the input_directory Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(out), allocatable :: Dmat (:,:,:) character(len=*), intent(in) :: input_directory integer, intent(in) :: nStates public  subroutine LoadTDMs (FileNameDM, FileNameTDM, nStates, number_of_orbitals, TDM) Loads the TDM found inside the input_directory Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileNameDM character(len=*), intent(in) :: FileNameTDM integer, intent(in) :: nStates integer, intent(out) :: number_of_orbitals real(kind=kind(1d0)), intent(out), allocatable :: TDM (:,:,:,:) public  subroutine LoadDipoleMO (input_directory, number_of_orbitals, ivOrb, MuOrb) Loads Dipole Matrix Elements between molecular orbitals\nIDEALLY, SHOULD COMPUTE THE DIPOLE FROM THE AO - AO DIPOLES. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: input_directory integer, intent(in) :: number_of_orbitals integer, intent(in) :: ivOrb (:) real(kind=kind(1d0)), intent(out), allocatable :: MuOrb (:,:) public  subroutine Write_R_el_bc (output_directory, atom_names, nAtoms, R_el) Save Subroutines Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: output_directory character(len=16), intent(in), allocatable :: atom_names (:) integer, intent(in) :: nAtoms real(kind=kind(1d0)), intent(in), allocatable :: R_el (:,:) public  subroutine Write_Dipole (FileName, Dipole, n_times, t_min, dt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName complex(kind=kind(1d0)), intent(in) :: Dipole (:,:) integer, intent(in) :: n_times real(kind=kind(1d0)), intent(in) :: t_min real(kind=kind(1d0)), intent(in) :: dt public  subroutine Write_Q_Charge (FileName, Charge, n_times, t_min, dt, nAtoms, atom_names) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(in) :: Charge (:,:,:) integer, intent(in) :: n_times real(kind=kind(1d0)), intent(in) :: t_min real(kind=kind(1d0)), intent(in) :: dt integer, intent(in) :: nAtoms character(len=16), intent(in) :: atom_names (:) public  subroutine Write_Charge_Density (FileName, nPts, gridv, ChDen, Weightv, nAtoms, atom_names) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName integer, intent(in) :: nPts real(kind=kind(1d0)), intent(in), allocatable :: gridv (:,:) real(kind=kind(1d0)), intent(in), allocatable :: ChDen (:) real(kind=kind(1d0)), intent(in), allocatable :: Weightv (:,:) integer, intent(in) :: nAtoms character(len=16), intent(in) :: atom_names (:) public  subroutine Write_Weights (FileName, WEIGHTV, gridv, nAtoms, nPts, atom_names) Write Weights Subroutine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(in) :: WEIGHTV (:,:) real(kind=kind(1d0)), intent(in) :: gridv (:,:) integer, intent(in) :: nAtoms integer, intent(in) :: nPts character(len=16), intent(in) :: atom_names (:) public  subroutine Read_Weights (FileName, WEIGHTV, nAtoms, nPts) Read Weights Subroutine Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: FileName real(kind=kind(1d0)), intent(out), allocatable :: WEIGHTV (:,:) integer, intent(in) :: nAtoms integer, intent(in) :: nPts","tags":"","loc":"module/module_cm_cd_io.html"},{"title":"Module_CM_RTP – Charge Migration","text":"Subroutines public  subroutine GetRunTimeParameters (input_directory, output_directory, molecular_geometry_file, n_times, t_min, t_max, FieldFile, Verbous, Weight_File, read_precomputed_weights_flag, save_charge_migration_flag, ivorb, counted_number_of_orbitals, dephasing_factor, relaxation_factor, bath_temperature) Reads the run time parameters specified in the command line. Arguments Type Intent Optional Attributes Name character(len=:), intent(out), allocatable :: input_directory character(len=:), intent(out), allocatable :: output_directory character(len=:), intent(out), allocatable :: molecular_geometry_file integer, intent(out) :: n_times real(kind=kind(1d0)), intent(out) :: t_min real(kind=kind(1d0)), intent(out) :: t_max character(len=:), intent(out), allocatable :: FieldFile logical, intent(out) :: Verbous character(len=:), intent(out), allocatable :: Weight_File logical, intent(out) :: read_precomputed_weights_flag logical, intent(out) :: save_charge_migration_flag integer, intent(out), allocatable :: ivorb (:) integer, intent(out) :: counted_number_of_orbitals real(kind=kind(1d0)), intent(out) :: dephasing_factor real(kind=kind(1d0)), intent(out) :: relaxation_factor real(kind=kind(1d0)), intent(out) :: bath_temperature","tags":"","loc":"module/module_cm_rtp.html"},{"title":"Module_Becke – Charge Migration","text":"This code is a Fortran implementation of the Becke partitioning scheme based on the following papers: H. Gharibnejad, N. Douguet, B.I. Schneider, J. Olsen, L. Argenti,\n  A multi-center quadrature scheme for the molecular continuum,\n  Computer Physics Communications, Volume 263, 2021, 107889, ISSN 0010-4655,\n  https://doi.org/10.1016/j.cpc.2021.107889. and A. D. Becke; A multicenter numerical integration scheme for polyatomic molecules.\n  J. Chem. Phys. 15 February 1988; 88 (4): 2547–2553. https://doi.org/10.1063/1.454033 Quick Notes: Radius_Table: Given the name of an atom, returns its atomic radius. Only supports H, C, N, O, and Mg. get_param_a: Given two radii R_i and R_j, returns a transformed parameter a_ij. If the absolute value of is greater than 0.5, it's set to 0.5. new_mu_transformation: Returns a new mu parameter, given the original mu and . wkfun: Calculates a weighted function for atom i. PkFunTot: Sums up the function Pkfuna over all atoms. Pkfuna: Calculates a product of skfunab over all atoms excluding atom i. skfunab: Transforms an elliptical coordinate to a new mu, then returns the result of skfun with this new mu. skfun: Transforms a mu parameter into a step function. fkfun: Recursively calculates a function of mu. EllipticalCoord: Given coordinates rvec, avec, and bvec, calculates an elliptical coordinate. EuclDist: Given two points in space, calculates their Euclidean distance. The main considerations:\nThis code does not handle the case where the input atomic name does not match one of the provided options in Radius_Table. This could lead to an error or unexpected behavior.\nThe recursion in fkfun does not seem to have a base case when k is less than 1, which could potentially lead to a stack overflow error.\nThere are no checks for zero or negative distances in EuclDist which might cause issues if not handled properly upstream.\nThe input values are not validated for possible errors. Adding error handling and input validation could make the code more robust.\nThe functions are tightly coupled, which might make modifications and debugging more difficult. Uses iso_fortran_env Functions public  function EuclDist (avec, bvec) result(res) This function calculates the Euclidean distance between two points in 3D space. The inputs are two 3-component vectors representing the coordinates of the points, and the output is a scalar representing the distance between them. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: avec (3) real(kind=kind(1d0)), intent(in) :: bvec (3) Return Value real(kind=kind(1d0)) public  function EllipticalCoord (rvec, avec, bvec) result(res) Eq. 1 This function calculates the elliptical coordinate ( ) of a point relative to two other points (defined as atoms 'a' and 'b'). This coordinate is a measure of how much closer the point is to atom 'a' compared to atom 'b'. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) real(kind=kind(1d0)), intent(in) :: avec (3) real(kind=kind(1d0)), intent(in) :: bvec (3) Return Value real(kind=kind(1d0)) public  function Radius_Table (Atomic_Name) result(Atomic_Radius) Radius_Table for atomic radius based on atomic name\nThis function provides the atomic radius based on the atomic name. The input is a string representing the atomic name and the output is the corresponding atomic radius. This is useful for defining the size of atoms in molecular modelling. Arguments Type Intent Optional Attributes Name character(len=16), intent(in) :: Atomic_Name Return Value real(kind=kind(1d0)) public  function get_param_a (R_i, R_j) result(a_ij) This function calculates the parameter 'a' ( ) which depends on the radii of two atoms. This parameter is used in the transformation of the elliptical coordinate. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: R_i real(kind=kind(1d0)), intent(in) :: R_j Return Value real(kind=kind(1d0)) public  function new_mu_transformation (mu, a_ij) result(res) This function transforms the elliptical coordinate using the parameter 'a' ( ). This transformation is used to handle cases where the point is much closer to one atom than the other. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: mu real(kind=kind(1d0)), intent(in) :: a_ij Return Value real(kind=kind(1d0)) public recursive function fkfun (mu, k) result(res) Eq. 4 Recursive This function calculates a recursive function of the transformed elliptical coordinate. The output of this function will be used in the calculation of the step function skfun. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: mu integer, intent(in) :: k Return Value real(kind=kind(1d0)) public  function skfun (mu, k) result(res) (Step Function)\nThis function calculates a step function of the transformed elliptical coordinate. This function maps the transformed elliptical coordinate from the range [-1,1] to [0,1]. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: mu integer, intent(in) :: k Return Value real(kind=kind(1d0)) public  function skfunab (rvec, avec, bvec, k, a_ij) result(res) This function combines the calculations of the transformed elliptical coordinate and the step function. The output of this function will be used in the calculation of the partial partition function Pkfuna. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) real(kind=kind(1d0)), intent(in) :: avec (3) real(kind=kind(1d0)), intent(in) :: bvec (3) integer, intent(in) :: k real(kind=kind(1d0)) :: a_ij Return Value real(kind=kind(1d0)) public  function Pkfuna (rvec, iAtom, AtCoord, nAtoms, k, Radius_BS) result(res) Eq. 2 , nominator of Eq. 3\nThis function calculates the partial partition function for a specific atom. The output of this function represents the contribution of a specific atom to the total partition function. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) integer, intent(in) :: iAtom real(kind=kind(1d0)), intent(in) :: AtCoord (3,nAtoms) integer, intent(in) :: nAtoms integer, intent(in) :: k real(kind=kind(1d0)), intent(in) :: Radius_BS (:) Return Value real(kind=kind(1d0)) public  function PkFunTot (rvec, AtCoord, nAtoms, k, Radius_BS) result(res) Eq. 3 in the denominator\nThis function calculates the total partition function. This is done by summing the partial partition functions for all atoms. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) real(kind=kind(1d0)), intent(in) :: AtCoord (3,nAtoms) integer, intent(in) :: nAtoms integer, intent(in) :: k real(kind=kind(1d0)), intent(in) :: Radius_BS (:) Return Value real(kind=kind(1d0)) public  function wkfun (rvec, iAtom, AtCoord, nAtoms, k, Radius_BS) result(res) Eq. 3 $w_a \\vec(r)$  (WEIGHTS)\nThis function calculates the weight of an atom. The weight is defined as the ratio of the partial partition function of the atom to the total partition function. This weight represents the relative importance of the atom. Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: rvec (3) integer, intent(in) :: iAtom real(kind=kind(1d0)), intent(in) :: AtCoord (3,nAtoms) integer, intent(in) :: nAtoms integer, intent(in) :: k real(kind=kind(1d0)), intent(in) :: Radius_BS (:) Return Value real(kind=kind(1d0))","tags":"","loc":"module/module_becke.html"},{"title":"ChargeMigration – Charge Migration","text":"Uses Module_CM_CD_IO ModuleErrorHandling omp_lib ModuleString iso_fortran_env ModuleDiagonalize ModulePulses_3D Module_CM_RTP ModuleIO ModuleConstants Module_Becke ModuleSystemUtils Synopsis: Simulates charge migration in molecular systems under external fields, relaxations, and dephasing effects using the Lindblad master equation. Key Subroutines: LiouvillianPropagator: This central routine simulates the dynamics of a quantum system subject to an external field. It updates the state density matrix zStatRho using the eigenvalues L0_Eval and eigenvectors L0_LEvec, L0_REvec of the Liouvillian operator. ComputeLiouvillian_0: Calculates the time-independent Lindblad superoperator (Liouvillian), crucial in describing the time evolution of the density matrix in an open quantum system. It uses system energy eigenvalues Evec, dipole moment matrix Dmat, and parameters like bath_temperature, dephasing_factor, and relaxation_factor. DiagonalizeLindblad_0: Performs diagonalization of the Lindblad superoperator Liouvillian0, determining its eigenvalues L0_Eval and eigenvectors L0_LEvec and L0_REvec. HilbertToLiouvilleMatrix and LiouvilleToHilbertMatrix: These subroutines transform between Hilbert space matrices and Liouville space vectors. They are crucial for applying the Liouville operator in the simulations. ComputeOrbitalDensity: Builds the orbital density matrix Amat from the state density matrix zStatRho and transition density matrices TDM. ComputeAtomicCharges: Calculates new atomic charges QchargeVec from the orbital density OrbitalDensity and Becke matrix BeckeMatrix. TabulateChargeDensity: Generates charge density ChDen from the orbital density matrix Amat and orbital table OrbTab. ComputeBeckeMatrix: Constructs the Becke matrix BeckeMatrix using weights WeightV, orbital table OrbTab, and barycenter coordinates Bary_center. ComputeAtomicWeights: Calculates atomic weights WeightV for a given set of points gridv, atomic coordinates AtCoord, and radii Radius_BS. Variables Type Attributes Name Initial character(len=:), allocatable :: input_directory character(len=:), allocatable :: output_directory character(len=:), allocatable :: molecular_geometry_file integer :: n_times real(kind=kind(1d0)) :: t_min real(kind=kind(1d0)) :: t_max character(len=:), allocatable :: Ext_field_file character(len=:), allocatable :: Weight_File logical :: Verbous logical :: read_precomputed_weights_flag logical :: save_charge_migration_flag integer, allocatable :: ivorb (:) integer :: counted_number_of_orbitals real(kind=kind(1d0)) :: dephasing_factor real(kind=kind(1d0)) :: relaxation_factor real(kind=kind(1d0)) :: bath_temperature integer, parameter :: GS_IDX = 1 integer :: nStates integer :: number_of_orbitals integer :: i real(kind=kind(1d0)), allocatable :: Evec (:) real(kind=kind(1d0)), allocatable :: Dmat (:,:,:) real(kind=kind(1d0)), allocatable :: TDM (:,:,:,:) complex(kind=kind(1d0)), allocatable :: zMuEV (:,:) complex(kind=kind(1d0)), allocatable :: zDmat_t (:,:,:) integer :: npts integer :: nAtoms real(kind=kind(1d0)), allocatable :: gridv (:,:) real(kind=kind(1d0)), allocatable :: AtCoord (:,:) real(kind=kind(1d0)), allocatable :: OrbTab (:,:) complex(kind=kind(1d0)), allocatable :: zStatRho (:,:) real(kind=kind(1d0)) :: t real(kind=kind(1d0)) :: dt real(kind=kind(1d0)), allocatable :: ChDen (:) real(kind=kind(1d0)), allocatable :: WEIGHTV (:,:) real(kind=kind(1d0)), allocatable :: AtomicChargeVec (:,:) real(kind=kind(1d0)), allocatable :: AtomicChargeEvolution (:,:,:) character(len=30) :: istrn character(len=16), allocatable :: atom_names (:) integer :: iPts integer :: it integer :: iPol integer :: iAtom complex(kind=kind(1d0)), allocatable :: Liouvillian0 (:,:) complex(kind=kind(1d0)), allocatable :: L0_LEvec (:,:) complex(kind=kind(1d0)), allocatable :: L0_REvec (:,:) complex(kind=kind(1d0)), allocatable :: L0_Eval (:) integer :: iSim integer :: N_Simulations integer :: uid character(len=64), pointer :: Simulation_Tagv (:) character(len=1000) :: strn type(pulse_train), pointer :: train (:) real(kind=kind(1d0)), allocatable :: BeckeMatrix (:,:,:,:) real(kind=kind(1d0)), allocatable :: OrbitalDensity (:,:) real(kind=kind(1d0)), allocatable :: Radius_BS (:) real(kind=kind(1d0)) :: Computed_volume integer :: iOrb integer :: jOrb real(kind=kind(1d0)), allocatable :: QchargeVec (:,:) real(kind=kind(1d0)), allocatable :: R_el (:,:) Functions function zTraceFunction (zA) result(zTrace) Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: zA (:,:) Return Value complex(kind=kind(1d0)) Subroutines subroutine LiouvillianPropagator (L0_Eval, L0_LEvec, L0_REvec, zStatRho) The central routine in simulating the dynamics of a quantum system subject to an external field, describing the time evolution of the system in Liouville space.\n Build the time-independent Lindblad superoperator Read more… Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: L0_Eval (:) a complex array holding the eigenvalues of the Liouville operator. complex(kind=kind(1d0)), intent(in) :: L0_LEvec (:,:) a complex array holding the left eigenvectors of the Liouville operator. complex(kind=kind(1d0)), intent(in) :: L0_REvec (:,:) a complex array holding the right eigenvectors of the Liouville operator. complex(kind=kind(1d0)), intent(inout) :: zStatRho (:,:) a complex array holding the initial state density matrix of the quantum system. The array is updated within the subroutine, and hence is an input/output parameter. subroutine ComputeLiouvillian_0 (Evec, Dmat, Liouvillian0, bath_temperature, dephasing_factor, relaxation_factor) Calculates the time-independent Lindblad superoperator (Liouvillian), a crucial element in the Lindblad master equation, used for describing the time evolution of the density matrix of a quantum system in an open quantum system framework. Read more… Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: Evec (:) The array of energy eigenvalues of the system's Hamiltonian. real(kind=kind(1d0)), intent(in) :: Dmat (:,:,:) The dipole moment matrix of the system. complex(kind=kind(1d0)), intent(out), allocatable :: Liouvillian0 (:,:) The computed Liouvillian superoperator. It's an output parameter that's updated in the subroutine. real(kind=kind(1d0)), intent(in) :: bath_temperature The temperature of the bath or environment interacting with the quantum system. real(kind=kind(1d0)), intent(in) :: dephasing_factor The factor representing dephasing effects in the system. real(kind=kind(1d0)), intent(in) :: relaxation_factor The factor representing relaxation effects in the system. subroutine DiagonalizeLindblad_0 (Liouvillian0, L0_Eval, L0_LEvec, L0_REvec) Performs the diagonalization of the time-independent\nLindblad superoperator (Liouvillian0). The diagonalization is performed using the\nShort_Diag subroutine, and the results are printed to the standard output.\nThis routine also checks that the product of right and conjugate transpose of left eigenvectors\nis an identity matrix (a necessary condition for a valid diagonalization). Read more… Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(inout) :: Liouvillian0 (:,:) A complex square matrix representing the Lindblad superoperator to be diagonalized. complex(kind=kind(1d0)), intent(out), allocatable :: L0_Eval (:) A complex vector that will hold the eigenvalues of Liouvillian0. complex(kind=kind(1d0)), intent(out), allocatable :: L0_LEvec (:,:) A complex square matrix that will hold the left eigenvectors of Liouvillian0. complex(kind=kind(1d0)), intent(out), allocatable :: L0_REvec (:,:) A complex square matrix that will hold the right eigenvectors of Liouvillian0. subroutine HilbertToLiouvilleMatrix (RhoMat, RhoVec) Transforms a matrix from Hilbert space into a vector\nin Liouville space. The transformation is performed by looping through each element of the input\nmatrix and mapping it to the corresponding position in the output vector using the subroutine\nHilbertToLiouvilleIndexes. This transformation is required for the application of the Liouville operator. Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: RhoMat (:,:) A complex matrix representing the state in Hilbert space. complex(kind=kind(1d0)), intent(out) :: RhoVec (:) A complex vector representing the transformed state in Liouville space. subroutine LiouvilleToHilbertMatrix (RhoVec, RhoMat) Performs the inverse transformation of\nHilbertToLiouvilleMatrix, transforming a vector in Liouville space back into a matrix in\nHilbert space. The transformation is performed by looping through each element of the output matrix\nand assigning it the corresponding value from the input vector using the subroutine\nHilbertToLiouvilleIndexes. Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: RhoVec (:) A complex vector representing the state in Liouville space. complex(kind=kind(1d0)), intent(out) :: RhoMat (:,:) A complex matrix representing the transformed state in Hilbert space. subroutine HilbertToLiouvilleIndexes (i, j, iPair) Transforms matrix indices in Hilbert space into a\nsingle index in Liouville space. The transformation is dependent on the relative values of the\ninput indices. The resulting single index is required for the transformation from Hilbert to\nLiouville space. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Integers representing the indices in Hilbert space. integer, intent(in) :: j Integers representing the indices in Hilbert space. integer, intent(out) :: iPair An integer representing the corresponding single index in Liouville space. subroutine LiouvilleToHilbertIndexes (iPair, i, j) Takes in a single integer index in Liouville space\nand converts it into a pair of matrix indices in Hilbert space. The indices are calculated by\ndecomposing the given Liouville index into a square plus a remainder, which are then used to\ncalculate the corresponding Hilbert indices. Arguments Type Intent Optional Attributes Name integer, intent(in) :: iPair An integer representing a single index in Liouville space. integer, intent(out) :: i Integers representing the corresponding indices in Hilbert space. integer, intent(out) :: j Integers representing the corresponding indices in Hilbert space. subroutine DiagonalizeDipole (Dmat, EVEC_DX, zUMAT_DX, EVEC_DY, zUMAT_DY, EVEC_DZ, zUMAT_DZ) input and computes the diagonalized matrices and their eigenvalues. Read more… Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: Dmat (:,:,:) Real 3D array representing the dipole moment matrix. real(kind=kind(1d0)), intent(out), allocatable :: EVEC_DX (:) Real 1D arrays for the eigenvalues of the dipoles in X, Y, and Z directions. complex(kind=kind(1d0)), intent(out), allocatable :: zUMAT_DX (:,:) Complex 2D arrays for the diagonalized matrices in X, Y, and Z directions, respectively. real(kind=kind(1d0)), intent(out), allocatable :: EVEC_DY (:) Real 1D arrays for the eigenvalues of the dipoles in X, Y, and Z directions. complex(kind=kind(1d0)), intent(out), allocatable :: zUMAT_DY (:,:) Complex 2D arrays for the diagonalized matrices in X, Y, and Z directions, respectively. real(kind=kind(1d0)), intent(out), allocatable :: EVEC_DZ (:) Real 1D arrays for the eigenvalues of the dipoles in X, Y, and Z directions. complex(kind=kind(1d0)), intent(out), allocatable :: zUMAT_DZ (:,:) Complex 2D arrays for the diagonalized matrices in X, Y, and Z directions, respectively. subroutine Computevolume (nPts, volume, gridv) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPts real(kind=kind(1d0)), intent(out) :: volume real(kind=kind(1d0)), intent(in), allocatable :: gridv (:,:) subroutine Compute_R_el (gridv, WeightV, OrbTab, R_el) Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in), allocatable :: gridv (:,:) real(kind=kind(1d0)), intent(in), allocatable :: WeightV (:,:) real(kind=kind(1d0)), intent(in), allocatable :: OrbTab (:,:) real(kind=kind(1d0)), intent(out), allocatable :: R_el (:,:) subroutine AtomicRadius_Bragg_Slater_Becke (atom_names, nAtom, Radius_BS) Arguments Type Intent Optional Attributes Name character(len=16), intent(in) :: atom_names (:) integer, intent(in) :: nAtom real(kind=kind(1d0)), intent(out), allocatable :: Radius_BS (:) subroutine ComputeAtomicCharges (OrbitalDensity, BeckeMatrix, QchargeVec) Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: OrbitalDensity (:,:) real(kind=kind(1d0)), intent(in) :: BeckeMatrix (:,:,:,:) real(kind=kind(1d0)), intent(out), allocatable :: QchargeVec (:,:) subroutine ComputeOrbitalDensity (zStatRho, TDM, Amat) Build the expansion Matrix where is the solution of a suitable Master equation, starting from Here, we will neglect relaxation and decoherence and hence where Arguments Type Intent Optional Attributes Name complex(kind=kind(1d0)), intent(in) :: zStatRho (:,:) real(kind=kind(1d0)), intent(in) :: TDM (:,:,:,:) real(kind=kind(1d0)), intent(out), allocatable :: Amat (:,:) subroutine ComputeAtomicWeights (nPts, gridv, nAtoms, AtCoord, WeightV, Radius_BS) Arguments Type Intent Optional Attributes Name integer, intent(in) :: nPts real(kind=kind(1d0)), intent(in) :: gridv (:,:) integer, intent(in) :: nAtoms real(kind=kind(1d0)), intent(in) :: AtCoord (:,:) real(kind=kind(1d0)), intent(out), allocatable :: WeightV (:,:) real(kind=kind(1d0)), intent(in) :: Radius_BS (:) subroutine TabulateChargeDensity (Amat, OrbTab, ChDen) Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: Amat (:,:) real(kind=kind(1d0)), intent(in) :: OrbTab (:,:) real(kind=kind(1d0)), intent(out) :: ChDen (:) subroutine ComputeBeckeMatrix (WeightV, OrbTab, BeckeMatrix, Bary_center) Arguments Type Intent Optional Attributes Name real(kind=kind(1d0)), intent(in) :: WeightV (:,:) real(kind=kind(1d0)), intent(in) :: OrbTab (:,:) real(kind=kind(1d0)), intent(out), allocatable :: BeckeMatrix (:,:,:,:) real(kind=kind(1d0)), intent(in) :: Bary_center (:,:)","tags":"","loc":"program/chargemigration.html"},{"title":"Module_CD_IO.f90 – Charge Migration","text":"Source Code Module Module_CM_CD_IO use , intrinsic :: ISO_FORTRAN_ENV use ModuleErrorHandling use ModuleString implicit none private logical :: Verbous public :: & Set_CD_IO_Verbous , & LoadGeometry , & LoadEnergies , & LoadGrid , & LoadOrbitals , & LoadDipoleME , & LoadTDMs , & LoadDipoleMO , & Write_R_el_bc , & Write_Dipole , & Write_Q_Charge , & Write_Charge_Density , & Write_Weights , & Read_Weights , & Write_Summary contains !>> Commons <<! subroutine Set_CD_IO_Verbous ( logi ) logical , intent ( in ) :: logi Verbous = logi end subroutine Set_CD_IO_Verbous subroutine replace_char ( strn , ch1 , ch2 ) character ( len = * ), intent ( inout ) :: strn character , intent ( in ) :: ch1 , ch2 integer :: i do i = index ( strn , ch1 ) if ( i <= 0 ) exit strn ( i : i ) = ch2 enddo end subroutine replace_char subroutine Write_Summary ( FileName , nPts , nAtoms , volume , Computed_volume , n_times , t_min , t_max , atom_names , Radius_BS , number_of_orbitals , OrbTab ) integer , intent ( in ) :: nPts , nAtoms , n_times , number_of_orbitals real ( kind ( 1 d0 )), intent ( in ) :: volume , Computed_volume , t_min , t_max , Radius_BS (:), OrbTab (:, :) character ( len = 16 ), intent ( in ) :: atom_names (:) character ( len = * ), intent ( in ) :: FileName real ( kind ( 1 d0 )) :: self_overlap , other_overlap integer :: uid , atom_idx , orbital_idx1 , orbital_idx2 , point_idx , ierr ! Call the new subroutine to write the summary to the screen and the file open ( newunit = uid , file = FileName , form = \"formatted\" , status = \"unknown\" , action = \"write\" , iostat = ierr ) if ( ierr /= 0 ) then call assert ( \"Write_Summary: Failed to open file for writing: \" // FileName , Assertion % LEVEL_SEVERE ) return end if write ( uid , \"(a)\" ) \"SUMMARY\" write ( uid , \"(a,i0)\" ) \"    Number of Points=\" , nPts write ( uid , \"(a,i0)\" ) \"    Number of Atoms=\" , nAtoms write ( uid , \"(a,e14.6,a,e14.6)\" ) \"    volume =\" , volume , \" Computed volume =\" , Computed_volume write ( uid , \"(a,i0,e14.6,e14.6)\" ) \"    n_times, t_min, t_max=\" , n_times , t_min , t_max write ( uid , \"(a)\" ) \"    Bragg-Slater radii for Becke's Weights\" do atom_idx = 1 , nAtoms if ( atom_idx . ne . 1 ) then if ( atom_names ( atom_idx ) == atom_names ( atom_idx - 1 )) cycle end if write ( uid , \"(a,a,a,e14.4)\" ) \"        \" , atom_names ( atom_idx ), \"=\" , Radius_BS ( atom_idx ) !write Bragg-Slater radii end do write ( uid , * ) do orbital_idx1 = 1 , number_of_orbitals self_overlap = calculate_overlap ( OrbTab , nPts , orbital_idx1 , orbital_idx1 ) * Computed_volume other_overlap = 0.d0 do orbital_idx2 = 1 , number_of_orbitals if ( orbital_idx2 == orbital_idx1 ) cycle other_overlap = other_overlap + calculate_overlap ( OrbTab , nPts , orbital_idx1 , orbital_idx2 ) end do other_overlap = other_overlap * volume write ( uid , \"(a,i0,a,e14.6,a,e14.6)\" ) \"    Norm(\" , orbital_idx1 , \") =\" , self_overlap , \"    Overlap other =\" , other_overlap end do close ( uid ) ! Write to screen as well - calculte_overlap is only computed once, returning a value after 1st run write ( * , \"(a)\" ) \"SUMMARY\" write ( * , \"(a,i0)\" ) \"    Number of Points=\" , nPts write ( * , \"(a,i0)\" ) \"    Number of Atoms=\" , nAtoms write ( * , \"(a,e14.6,a,e14.6)\" ) \"    volume =\" , volume , \" Computed volume =\" , Computed_volume write ( * , \"(a,i0,e14.6,e14.6)\" ) \"    n_times, t_min, t_max=\" , n_times , t_min , t_max write ( * , \"(a)\" ) \"    Bragg-Slater radii for Becke's Weights\" do atom_idx = 1 , nAtoms if ( atom_idx . ne . 1 ) then if ( atom_names ( atom_idx ) == atom_names ( atom_idx - 1 )) cycle end if write ( * , \"(a,a,a,e14.4)\" ) \"        \" , atom_names ( atom_idx ), \"=\" , Radius_BS ( atom_idx ) !write Bragg-Slater radii end do write ( * , * ) do orbital_idx1 = 1 , number_of_orbitals self_overlap = calculate_overlap ( OrbTab , nPts , orbital_idx1 , orbital_idx1 ) * Computed_volume other_overlap = 0.d0 do orbital_idx2 = 1 , number_of_orbitals if ( orbital_idx2 == orbital_idx1 ) cycle other_overlap = other_overlap + calculate_overlap ( OrbTab , nPts , orbital_idx1 , orbital_idx2 ) end do other_overlap = other_overlap * volume write ( * , \"(a,i0,a,e14.6,a,e14.6)\" ) \"    Norm(\" , orbital_idx1 , \") =\" , self_overlap , \"    Overlap other =\" , other_overlap end do contains real function calculate_overlap ( OrbTab , nPts , orbital_idx1 , orbital_idx2 ) real ( kind ( 1 d0 )), intent ( in ) :: OrbTab (:, :) ! 3 x npts integer , intent ( in ) :: nPts , orbital_idx1 , orbital_idx2 integer :: point_idx calculate_overlap = 0.d0 do point_idx = 1 , nPts calculate_overlap = calculate_overlap + OrbTab ( point_idx , orbital_idx1 ) * OrbTab ( point_idx , orbital_idx2 ) end do end function calculate_overlap end subroutine Write_Summary !>> Load Subroutines <<! !> Load the position of the atomic nuclei subroutine LoadGeometry ( nAtoms , AtCoord , FileName , atom_names ) ! integer , intent ( out ) :: nAtoms real ( kind ( 1 d0 )), allocatable , intent ( out ) :: AtCoord (:, :) character ( len = * ), intent ( in ) :: FileName ! integer :: iAtom , iCoord , uid character ( len = 16 ), allocatable , intent ( out ) :: atom_names (:) ! write ( * , \"(a)\" ) \"Loading Geometry\" !.. Open file with geometry open ( newunit = uid , file = trim ( FileName ), form = \"formatted\" , status = \"old\" ) !*** Skip to the line specifying the number of atoms ! determine the number of atoms read ( uid , * ) nAtoms ! Skip to the line where the coordinates start to be listed !allocate the matrix of coordinates read ( uid , * ) allocate ( AtCoord ( 3 , nAtoms )) allocate ( atom_names ( nAtoms )) do iAtom = 1 , nAtoms read ( uid , * ) atom_names ( iAtom ), ( AtCoord ( iCoord , iAtom ), iCoord = 1 , 3 ) enddo close ( uid ) write ( * , * ) \"nAtoms\" , nAtoms end subroutine LoadGeometry ! !> Loads the Energies found inside the input_directory subroutine LoadEnergies ( FileName , nStates , Evec ) ! use ModuleErrorHandling use ModuleString ! implicit none ! character ( len = * ), intent ( in ) :: FileName integer , intent ( out ) :: nStates real ( kind ( 1 d0 )), allocatable , intent ( out ) :: Evec (:) integer :: uid , iostat character ( len = 1000 ) :: iomsg real ( kind ( 1 d0 )) :: E integer :: i write ( * , \"(a)\" ) \"Loading Energies\" open (& newunit = uid , & file = FileName , & form = \"formatted\" , & status = \"old\" , & action = \"read\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call errormessage ( trim ( iomsg )) stop endif nStates = 0 do read ( uid , * , iostat = iostat ) E if ( iostat /= 0 ) exit nStates = nStates + 1 enddo rewind ( uid ) allocate ( Evec ( nStates )) write ( * , \"(a)\" ) \" State Energies \" do i = 1 , nStates read ( uid , * ) Evec ( i ) write ( * , * ) i , Evec ( i ) enddo write ( * , * ) close ( uid ) ! end subroutine LoadEnergies ! !> Loads the Grid found inside the input_directory subroutine LoadGrid ( FileName , npts , gridv ) ! use ModuleErrorHandling use ModuleString ! implicit none ! character ( len = * ), intent ( in ) :: FileName integer , intent ( out ) :: npts real ( kind ( 1 d0 )), allocatable , intent ( out ) :: gridv (:, :) integer :: uid , iostat character ( len = 1000 ) :: iomsg real ( kind ( 1 d0 )) :: x , y , z character ( len = 100 ) :: line integer :: i , j write ( * , \"(a)\" ) \"Loading Grid\" open (& newunit = uid , & file = FileName , & form = \"formatted\" , & status = \"old\" , & action = \"read\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call errormessage ( trim ( iomsg )) stop endif ! Skip the header line read ( uid , '(A)' ) line npts = 0 do read ( uid , '(A)' , iostat = iostat ) line if ( iostat /= 0 ) exit read ( line , * , iostat = iostat ) x , y , z if ( iostat /= 0 ) exit npts = npts + 1 enddo rewind ( uid ) ! Skip the header line again read ( uid , '(A)' ) line allocate ( gridv ( 3 , npts )) do i = 1 , npts read ( uid , '(A)' , iostat = iostat ) line read ( line , * ) x , y , z gridv (:, i ) = [ x , y , z ] enddo close ( uid ) end subroutine LoadGrid ! !> Loads the Orbitals found inside the input_directory !> Loads the Orbitals from the grid_density.csv file inside the input_directory subroutine LoadOrbitals ( Dir , number_of_orbitals , npts , OrbTab ) ! use ModuleErrorHandling use ModuleString ! implicit none ! character ( len = * ), intent ( in ) :: Dir integer , intent ( in ) :: number_of_orbitals , npts real ( kind ( 1 d0 )), allocatable , intent ( out ) :: OrbTab (:, :) integer :: uid , iostat , i , iOrb character ( len = 1000 ) :: iomsg character ( len = 1000 ) :: headerLine , dataLine ! write ( * , \"(a)\" ) \"Loading Orbitals\" ! allocate ( OrbTab ( npts , number_of_orbitals )) ! Make sure that OrbTab is filled open (& newunit = uid , & file = Dir // \"/grid_density.csv\" , & form = \"formatted\" , & status = \"old\" , & action = \"read\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call Assert ( trim ( iomsg ), Assertion % LEVEL_SEVERE ) call StopExecution () endif ! Skip the header line read ( uid , '(a)' ) headerLine do i = 1 , npts read ( uid , '(a)' ) dataLine read ( dataLine , * , iostat = iostat ) ( OrbTab ( i , iOrb ), iOrb = 1 , number_of_orbitals ) if ( iostat /= 0 ) then call errormessage ( \"Error reading row \" // ConvertToStrn ( i ) // \" from grid_density.csv.\" ) stop endif enddo close ( uid ) ! Make sure that OrbTab is filled do iOrb = 1 , number_of_orbitals do i = 1 , npts if ( OrbTab ( i , iOrb ) == 0 ) then call errormessage ( \"Error in row \" // ConvertToStrn ( i ) // \" of OrbTab. Not filled properly.\" ) stop endif enddo end do ! end subroutine LoadOrbitals ! !> Loads all the Dipoles found inside the input_directory subroutine LoadDipoleME ( Dmat , input_directory , nStates ) use ModuleErrorHandling implicit none real ( kind ( 1 d0 )), allocatable , intent ( out ) :: Dmat (:, :, :) character ( len = * ), intent ( in ) :: input_directory integer , intent ( in ) :: nStates real ( kind ( 1 d0 )), allocatable :: dBufM (:, :) integer :: i write ( * , \"(a)\" ) \"Loading Dipole Matrices for XYZ components\" if ( nStates <= 0 ) then call ErrorMessage ( \"Invalid nStates in LoadDipoleME\" ) stop endif if ( allocated ( Dmat )) deallocate ( Dmat ) allocate ( Dmat ( nStates , nStates , 3 ), dBufM ( nStates , nStates )) call LoadDipoles ( input_directory // \"/X_DIPOLE.csv\" , nStates , dBufM ) Dmat (:, :, 1 ) = dBufM call LoadDipoles ( input_directory // \"/Y_DIPOLE.csv\" , nStates , dBufM ) Dmat (:, :, 2 ) = dBufM call LoadDipoles ( input_directory // \"/Z_DIPOLE.csv\" , nStates , dBufM ) Dmat (:, :, 3 ) = dBufM end subroutine LoadDipoleME ! !> Loads the Dipoles found inside the input_directory subroutine LoadDipoles ( FileName , nStates , Dmat ) use ModuleErrorHandling use ModuleString implicit none character ( len = * ), intent ( in ) :: FileName integer , intent ( in ) :: nStates real ( kind ( 1 d0 )), intent ( inout ) :: Dmat (:, :) integer :: uid , iostat character ( len = 1000 ) :: iomsg integer :: i , j character ( len = 10 ) :: StateStr character ( len = 20 ) :: iStr open (& newunit = uid , & file = FileName , & form = \"formatted\" , & status = \"old\" , & action = \"read\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call ErrorMessage ( trim ( iomsg )) stop endif write ( * , * ) write ( * , \"(a)\" ) trim ( FileName ) ! Read and ignore header read ( uid , * , iostat = iostat , iomsg = iomsg ) StateStr if ( iostat /= 0 ) then call ErrorMessage ( \"Error reading header: \" // trim ( iomsg )) close ( uid ) return endif do i = 1 , nStates read ( uid , * , iostat = iostat , iomsg = iomsg ) StateStr , ( Dmat ( i , j ), j = 1 , nStates ) if ( iostat /= 0 ) then write ( iStr , '(I20)' ) i call ErrorMessage ( \"Error reading row \" // trim ( iStr ) // \": \" // trim ( iomsg )) close ( uid ) return endif write ( * , \"(*(x,e14.6))\" ) ( Dmat ( i , j ), j = 1 , nStates ) enddo close ( uid ) end subroutine LoadDipoles ! !> Loads the TDM found inside the input_directory !--------------------------------------------------------------------- ! LoadTDMs Subroutine !--------------------------------------------------------------------- ! ! Description: ! This subroutine reads in two files, one containing the density matrix (DM) ! and the other containing off-diagonal elements of the transition density matrix (TDM). ! The DM values are used for the diagonal blocks of the TDM, representing transitions ! from a state to itself. ! ! Linear Algebra Context: ! The density matrix, rho, for a quantum state |psi> is defined as: ! rho = |psi><psi| ! The diagonal elements of rho provide the probability of the system being in ! each of the basis states. ! ! The transition density matrix, D, for an initial state |psi_i> and a final state |psi_f> is: ! D = |psi_f><psi_i| ! When the initial and final states are the same (i.e., |psi_i> = |psi_f>), ! the TDM reduces to the DM. ! ! In this subroutine: ! - Diagonal blocks of TDM (from the file FileNameDM) correspond to the DM !   (i.e., transitions from a state to itself). ! - Off-diagonal blocks of TDM (from the file FileNameTDM) represent transitions !   between different states. ! ! Inputs: ! FileNameDM     - File containing the density matrix (DM) values. ! FileNameTDM    - File containing the off-diagonal elements of the TDM. ! nStates        - Number of quantum states. ! ! Outputs: ! number_of_orbitals - Total number of active orbitals read from the DM file. ! TDM               - 4D array containing the transition density matrix. ! ! Usage: ! call LoadTDMs(FileNameDM, FileNameTDM, nStates, number_of_orbitals, TDM) ! !--------------------------------------------------------------------- subroutine LoadTDMs ( FileNameDM , FileNameTDM , nStates , number_of_orbitals , TDM ) ! The density matrix (DM) is used as the diagonal blocks of the transition density matrix (TDM). This actually !   makes sense when you think about it. The diagonal blocks of the TDM refer to transitions from a state to !   itself. For electronic systems, the transition density matrix's diagonal blocks can be equivalent to the !   ground state density matrix, especially when considering transitions between ground states or reference !   states to excited states. ! During External Perturbations: If the system is under the influence of an external field or perturbation, !   the diagonal elements of the TDM might contain additional terms or corrections that differ from the DM??? ! use ModuleErrorHandling use ModuleString ! implicit none ! character ( len = * ), intent ( in ) :: FileNameDM character ( len = * ), intent ( in ) :: FileNameTDM integer , intent ( in ) :: nStates integer , intent ( out ) :: number_of_orbitals real ( kind ( 1 d0 )), allocatable , intent ( out ) :: TDM (:, :, :, :) integer :: uid , iostat character ( len = 1000 ) :: iomsg character ( len = 10000 ) :: line integer :: i_state , ii_state , ij_state , ii_orb , ij_orb , nlines write ( * , \"(a)\" ) \"Loading Transition Density Matrix\" ! !.. Open the file with the Diagonal part of TDM, i.e., the \"DM\" open (& newunit = uid , & file = FileNameDM , & form = \"formatted\" , & status = \"old\" , & action = \"read\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call errormessage ( trim ( iomsg )) stop endif !.. Determines the number of orbitals nlines = 0 do read ( uid , \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) exit line = adjustl ( trim ( line )) ! This removes leading and trailing spaces if ( len_trim ( line ) == 0 ) cycle nlines = nlines + 1 enddo if ( mod ( nlines , nStates ) /= 0 ) then call ErrorMessage ( \"Inconsistent number of lines in \" // FileNameDM ) endif number_of_orbitals = nlines / nStates write ( * , \"(a, i0)\" ) \"Number of Active Orbitals: \" , number_of_orbitals !.. Allocate the whole TDM array allocate ( TDM ( number_of_orbitals , number_of_orbitals , nStates , nStates )) TDM = 0.d0 !.. Reads the diagonal blocks of TDM rewind ( uid ) i_state = 0 ii_orb = 0 do read ( uid , \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) exit if ( len_trim ( line ) == 0 ) cycle if ( ii_orb == 0 ) then i_state = i_state + 1 ii_orb = 1 else ii_orb = ii_orb + 1 endif call replace_char ( line , \",\" , \" \" ) read ( line , * ) ( TDM ( ii_orb , ij_orb , i_state , i_state ), ij_orb = 1 , number_of_orbitals ) if ( ii_orb == number_of_orbitals ) ii_orb = 0 enddo close ( uid ) ! !.. Open the file with the Off-Diagonal part of TDM, i.e., the \"TDM\" open (& newunit = uid , & file = FileNameTDM , & form = \"formatted\" , & status = \"old\" , & action = \"read\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call errormessage ( trim ( iomsg )) stop endif !.. Reads the diagonal blocks of TDM do ij_state = 2 , nStates do ii_state = 1 , ij_state - 1 do ii_orb = 1 , number_of_orbitals read ( uid , \"(a)\" ) line call replace_char ( line , \",\" , \" \" ) read ( line , * ) ( TDM ( ii_orb , ij_orb , ii_state , ij_state ), ij_orb = 1 , number_of_orbitals ) enddo TDM (:, :, ij_state , ii_state ) = transpose ( TDM (:, :, ii_state , ij_state )) enddo enddo close ( uid ) ! if ( Verbous ) then write ( * , * ) \"number_of_orbitals = \" , number_of_orbitals do ii_state = 1 , nStates do ij_state = 1 , nStates write ( * , * ) \"STATES \" , ii_state , \" \" , ij_state do ii_orb = 1 , number_of_orbitals write ( * , \"(*(x,e14.6))\" ) ( TDM ( ii_orb , ij_orb , ii_state , ij_state ), ij_orb = 1 , number_of_orbitals ) enddo if ( i_state < nStates ) write ( * , * ) enddo enddo endif end subroutine LoadTDMs ! !> Loads Dipole Matrix Elements between molecular orbitals subroutine LoadDipoleMO ( input_directory , number_of_orbitals , ivOrb , MuOrb ) !! IDEALLY, SHOULD COMPUTE THE DIPOLE FROM THE AO - AO DIPOLES. ! use ModuleErrorHandling use ModuleString ! implicit none ! character ( len = * ), intent ( in ) :: input_directory integer , intent ( in ) :: number_of_orbitals integer , intent ( in ) :: ivOrb (:) real ( kind ( 1 d0 )), allocatable , intent ( out ) :: MuOrb (:, :) character ( len = * ), parameter :: FILE_AO_DIPOLE_X = \"AO_MLTPL_X\" character ( len = * ), parameter :: FILE_MO_VECTORS = \"MO_VECTORS\" integer :: uid , iostat character ( len = 1000 ) :: iomsg character ( len = 10000 ) :: line integer :: iAOi , iAOj , iAO , nAO integer :: iMO integer :: ii_orb , ij_orb real ( kind ( 1 d0 )), allocatable :: MuAO (:, :), dBufv (:) real ( kind ( 1 d0 )), allocatable :: MoVec (:, :) !.. Read file dipole between AOs open (& newunit = uid , & file = input_directory // \"/\" // FILE_AO_DIPOLE_X , & form = \"formatted\" , & status = \"old\" , & action = \"read\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call errormessage ( trim ( iomsg )) stop endif !.. Determines the number of AOs nAO = 0 do read ( uid , \"(a)\" , iostat = iostat ) line if ( iostat /= 0 ) exit nAO = nAO + 1 enddo write ( * , * ) \"nAO : \" , nAO !.. Reads the Dipole between AOs allocate ( MuAO ( nAO , nAO )) MuAO = 0.d0 rewind ( uid ) do iAOi = 1 , nAO read ( uid , \"(a)\" , iostat = iostat ) line call replace_char ( line , \",\" , \" \" ) read ( line , * ) ( MuAO ( iAOi , iAOj ), iAOj = 1 , nAO ) enddo close ( uid ) !.. Read file MO coefficients open (& newunit = uid , & file = input_directory // \"/\" // FILE_MO_VECTORS , & form = \"formatted\" , & status = \"old\" , & action = \"read\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call errormessage ( trim ( iomsg )) stop endif read ( uid , * ) allocate ( MOVec ( nAO , nAO )) MOVec = 0.d0 do iMO = 1 , nAO do iAO = 1 , nAO read ( uid , * ) MOVec ( iAO , iMO ) enddo enddo close ( uid ) write ( * , * ) \"MOVec check:\" , sum ( abs ( MOVec )) write ( * , \"(a,*(x,i4))\" ) \"ivOrb:\" , ivOrb allocate ( dBufv ( nAO )) allocate ( MuOrb ( number_of_orbitals , number_of_orbitals )) dBufv = 0.d0 MuOrb = 0.d0 do ij_orb = 1 , number_of_orbitals dBufv = matmul ( MuAO , MOVec (:, ivOrb ( ij_orb ))) do ii_orb = 1 , number_of_orbitals MuOrb ( ii_orb , ij_orb ) = dot_product ( MOVec (:, ivOrb ( ii_orb )), dBufv ) enddo enddo deallocate ( MOVec , dBufv , MuAO ) write ( * , * ) write ( * , * ) \"MO DIPOLE X\" do ii_orb = 1 , number_of_orbitals write ( * , \"(*(x,e14.6))\" ) ( MuOrb ( ii_orb , ij_orb ), ij_orb = 1 , number_of_orbitals ) enddo end subroutine LoadDipoleMO !>> Save Subroutines subroutine Write_R_el_bc ( output_directory , atom_names , nAtoms , R_el ) ! Inputs: character ( len = * ), intent ( in ) :: output_directory ! Directory path to save the file character ( len = 16 ), allocatable , intent ( in ) :: atom_names (:) integer , intent ( in ) :: nAtoms ! Number of atoms real ( kind ( 1 d0 )), allocatable , intent ( in ) :: R_el (:, :) ! Local variables: integer :: uid ! File unit identifier integer :: iAtom , iPol ! Loop counters ! Attempt to open the file for writing open ( newunit = uid , file = output_directory // \"/\" // \"R_el_bc.csv\" , form = \"formatted\" , status = \"unknown\" , action = \"write\" ) ! Write headers with fixed-width format write ( uid , \"(a)\" ) '\"Atom_Index\",\"Atom_Name\",\"X_Position\",\"Y_Position\",\"Z_Position\"' ! Loop over atoms and write their positions to the file do iAtom = 1 , nAtoms write ( uid , \"(i5,',',A20,2(',',f20.14),',',f20.14)\" ) iAtom , trim ( atom_names ( iAtom )), ( R_el ( iPol , iAtom ), iPol = 1 , 3 ) end do ! Close the file after writing close ( uid ) end subroutine Write_R_el_bc subroutine Write_Dipole ( FileName , Dipole , n_times , t_min , dt ) character ( len = * ), intent ( in ) :: FileName complex ( kind ( 1 d0 )), intent ( in ) :: Dipole (:, :) real ( kind ( 1 d0 )), intent ( in ) :: t_min , dt integer , intent ( in ) :: n_times real ( kind ( 1 d0 )) :: t integer :: uid_dipole , iPol , it open ( newunit = uid_dipole , & file = FileName , & form = \"formatted\" , & status = \"unknown\" , & action = \"write\" ) ! Write Headers write ( uid_dipole , '(a)' ) '\"itime\",\"Time\",\"DipoleX_Re\",\"DipoleX_Im\",\"DipoleY_Re\",\"DipoleY_Im\",\"DipoleZ_Re\",\"DipoleZ_Im\"' ! Write Data do it = 1 , n_times t = t_min + dt * dble ( it - 1 ) write ( uid_dipole , \"(i4,6(',',E24.16),',',E24.16)\" ) & it , t , & dble ( Dipole ( 1 , it )), aimag ( Dipole ( 1 , it )), & dble ( Dipole ( 2 , it )), aimag ( Dipole ( 2 , it )), & dble ( Dipole ( 3 , it )), aimag ( Dipole ( 3 , it )) enddo close ( uid_dipole ) end subroutine Write_Dipole subroutine Write_Q_Charge ( FileName , Charge , n_times , t_min , dt , nAtoms , atom_names ) character ( len = * ), intent ( in ) :: FileName real ( kind ( 1 d0 )), intent ( in ) :: Charge (:, :, :) real ( kind ( 1 d0 )), intent ( in ) :: t_min , dt integer , intent ( in ) :: n_times , nAtoms character ( len = 16 ), intent ( in ) :: atom_names (:) CHARACTER ( LEN = 1000 ) :: formatString real ( kind ( 1 d0 )) :: t integer :: uid_AtomicCharge , iPol , it , iAtom open ( newunit = uid_AtomicCharge , & file = FileName , & form = \"formatted\" , & status = \"unknown\" , & action = \"write\" ) ! Start of the header write ( uid_AtomicCharge , '(a)' , advance = \"no\" ) '\"itime\",\"Time\",\"TotalCharge\",' ! Headers for the individual atomic charges do iAtom = 1 , nAtoms - 1 write ( uid_AtomicCharge , \"(a)\" , advance = \"no\" ) \"\" & // '\"Atom_' // trim ( atom_names ( iAtom )) // '_ChargeX\",' & // '\"Atom_' // trim ( atom_names ( iAtom )) // '_ChargeY\",' & // '\"Atom_' // trim ( atom_names ( iAtom )) // '_ChargeZ\",' end do ! Last atomic charge header write ( uid_AtomicCharge , '(a)' ) '' & // '\"Atom_' // trim ( atom_names ( nAtoms )) // '_ChargeX\",' & // '\"Atom_' // trim ( atom_names ( nAtoms )) // '_ChargeY\",' & // '\"Atom_' // trim ( atom_names ( nAtoms )) // '_ChargeZ\"' ! Write Data do it = 1 , n_times t = t_min + dt * dble ( it - 1 ) ! Write initial data: iteration number, time, and the sum of charges at that time step. write ( uid_AtomicCharge , \"(i4,2(',',E24.16))\" , advance = 'no' ) it , t , sum ( Charge (:, :, it )) ! For the first atom in each time step, skip the comma. write ( uid_AtomicCharge , \"(',', E24.16, ',', E24.16, ',', E24.16)\" , advance = \"no\" ) & Charge ( 1 , 1 , it ), Charge ( 2 , 1 , it ), Charge ( 3 , 1 , it ) ! For all other atoms except the iAtom=nAtoms, prefix the charges with a comma do iAtom = 2 , nAtoms - 1 ! For all other atoms, prefix the charges with a comma and do not advance to the next line write ( uid_AtomicCharge , \"(',', E24.16, ',', E24.16, ',', E24.16)\" , advance = \"no\" ) & Charge ( 1 , iAtom , it ), Charge ( 2 , iAtom , it ), Charge ( 3 , iAtom , it ) end do ! For the last atom, suffix the charges with a newline write ( uid_AtomicCharge , \"(',', E24.16, ',', E24.16, ',', E24.16)\" ) & Charge ( 1 , nAtoms , it ), Charge ( 2 , nAtoms , it ), Charge ( 3 , nAtoms , it ) enddo close ( uid_AtomicCharge ) end subroutine Write_Q_Charge subroutine Write_Charge_Density ( FileName , npts , gridv , ChDen , Weightv , nAtoms , atom_names ) use ModuleErrorHandling use ModuleString implicit none character ( len = * ), intent ( in ) :: FileName integer , intent ( in ) :: nPts , nAtoms real ( kind ( 1 d0 )), allocatable , intent ( in ) :: gridv (:, :) real ( kind ( 1 d0 )), allocatable , intent ( in ) :: ChDen (:) real ( kind ( 1 d0 )), allocatable , intent ( in ) :: Weightv (:, :) character ( len = 16 ), intent ( in ) :: atom_names (:) integer :: uid , iostat character ( len = 1000 ) :: iomsg integer :: iPts , iAtom , j open (& newunit = uid , & file = FileName , & form = \"formatted\" , & status = \"unknown\" , & action = \"write\" , & iostat = iostat , & iomsg = iomsg ) if ( iostat /= 0 ) then call errormessage ( trim ( iomsg )) stop endif ! Start of the header write ( uid , \"(a)\" , advance = \"no\" ) '\"x\",\"y\",\"z\",\"ChargeDensity\",' ! Headers for the individual atomic charges do iAtom = 1 , nAtoms - 1 write ( uid , \"(a)\" , advance = \"no\" ) '\"Atom_' // trim ( atom_names ( iAtom )) // '_ChargeDensity\",' end do ! Header for the last atom write ( uid , '(a)' ) '\"Atom_' // trim ( atom_names ( nAtoms )) // '_ChargeDensity\"' ! Write the data do iPts = 1 , nPts ! Writing the first set of values without a comma at the beginning write ( uid , \"(E24.14E3, ',', E24.14E3, ',', E24.14E3, ',', E24.14E3)\" , advance = \"no\" ) ( gridv ( j , iPts ), j = 1 , 3 ), ChDen ( iPts ) ! Writing the next sets of values with a comma at the beginning do iAtom = 1 , nAtoms - 1 write ( uid , \"(',', E24.14E3)\" , advance = \"no\" ) ChDen ( iPts ) * Weightv ( iPts , iAtom ) end do ! For the last value, write without appending another comma write ( uid , \"(',', E24.14E3)\" ) ChDen ( iPts ) * Weightv ( iPts , nAtoms ) enddo close ( uid ) end subroutine Write_Charge_Density !> Write Weights Subroutine subroutine Write_Weights ( FileName , WEIGHTV , gridv , nAtoms , nPts , atom_names ) character ( len = * ), intent ( in ) :: FileName real ( kind ( 1 d0 )), intent ( in ) :: gridv (:, :) integer , intent ( in ) :: nPts , nAtoms real ( kind ( 1 d0 )), intent ( in ) :: WEIGHTV (:, :) character ( len = 16 ), intent ( in ) :: atom_names (:) integer :: uid , iPts , iAtom , i ! write ( * , \"(a)\" ) \"Writing Weights to File\" !..Write Weights to File open ( newunit = uid , file = FileName , form = \"formatted\" , status = \"unknown\" , action = \"write\" ) ! Start of the header write ( uid , \"(a)\" , advance = \"no\" ) '\"x\",\"y\",\"z\",' ! Headers for the individual atomic charges do iAtom = 1 , nAtoms - 1 write ( uid , \"(a)\" , advance = \"no\" ) '\"Atom_' // trim ( atom_names ( iAtom )) // '_ChargeDensity\",' end do ! Header for the last atom write ( uid , '(a)' ) '\"Atom_' // trim ( atom_names ( nAtoms )) // '_ChargeDensity\"' ! Write the data do iPts = 1 , nPts ! Writing the first set of values without a comma at the beginning write ( uid , \"(E24.14E3, ',', E24.14E3, ',', E24.14E3)\" , advance = \"no\" ) ( gridv ( i , iPts ), i = 1 , 3 ) ! Writing the next sets of values with a comma at the beginning do iAtom = 1 , nAtoms - 1 write ( uid , \"(',', E24.14E3)\" , advance = \"no\" ) WEIGHTV ( iPts , iAtom ) end do ! For the last value, write without appending another comma write ( uid , \"(',', E24.14E3)\" ) WEIGHTV ( iPts , nAtoms ) end do close ( uid ) end subroutine Write_Weights !> Read Weights Subroutine subroutine Read_Weights ( FileName , WEIGHTV , nAtoms , nPts ) character ( len = * ), intent ( in ) :: FileName integer , intent ( in ) :: nPts , nAtoms real ( kind ( 1 d0 )), allocatable , intent ( out ) :: WEIGHTV (:, :) real ( kind ( 1 d0 )) :: dBuf ( 3 ) integer :: uid , iPts , iAtom , i character ( len = 100 ) :: headerLine allocate ( WEIGHTV ( nPts , nAtoms )) ! write ( * , \"(a)\" ) \"Reading Weights from File\" ! !..Read Weights from File open ( newunit = uid , file = FileName , form = \"formatted\" , status = \"old\" , action = \"read\" ) ! Skip the header read ( uid , \"(a)\" ) headerLine ! Read the data do iPts = 1 , nPts read ( uid , \"(E24.14E3, ',', E24.14E3, ',', E24.14E3)\" , advance = \"no\" ) ( dBuf ( i ), i = 1 , 3 ) do iAtom = 1 , nAtoms - 1 read ( uid , \"(',', E24.14E3)\" , advance = \"no\" ) WEIGHTV ( iPts , iAtom ) end do read ( uid , \"(',', E24.14E3)\" ) WEIGHTV ( iPts , nAtoms ) end do ! Close the file close ( uid ) end subroutine Read_Weights end Module Module_CM_CD_IO","tags":"","loc":"sourcefile/module_cd_io.f90.html"},{"title":"ModuleRTP.f90 – Charge Migration","text":"Source Code module Module_CM_RTP implicit none private public :: GetRunTimeParameters contains !> Reads the run time parameters specified in the command line. subroutine GetRunTimeParameters ( input_directory , output_directory , molecular_geometry_file , & n_times , t_min , t_max , FieldFile , Verbous , Weight_File , read_precomputed_weights_flag , & save_charge_migration_flag , ivorb , counted_number_of_orbitals , dephasing_factor , relaxation_factor , bath_temperature ) ! use ModuleErrorHandling use ModuleCommandLineParameterList use ModuleString ! implicit none ! character ( len = :), allocatable , intent ( out ) :: input_directory character ( len = :), allocatable , intent ( out ) :: output_directory character ( len = :), allocatable , intent ( out ) :: molecular_geometry_file integer , intent ( out ) :: n_times real ( kind ( 1 d0 )), intent ( out ) :: t_min real ( kind ( 1 d0 )), intent ( out ) :: t_max character ( len = :), allocatable , intent ( out ) :: FieldFile character ( len = :), allocatable , intent ( out ) :: Weight_File logical , intent ( out ) :: read_precomputed_weights_flag logical , intent ( out ) :: Verbous logical , intent ( out ) :: save_charge_migration_flag integer , allocatable , intent ( out ) :: ivorb (:) real ( kind ( 1 d0 )), intent ( out ) :: dephasing_factor real ( kind ( 1 d0 )), intent ( out ) :: relaxation_factor real ( kind ( 1 d0 )), intent ( out ) :: bath_temperature ! character ( len = * ), parameter :: PROGRAM_DESCRIPTION = & \"Computes the Charge Density on a spatial grid from \" // & \"tabulated orbitals, The Density Matrices and Transition Density Matrices\" type ( ClassCommandLineParameterList ) :: List character ( len = 512 ) :: strnBuf CHARACTER ( 10000 ) :: orbital_string integer , intent ( out ) :: counted_number_of_orbitals integer :: pos1 , pos2 , i , number_of_orbitals , ERROR_FLAG call List % SetDescription ( PROGRAM_DESCRIPTION ) call List % Add ( \"--help\" , \"Print Command Usage\" ) call List % Add ( \"-i\" , \"Input  Dir\" , \"CD_inp\" , \"optional\" ) call List % Add ( \"-o\" , \"Output Dir\" , \"CD_out\" , \"optional\" ) call List % Add ( \"-xyz\" , \"Mol Geom File in Inp Dir\" , \"geom.xyz\" , \"optional\" ) call List % Add ( \"-nt\" , \"n times\" , 101 , \"optional\" ) call List % Add ( \"-t_min\" , \"min time\" , 0.d0 , \"optional\" ) call List % Add ( \"-t_max\" , \"max time\" , 20 0.d0 , \"optional\" ) call List % Add ( \"-field\" , \"Field File\" , \"Field\" , \"optional\" ) call List % Add ( \"-w\" , \"Becke's Weights File\" , \"Weights_File\" , \"optional\" ) call List % Add ( \"-v\" , \"verbous\" ) call List % Add ( \"-sden\" , \"Save Charge Density to file (time consuming!)\" ) call List % Add ( \"-iorb\" , \"absolute index active orbitals \" , \"7,8,9,10,11,12,13\" , \"optional\" ) call List % Add ( \"-bath\" , \"BATH TEMPERATURE\" , 32717 5.d-2 , \"optional\" ) call List % Add ( \"-rf\" , \"RELAXATION FACTOR\" , 1.d-3 , \"optional\" ) call List % Add ( \"-df\" , \"DEPHASING FACTOR\" , 1.d-3 , \"optional\" ) call List % Add ( \"-xxx\" , \"workaround\" ) call List % Parse () if ( List % Present ( \"--help\" )) then call List % PrintUsage () stop end if call List % Get ( \"-o\" , strnBuf ) allocate ( output_directory , source = trim ( adjustl ( strnBuf ))) call List % Get ( \"-i\" , strnBuf ) allocate ( input_directory , source = trim ( adjustl ( strnBuf ))) call List % Get ( \"-xyz\" , strnBuf ) allocate ( molecular_geometry_file , source = trim ( adjustl ( strnBuf ))) call List % Get ( \"-nt\" , n_times ) call List % Get ( \"-t_min\" , t_min ) call List % Get ( \"-t_max\" , t_max ) call List % Get ( \"-rf\" , relaxation_factor ) call List % Get ( \"-df\" , dephasing_factor ) call List % Get ( \"-bath\" , bath_temperature ) Verbous = List % Present ( \"-v\" ) save_charge_migration_flag = List % Present ( \"-sden\" ) read_precomputed_weights_flag = List % Present ( \"-w\" ) call List % Get ( \"-w\" , strnBuf ) allocate ( Weight_File , source = trim ( adjustl ( strnBuf ))) call List % Get ( \"-field\" , strnBuf ) allocate ( FieldFile , source = trim ( adjustl ( strnBuf ))) pos1 = 1 number_of_orbitals = 0 call List % Get ( \"-iorb\" , orbital_string ) counted_number_of_orbitals = 1 do pos1 = index ( orbital_string , \",\" ) if ( pos1 <= 0 ) exit counted_number_of_orbitals = counted_number_of_orbitals + 1 orbital_string ( pos1 : pos1 ) = \" \" enddo allocate ( ivorb ( counted_number_of_orbitals )) do i = 1 , counted_number_of_orbitals pos1 = index ( orbital_string , \" \" ) if ( pos1 > 0 ) then read ( orbital_string ( 1 : pos1 - 1 ), * ) ivorb ( i ) orbital_string = orbital_string ( pos1 + 1 :) else read ( orbital_string , * ) ivorb ( i ) endif enddo call List % Free () ! end subroutine GetRunTimeParameters end module Module_CM_RTP","tags":"","loc":"sourcefile/modulertp.f90.html"},{"title":"main.f90 – Charge Migration","text":"Source Code program ChargeMigration !! !! Synopsis: Simulates charge migration in molecular systems under external fields, relaxations, and dephasing effects using the Lindblad master equation. !! !! ------------ !! Key Subroutines: !! ------------ !! * LiouvillianPropagator: This central routine simulates the dynamics of a quantum system subject to an external field. It updates the state density matrix zStatRho using the eigenvalues L0_Eval and eigenvectors L0_LEvec, L0_REvec of the Liouvillian operator. !! !! * ComputeLiouvillian_0: Calculates the time-independent Lindblad superoperator (Liouvillian), crucial in describing the time evolution of the density matrix in an open quantum system. It uses system energy eigenvalues Evec, dipole moment matrix Dmat, and parameters like bath_temperature, dephasing_factor, and relaxation_factor. !! !! * DiagonalizeLindblad_0: Performs diagonalization of the Lindblad superoperator Liouvillian0, determining its eigenvalues L0_Eval and eigenvectors L0_LEvec and L0_REvec. !! !! * HilbertToLiouvilleMatrix and LiouvilleToHilbertMatrix: These subroutines transform between Hilbert space matrices and Liouville space vectors. They are crucial for applying the Liouville operator in the simulations. !! !! * ComputeOrbitalDensity: Builds the orbital density matrix Amat from the state density matrix zStatRho and transition density matrices TDM. !! !! * ComputeAtomicCharges: Calculates new atomic charges QchargeVec from the orbital density OrbitalDensity and Becke matrix BeckeMatrix. !! !! * TabulateChargeDensity: Generates charge density ChDen from the orbital density matrix Amat and orbital table OrbTab. !! !! * ComputeBeckeMatrix: Constructs the Becke matrix BeckeMatrix using weights WeightV, orbital table OrbTab, and barycenter coordinates Bary_center. !! !! * ComputeAtomicWeights: Calculates atomic weights WeightV for a given set of points gridv, atomic coordinates AtCoord, and radii Radius_BS. !! use , intrinsic :: ISO_FORTRAN_ENV use ModuleErrorHandling use ModuleSystemUtils use ModuleString use ModuleIO use ModuleConstants use ModuleDiagonalize use ModulePulses_3D ! !.. Local modules use Module_CM_RTP use Module_CM_CD_IO use Module_Becke use omp_lib implicit none external zgemm , zgemv , system !Explicit declaration of the EXTERNAL attribute is required. !.. Run-time parameters !.. character ( len = :), allocatable :: input_directory character ( len = :), allocatable :: output_directory character ( len = :), allocatable :: molecular_geometry_file integer :: n_times real ( kind ( 1 d0 )) :: t_min real ( kind ( 1 d0 )) :: t_max character ( len = :), allocatable :: Ext_field_file character ( len = :), allocatable :: Weight_File logical :: Verbous logical :: read_precomputed_weights_flag logical :: save_charge_migration_flag integer , allocatable :: ivorb (:) integer :: counted_number_of_orbitals real ( kind ( 1 d0 )) :: dephasing_factor real ( kind ( 1 d0 )) :: relaxation_factor real ( kind ( 1 d0 )) :: bath_temperature integer , parameter :: GS_IDX = 1 !.. Local parameters integer :: nStates , number_of_orbitals , i real ( kind ( 1 d0 )), allocatable :: Evec (:) !.. Dmat(i,j,alpha) = $ \\langle \\varphi_i | \\hat{\\mu}_\\alpha$ | \\varphi_j \\rangle $ real ( kind ( 1 d0 )), allocatable :: Dmat (:, :, :) !.. TDM(j,i,B,A) = $ \\langle A | \\hat{a}_i&#94;\\dagger \\hat{a}_j | B \\rangle $ real ( kind ( 1 d0 )), allocatable :: TDM (:, :, :, :) !.. Expectation Value of the Dipole Moment (Mu) complex ( kind ( 1 d0 )), allocatable :: zMuEV (:, :), zDmat_t (:, :, :) integer :: npts , nAtoms real ( kind ( 1 d0 )), allocatable :: gridv (:, :), AtCoord (:, :) ! 3 x npts real ( kind ( 1 d0 )), allocatable :: OrbTab (:, :) ! 3 x npts !.. Statistical Density Matrix complex ( kind ( 1 d0 )), allocatable :: zStatRho (:, :) real ( kind ( 1 d0 )) :: t , dt real ( kind ( 1 d0 )), allocatable :: ChDen (:), WEIGHTV (:, :) real ( kind ( 1 d0 )), allocatable :: AtomicChargeVec (:, :), AtomicChargeEvolution (:, :, :) character ( len = 30 ) :: istrn character ( len = 16 ), allocatable :: atom_names (:) integer :: iPts , it , iPol , iAtom complex ( kind ( 1 d0 )), allocatable :: Liouvillian0 (:, :), L0_LEvec (:, :), L0_REvec (:, :), L0_Eval (:) !.. Pulse parameters integer :: iSim , N_Simulations , uid character ( len = 64 ), pointer :: Simulation_Tagv (:) character ( len = 1000 ) :: strn type ( pulse_train ), pointer :: train (:) !.. !  B_{ij}&#94;{\\alpha} = \\int d&#94;3r \\phi_i(\\vec{r})\\phi_j(\\vec{r}) w_\\alpha(\\vec{r}) = BeckeMatrix(i,j,alpha) real ( kind ( 1 d0 )), allocatable :: BeckeMatrix (:, :, :, :) real ( kind ( 1 d0 )), allocatable :: OrbitalDensity (:, :) real ( kind ( 1 d0 )), allocatable :: Radius_BS (:) complex ( kind ( 1 d0 )), external :: zdotu !..Test real ( kind ( 1 d0 )) :: Computed_volume integer :: iOrb , jOrb real ( kind ( 1 d0 )), allocatable :: QchargeVec (:, :), R_el (:, :) call GetRunTimeParameters ( input_directory , output_directory , molecular_geometry_file , & n_times , t_min , t_max , Ext_field_file , Verbous , Weight_File , read_precomputed_weights_flag , & save_charge_migration_flag , ivorb , counted_number_of_orbitals , dephasing_factor , relaxation_factor , bath_temperature ) call system ( \"mkdir -p \" // trim ( output_directory )) call system ( \"mkdir -p \" // output_directory // \"/Dipole\" ) call system ( \"mkdir -p \" // output_directory // \"/AtomicCharge\" ) call system ( \"mkdir -p \" // output_directory // \"/ChargeDensity\" ) call system ( \"mkdir -p \" // output_directory // \"/Pulses\" ) call Set_CD_IO_Verbous ( Verbous ) open ( newunit = uid , & file = Ext_field_file , & form = \"formatted\" , & status = \"old\" ) call Parse_Simulation_File ( uid , OUTPUT_UNIT , N_Simulations , Simulation_Tagv , train ) close ( uid ) write ( * , * ) \"N_Simulations=\" , N_Simulations !.. Write and Print the pulse !.. dt = ( t_max - t_min ) / dble ( n_times ) write ( * , * ) \"fortran t_min=\" , t_min write ( * , * ) \"fortran t_min=\" , t_min write ( * , * ) \"fortran t_max=\" , t_max write ( * , * ) \"fortran n_times=\" , n_times write ( * , * ) \"fortran dble(n_times - 1)=\" , dble ( n_times ) write ( * , * ) \"fortran dt=\" , dt call omp_set_num_threads ( 30 ) ! fixme do not hard code, use number of passed or allowed threads !$OMP PARALLEL DO PRIVATE(strn, i) do i = 1 , N_Simulations write ( * , * ) \"Writing pulse \" // trim ( Simulation_Tagv ( i )) strn = trim ( output_directory ) // \"/Pulses/pulse\" // trim ( Simulation_Tagv ( i )) call train ( i )% Write ( strn , t_min , t_max , dt ) !pulse_trainWrite strn = trim ( output_directory ) // \"/Pulses/FTpulse\" // trim ( Simulation_Tagv ( i )) call train ( i )% WriteFTA ( strn ) !pulse_trainWriteFTA end do !$OMP END PARALLEL DO ! call LoadEnergies ( input_directory // \"/ROOT_ENERGIES\" , nStates , Evec ) !.. At the moment, we assume that the TDM are defined as !   $\\rho&#94;{JI}_{nm} = \\langle J | a_n&#94;\\dagger a_m | I \\rangle $ call LoadTDMs ( input_directory // \"/DENSITY_MATRIX\" , input_directory // \"/TRANSITION_DENSITY_MATRIX\" , nStates , number_of_orbitals , TDM ) !.. Load Dipole matrix elements $\\mu_{IJ}$ call LoadDipoleME ( Dmat , input_directory , nStates ) allocate ( zDmat_t ( nStates , nStates , 3 )) do i = 1 , 3 zDmat_t (:, :, i ) = Z1 * transpose ( Dmat (:, :, i )) enddo if ( number_of_orbitals . ne . counted_number_of_orbitals ) then ! TODO change to assert method of ASTRA write ( * , * ) \"Number of orbitals given by '-iOrb' do not match number of orbitals in active the active space\" stop endif !.. Load Geometry,volume, Grid and Orbitals call LoadGeometry ( nAtoms , AtCoord , molecular_geometry_file , atom_names ) call LoadGrid ( input_directory // \"/gridcoord.csv\" , npts , gridv ) ! $G=\\{\\vec{r}_i, i=1,\\ldots,N_{G}\\}$ call Computevolume ( nPts , Computed_volume , gridv ) ! Should probably check that this computed volume is the same as the one given in the input file !.. Load Orbitals call LoadOrbitals ( input_directory , number_of_orbitals , npts , OrbTab ) ! $\\varphi_n(\\vec{r}_i)$ !.. Compute and Write | or Read Becke's Weights ! call AtomicRadius_Bragg_Slater_Becke ( atom_names , nAtoms , Radius_BS ) if ( read_precomputed_weights_flag == . True .) then call Read_Weights ( Weight_File , WEIGHTV , nAtoms , nPts ) else call ComputeAtomicWeights ( nPts , gridv , nAtoms , AtCoord , WeightV , Radius_BS ) call Write_Weights ( output_directory // \"/\" // Weight_File // \"_\" // output_directory // \".csv\" , & WEIGHTV , gridv , nAtoms , nPts , atom_names ) endif !.. Compute Berycenter of Atmoic Charges call Compute_R_el ( gridv , WeightV , OrbTab , R_el ) call Write_R_el_bc ( output_directory , atom_names , nAtoms , R_el ) !.. Compute Becke's Matrix call ComputeBeckeMatrix ( WeightV , OrbTab , BeckeMatrix , AtCoord ) !using electronic barycenter or AtCoord for the nuclear barycenter write ( * , * ) \"allocating Atomic Charge matrixes\" allocate ( AtomicChargeEvolution ( 3 , nAtoms , n_times )) !.. Compute Liouvillian and Diagonalizes it write ( * , * ) \"Computing Liouvillian\" call ComputeLiouvillian_0 ( Evec , Dmat , Liouvillian0 , bath_temperature , dephasing_factor , relaxation_factor ) call DiagonalizeLindblad_0 ( Liouvillian0 , L0_Eval , L0_LEvec , L0_REvec ) allocate ( zStatRho ( nStates , nStates )) allocate ( ChDen ( nPts )) allocate ( zMuEV ( 3 , n_times )) zMuEV = Z0 write ( * , * ) \"Starting Sim Loop\" Sim_loop : do iSim = 1 , N_Simulations ! Lets keep a percentage write of the simulation only 2 digits after the decimal point write ( * , '(A, F0.2, A, I0, A)' ) \"Simulation progress: \" , 10 0.d0 * iSim / ( N_Simulations ) if ( save_charge_migration_flag ) then write ( * , * ) \"Computing Charge Migration for simulation \" , iSim , trim ( Simulation_tagv ( iSim )) end if !.. Load Initial State zStatRho = Z0 zStatRho ( GS_IDX , GS_IDX ) = 1.d0 !.. Time cycle time_loop : do it = 1 , n_times ! t = t_min + dt * dble ( it - 1 ) !.. Computes the excitation density wrt ground state zStatRho ( GS_IDX , GS_IDX ) = zStatRho ( GS_IDX , GS_IDX ) - 1.d0 !.. Evaluates the expectation value of the dipole as a function of time !            write(*, *) it, iSim, 100.d0 * iSim / (N_Simulations) do iPol = 1 , 3 zMuEV ( iPol , it ) = zdotu ( nStates * nStates , zStatRho , 1 , zDmat_t ( 1 , 1 , iPol ), 1 ) enddo ! call ComputeOrbitalDensity ( zStatRho , TDM , OrbitalDensity ) ! call ComputeAtomicCharges ( OrbitalDensity , BeckeMatrix , AtomicChargeVec ) AtomicChargeVec = AtomicChargeVec * Computed_volume AtomicChargeEvolution (:, :, it ) = AtomicChargeVec !$> this needs to be be moved outside of this module or loop since is costly and can be computed when needed if ( save_charge_migration_flag ) then call TabulateChargeDensity ( OrbitalDensity , OrbTab , ChDen ) write ( istrn , \"(f12.4)\" ) t !..Makes new directory inside of ChargeDensity directory for each simulation call system ( \"mkdir -p \" // output_directory // \"/ChargeDensity/ChDenSim\" // trim ( Simulation_tagv ( iSim ))) call Write_Charge_Density (& output_directory // \"/ChargeDensity/ChDenSim\" // trim ( Simulation_tagv ( iSim )) & // \"/ChDen\" // trim ( adjustl ( istrn )) // \".csv\" , & nPts , gridv , ChDen , Weightv , nAtoms , atom_names ) endif ! zStatRho ( GS_IDX , GS_IDX ) = zStatRho ( GS_IDX , GS_IDX ) + 1.d0 ! if ( it == n_times ) exit time_loop ! call LiouvillianPropagator ( L0_Eval , L0_LEvec , L0_REvec , zStatRho ) ! enddo time_loop !.. Save Dipole to filerc call Write_Dipole ( output_directory // \"/Dipole/Dipole\" // trim ( Simulation_tagv ( iSim )) // \".csv\" , zMuEV , n_times , t_min , dt ) !.. Save Q_Charge call Write_Q_Charge ( output_directory // \"/AtomicCharge/AtomicCharge\" // trim ( Simulation_tagv ( iSim )) // \".csv\" , & AtomicChargeEvolution , n_times , t_min , dt , nAtoms , atom_names ) end do Sim_loop ! call Write_Summary ( output_directory // \"/Simulation_Summary\" , nPts , nAtoms , volume , Computed_volume , n_times , t_min , t_max , atom_names , Radius_BS , number_of_orbitals , OrbTab ) stop contains ! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ! Lindblad Equation - LiouvillianPropagator: ! ---------------------------------------------------- subroutine LiouvillianPropagator ( L0_Eval , L0_LEvec , L0_REvec , zStatRho ) !! The central routine in simulating the dynamics of a quantum system subject to an external field, describing the time evolution of the system in Liouville space. !! Build the time-independent Lindblad superoperator !! \\begin{equation} !!\\dot{\\rho}(t) = -i[H, \\rho(t)] + \\sum_{mn} \\Bigl( L_{mn} \\rho(t) L_{mn}&#94;\\dagger - \\frac{1}{2} L_{mn}&#94;\\dagger L_{mn} \\rho(t) - \\frac{1}{2} \\rho(t) L_{mn}&#94;\\dagger L_{mn} \\Bigr) !!\\end{equation} !! !!Where: !! !! *  \\dot{\\rho}(t)  is the time derivative of the density matrix. !! *  [H, \\rho(t)]  represents the commutator of the Hamiltonian H and the density matrix \\rho(t), which is the standard von Neumann equation describing the unitary evolution of the system, the Liouvillian. !! * (L_{mn} are the Lindblad (or jump) operators. These represent the different ways the environment can affect the system, leading to decoherence and relaxation. !! * The terms with L_{mn} \\rho(t) L_{mn}&#94;\\dagger describe the action of the environment on the system, and thus are responsible for transitions induced by the bath. !! * The terms with L_{mn}&#94;\\dagger L_{mn} \\rho(t) and \\rho(t) L_{mn}&#94;\\dagger L_{mn} subtract off double-counted terms and ensure the trace of the density matrix remains equal to 1. Behaving as \"decoherence\" processes where the system's off-diagonal elements (coherences) are diminished due to interactions with the environment. !! *  H = H_0 + (\\hat{\\epsilon}\\cdot\\vec{\\mu}) E(t) !! !! For pure dephasing without relaxation: !!   L_{nm} = \\delta_{mn} \\sqrt{\\gamma_m/2} | m \\rangle \\langle m | !! !! For relaxation without pure dephasing: !!   L_{mn} = (1-\\delta_{nm}) \\sqrt{\\gamma_{mn}} |m\\rangle \\langle n| !!   subject to the constraint \\gamma_{mn} = e&#94;{-\\beta \\omega_{mn}} \\gamma_{nm} !!   where \\beta = 1/(k_B T) !! !! Key steps in the subroutine: !! !!   * Transform the initial density matrix zStatRho into Liouville space. !!   * Propagate the transformed matrix in the absence of external fields for a time interval dt/2. !!   * Convert the propagated matrix back into Hilbert space. !!   * Consider the system's interaction with an external electric field by applying rotations in the Hilbert space. !!   * Diagonalize the density matrix to determine the pure states it comprises. !!   * Propagate each individual state under the influence of the external field. !!   * Re-form the density matrix from the propagated pure states. !!   * Repeat steps 1-3 for the re-formed density matrix to complete the propagation process over the time interval dt. !! !! Notes: !! !!   * This subroutine heavily relies on various matrix operations and makes use of other subroutines such as HilbertToLiouvilleMatrix, ZGEMV, LiouvilleToHilbertMatrix, DiagonalizeDipole, ZGEMM, Short_ZHEEV, and ExternalElectricFieldCart, which are not defined within this subroutine and are expected to be defined elsewhere. !!   * Important to note is that certain variables used within this subroutine, such as dt, t, iSim, train, Z1, Zi, Z0, nStates, and Dmat, are not defined or passed as arguments, implying that they are either global variables or passed from a higher-level routine that calls this function. !!   * The FIRST_CALL logical variable is used to execute certain lines of code only during the first invocation of the subroutine, primarily for the allocation and initialization of arrays. !!   * This subroutine effectively encapsulates a single iteration or time step of the simulation. For a complete simulation over a given time period, this subroutine would typically be called repeatedly in a loop. ! complex ( kind ( 1 d0 )), intent ( in ) :: L0_LEvec (:, :) !! a complex array holding the left eigenvectors of the Liouville operator. complex ( kind ( 1 d0 )), intent ( in ) :: L0_REvec (:, :) !! a complex array holding the right eigenvectors of the Liouville operator. complex ( kind ( 1 d0 )), intent ( in ) :: L0_Eval (:) !! a complex array holding the eigenvalues of the Liouville operator. complex ( kind ( 1 d0 )), intent ( inout ) :: zStatRho (:, :) !! a complex array holding the initial state density matrix of the quantum system. The array is updated within the subroutine, and hence is an input/output parameter. logical , save :: FIRST_CALL = . TRUE . integer :: nLiou !! the size of the L0_Eval array, which represents the dimension of the Liouville space. integer :: i_state , j real ( kind ( 1 d0 )) :: EFieldX , EFieldY , EFieldZ !!real numbers representing the components of the external electric field at time t + dt/2. complex ( kind ( 1 d0 )), allocatable , save :: zmat1 (:, :), zmat2 (:, :) complex ( kind ( 1 d0 )), allocatable , save :: zPureMat (:, :) real ( kind ( 1 d0 )), allocatable , save :: Epure (:) complex ( kind ( 1 d0 )), allocatable , save :: zUMAT_DX (:, :), zUMAT_DY (:, :), zUMAT_DZ (:, :) complex ( kind ( 1 d0 )), allocatable , save :: zUMAT_DYs_DX (:, :), zUMAT_DZs_DY (:, :) complex ( kind ( 1 d0 )), allocatable , save :: RhoVec2 (:), RhoVec (:) real ( kind ( 1 d0 )), allocatable , save :: EVEC_DX (:), EVEC_DY (:), EVEC_DZ (:) nLiou = size ( L0_Eval , 1 ) if ( FIRST_CALL ) then allocate ( RhoVec ( nLiou )) allocate ( RhoVec2 ( nLiou )) RhoVec = Z0 RhoVec2 = Z0 endif call HilbertToLiouvilleMatrix ( zStatRho , RhoVec ) !.. First half of the field-free propagation in Liouville Space across an interval dt/2 call ZGEMV ( \"C\" , nLiou , nLiou , Z1 , L0_LEvec , nLiou , RhoVec , 1 , Z0 , RhoVec2 , 1 ) RhoVec2 = RhoVec2 * exp ( - Zi * L0_Eval * dt / 2.d0 ) call ZGEMV ( \"N\" , nLiou , nLiou , Z1 , L0_REvec , nLiou , RhoVec2 , 1 , Z0 , RhoVec , 1 ) call LiouvilleToHilbertMatrix ( RhoVec , zStatRho ) nStates = size ( zStatRho , 1 ) if ( FIRST_CALL ) then allocate ( zmat1 ( nStates , nStates ), zmat2 ( nStates , nStates ), Epure ( nStates ), zPureMat ( nStates , nStates )) zmat1 = 0.d0 zmat2 = 0.d0 Epure = 0.d0 zPureMat = 0.d0 !.. Diagonalizes the dipole matrices call DiagonalizeDipole ( Dmat , & EVEC_DX , zUMAT_DX , & EVEC_DY , zUMAT_DY , & EVEC_DZ , zUMAT_DZ ) ! !.. Computes combined matrices allocate ( zUMAT_DYs_DX ( nStates , nStates )) zUMAT_DYs_DX = Z0 call ZGEMM ( \"C\" , \"N\" , nStates , nStates , nStates , Z1 , zUMAT_DY , nStates , & zUMAT_DX , nStates , Z0 , zUMAT_DYs_DX , nStates ) allocate ( zUMAT_DZs_DY ( nStates , nStates )) zUMAT_DZs_DY = Z0 call ZGEMM ( \"C\" , \"N\" , nStates , nStates , nStates , Z1 , zUMAT_DZ , nStates , & zUMAT_DY , nStates , Z0 , zUMAT_DZs_DY , nStates ) FIRST_CALL = . FALSE . endif !.. Diagonalizes the density matrix to determine the pure states it is composed of zPureMat = zStatRho call Short_ZHEEV ( nStates , zPureMat , EPure ) ! !.. Propagates the individual states in the presence of the field EFieldX = ExternalElectricFieldCart ( t + dt / 2.d0 , train ( iSim ), 1 ) EFieldY = ExternalElectricFieldCart ( t + dt / 2.d0 , train ( iSim ), 2 ) EFieldZ = ExternalElectricFieldCart ( t + dt / 2.d0 , train ( iSim ), 3 ) zmat1 = Z0 zmat2 = Z0 call ZGEMM ( \"C\" , \"N\" , nStates , nStates , nStates , Z1 , zUMAT_DX , nStates , zPureMat , nStates , Z0 , zmat1 , nStates ) do i = 1 , nStates zmat1 ( i , :) = exp ( - Zi * EfieldX * EVEC_DX ( i ) * dt / 2.d0 ) * zmat1 ( i , :) enddo call ZGEMM ( \"N\" , \"N\" , nStates , nStates , nStates , Z1 , zUMAT_DYs_DX , nStates , zmat1 , nStates , Z0 , zmat2 , nStates ) do i = 1 , nStates zmat2 ( i , :) = exp ( - Zi * EfieldY * EVEC_DY ( i ) * dt / 2.d0 ) * zmat2 ( i , :) enddo call ZGEMM ( \"N\" , \"N\" , nStates , nStates , nStates , Z1 , zUMAT_DZs_DY , nStates , zmat2 , nStates , Z0 , zmat1 , nStates ) do i = 1 , nStates zmat1 ( i , :) = exp ( - Zi * EfieldZ * EVEC_DZ ( i ) * dt ) * zmat1 ( i , :) enddo call ZGEMM ( \"C\" , \"N\" , nStates , nStates , nStates , Z1 , zUMAT_DZs_DY , nStates , zmat1 , nStates , Z0 , zmat2 , nStates ) do i = 1 , nStates zmat2 ( i , :) = exp ( - Zi * EfieldY * EVEC_DY ( i ) * dt / 2.d0 ) * zmat2 ( i , :) enddo call ZGEMM ( \"C\" , \"N\" , nStates , nStates , nStates , Z1 , zUMAT_DYs_DX , nStates , zmat2 , nStates , Z0 , zmat1 , nStates ) do i = 1 , nStates zmat1 ( i , :) = exp ( - Zi * EfieldX * EVEC_DX ( i ) * dt / 2.d0 ) * zmat1 ( i , :) enddo call ZGEMM ( \"N\" , \"N\" , nStates , nStates , nStates , Z1 , zUMAT_DX , nStates , zmat1 , nStates , Z0 , zPureMat , nStates ) !LiouvillianPropagator !.. Form the density matrix again zStatRho = Z0 do i_state = 1 , nStates do j = 1 , nStates zStatRho (:, j ) = zStatRho (:, j ) + EPure ( i_state ) * zPureMat (:, i_state ) * conjg ( zPureMat ( j , i_state )) enddo enddo call HilbertToLiouvilleMatrix ( zStatRho , RhoVec ) !.. Second half of the field-free propagation in Liouville Space across an interval dt/2 call ZGEMV ( \"C\" , nLiou , nLiou , Z1 , L0_LEvec , nLiou , RhoVec , 1 , Z0 , RhoVec2 , 1 ) RhoVec2 = RhoVec2 * exp ( - Zi * L0_Eval * dt / 2.d0 ) call ZGEMV ( \"N\" , nLiou , nLiou , Z1 , L0_REvec , nLiou , RhoVec2 , 1 , Z0 , RhoVec , 1 ) call LiouvilleToHilbertMatrix ( RhoVec , zStatRho ) end subroutine LiouvillianPropagator ! subroutine ComputeLiouvillian_0 ( Evec , Dmat , Liouvillian0 , bath_temperature , dephasing_factor , relaxation_factor ) !! Calculates the time-independent Lindblad superoperator (Liouvillian), a crucial element in the Lindblad master equation, used for describing the time evolution of the density matrix of a quantum system in an open quantum system framework. !! !! Key steps in the subroutine: !! * First, the subroutine initializes parameters and allocates space for the Liouvillian. !! * The unitary part of the Liouvillian is computed, based on the system Hamiltonian eigenvalues. !! * The subroutine calculates the pair relaxation rates and the dephasing rates for all pairs of states, taking into account the energy levels, dipole moment matrix, and input parameters related to dephasing and relaxation. !! * The total relaxation rate for each state is computed as the sum of the pair relaxation rates involving the state. !! * Finally, the dissipative part of the Liouvillian, capturing the effects of the interaction of the system with its environment, is computed based on these relaxation rates. !! !! Note: Please note that this subroutine computes the Lindblad superoperator for a specific case where the relaxation and dephasing rates are assumed to be constants and the Lindblad operators are assumed to be proportional to the dipole moment operator. real ( kind ( 1 d0 )), intent ( in ) :: Evec (:) !! The array of energy eigenvalues of the system's Hamiltonian. real ( kind ( 1 d0 )), intent ( in ) :: Dmat (:, :, :) !! The dipole moment matrix of the system. complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: Liouvillian0 (:, :) !! The computed Liouvillian superoperator. It's an output parameter that's updated in the subroutine. real ( kind ( 1 d0 )), intent ( in ) :: dephasing_factor !! The factor representing dephasing effects in the system. real ( kind ( 1 d0 )), intent ( in ) :: relaxation_factor !! The factor representing relaxation effects in the system. real ( kind ( 1 d0 )), intent ( in ) :: bath_temperature !! The temperature of the bath or environment interacting with the quantum system. integer :: nLiou , nStates , i , j , iLiou , i1 , i2 , iLiou1 , iLiou2 !.. Dephasing and Relaxation Constants real ( kind ( 1 d0 )), allocatable :: PairGamma (:, :), TotalGamma (:) !! The arrays containing the pair relaxation rates and the total relaxation rates, respectively. real ( kind ( 1 d0 )) :: AverageDipole , dBuf real ( kind ( 1 d0 )) :: BETA !! The inverse temperature factor (1/kT) with k being the Boltzmann constant and T being the temperature. BETA = 1.d0 / ( BOLTZMANN_CONSTANT_auK * bath_temperature ) nStates = size ( Evec , 1 ) nLiou = nStates ** 2 allocate ( Liouvillian0 ( nLiou , nLiou )) Liouvillian0 = Z0 ! !.. Unitary component do iLiou = 1 , nLiou call LiouvilleToHilbertIndexes ( iLiou , i , j ) Liouvillian0 ( iLiou , iLiou ) = Evec ( i ) - Evec ( j ) end do ! !.. Determine the factors \\gamma_{mn} allocate ( PairGamma ( nStates , nStates )) PairGamma = 0.d0 do i = 1 , nStates ! dBuf = 0.d0 do j = 1 , nStates if ( j == i ) cycle ! AverageDipole = sqrt ( sum ( Dmat ( i , j , :) ** 2 ) / 3.d0 ) dBuf = dBuf + AverageDipole ! !.. Relaxation Factor PairGamma ( i , j ) = relaxation_factor * AverageDipole if ( Evec ( i ) > Evec ( j )) PairGamma ( i , j ) = PairGamma ( i , j ) * exp ( - BETA * ( Evec ( i ) - Evec ( j ))) ! enddo ! !.. Dephasing Factor PairGamma ( i , i ) = dephasing_factor * sqrt ( dBuf ) ! enddo ! !.. Determines \\Gamma_i = \\sum_m \\gamma_{mi} allocate ( TotalGamma ( nStates )) do i = 1 , nStates TotalGamma ( i ) = sum ( PairGamma (:, i )) enddo ! !.. Dissipative component do iLiou = 1 , nLiou call LiouvilleToHilbertIndexes ( iLiou , i , j ) Liouvillian0 ( iLiou , iLiou ) = Liouvillian0 ( iLiou , iLiou ) - Zi * ( TotalGamma ( i ) + TotalGamma ( j )) / 2.d0 enddo do i1 = 1 , nStates call HilbertToLiouvilleIndexes ( i1 , i1 , iLiou1 ) do i2 = 1 , nStates call HilbertToLiouvilleIndexes ( i2 , i2 , iLiou2 ) Liouvillian0 ( iLiou1 , iLiou2 ) = Liouvillian0 ( iLiou1 , iLiou2 ) + Zi * PairGamma ( i1 , i2 ) enddo enddo end subroutine ComputeLiouvillian_0 ! subroutine DiagonalizeLindblad_0 ( Liouvillian0 , L0_Eval , L0_LEvec , L0_REvec ) !! Performs the diagonalization of the time-independent !! Lindblad superoperator (Liouvillian0). The diagonalization is performed using the !! Short_Diag subroutine, and the results are printed to the standard output. !! This routine also checks that the product of right and conjugate transpose of left eigenvectors !! is an identity matrix (a necessary condition for a valid diagonalization). !! !! Note: The input matrix Liouvillian0 is also modified during the execution of this subroutine. complex ( kind ( 1 d0 )), intent ( inout ) :: Liouvillian0 (:, :) !! A complex square matrix representing the Lindblad superoperator to be diagonalized. complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: L0_LEvec (:, :) !! A complex square matrix that will hold the left eigenvectors of Liouvillian0. complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: L0_REvec (:, :) !! A complex square matrix that will hold the right eigenvectors of Liouvillian0. complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: L0_Eval (:) !! A complex vector that will hold the eigenvalues of Liouvillian0. complex ( kind ( 1 d0 )), allocatable :: zmat (:, :) integer :: nLiou , iLiou , n , i , j nLiou = size ( Liouvillian0 , 1 ) allocate ( L0_LEvec ( nLiou , nLiou )) allocate ( L0_REvec ( nLiou , nLiou )) allocate ( L0_Eval ( nLiou )) L0_LEvec = Z0 L0_REvec = Z0 L0_Eval = Z0 call Short_Diag ( nLiou , Liouvillian0 , L0_Eval , L0_LEvec , L0_REvec ) do iLiou = 1 , nLiou write ( * , * ) iLiou , L0_Eval ( iLiou ) enddo !.. Test that U_R U_L&#94;\\dagger is indeed the identity n = nLiou allocate ( zmat ( n , n )) zmat = Z0 call ZGEMM ( \"N\" , \"T\" , n , n , n , Z1 , L0_REvec , n , L0_LEvec , n , Z0 , zmat , n ) do i = 1 , n zmat ( i , i ) = zmat ( i , i ) - Z1 enddo write ( * , * ) \"|U_R U_L&#94;+ -1|_1 = \" , sum ( abs ( zmat )) end subroutine DiagonalizeLindblad_0 ! !<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ! Hilbert and Liouville space transformations subroutines ! ---------------------------------------------------- subroutine HilbertToLiouvilleMatrix ( RhoMat , RhoVec ) !! Transforms a matrix from Hilbert space into a vector !! in Liouville space. The transformation is performed by looping through each element of the input !! matrix and mapping it to the corresponding position in the output vector using the subroutine !! HilbertToLiouvilleIndexes. This transformation is required for the application of the Liouville operator. !! complex ( kind ( 1 d0 )), intent ( in ) :: RhoMat (:, :) !! A complex matrix representing the state in Hilbert space. complex ( kind ( 1 d0 )), intent ( out ) :: RhoVec (:) !! A complex vector representing the transformed state in Liouville space. integer :: i , j , n , iPair n = size ( RhoMat , 1 ) do i = 1 , n do j = 1 , n call HilbertToLiouvilleIndexes ( i , j , iPair ) RhoVec ( iPair ) = RhoMat ( i , j ) enddo enddo end subroutine HilbertToLiouvilleMatrix ! subroutine LiouvilleToHilbertMatrix ( RhoVec , RhoMat ) !! Performs the inverse transformation of !! HilbertToLiouvilleMatrix, transforming a vector in Liouville space back into a matrix in !! Hilbert space. The transformation is performed by looping through each element of the output matrix !! and assigning it the corresponding value from the input vector using the subroutine !! HilbertToLiouvilleIndexes. !! complex ( kind ( 1 d0 )), intent ( in ) :: RhoVec (:) !! A complex vector representing the state in Liouville space. complex ( kind ( 1 d0 )), intent ( out ) :: RhoMat (:, :) !! A complex matrix representing the transformed state in Hilbert space. integer :: i , j , n , iPair n = size ( RhoMat , 1 ) RhoMat = Z0 do j = 1 , n do i = 1 , n call HilbertToLiouvilleIndexes ( i , j , iPair ) RhoMat ( i , j ) = RhoVec ( iPair ) enddo enddo end subroutine LiouvilleToHilbertMatrix ! subroutine HilbertToLiouvilleIndexes ( i , j , iPair ) !! Transforms matrix indices in Hilbert space into a !! single index in Liouville space. The transformation is dependent on the relative values of the !! input indices. The resulting single index is required for the transformation from Hilbert to !! Liouville space. !! integer , intent ( in ) :: i , j !! Integers representing the indices in Hilbert space. integer , intent ( out ) :: iPair !! An integer representing the corresponding single index in Liouville space. if ( i == j ) then iPair = i ** 2 elseif ( i < j ) then iPair = ( j - 1 ) ** 2 + i else iPair = ( i - 1 ) * i + j endif end subroutine HilbertToLiouvilleIndexes ! subroutine LiouvilleToHilbertIndexes ( iPair , i , j ) !! Takes in a single integer index in Liouville space !! and converts it into a pair of matrix indices in Hilbert space. The indices are calculated by !! decomposing the given Liouville index into a square plus a remainder, which are then used to !! calculate the corresponding Hilbert indices. !! integer , intent ( in ) :: iPair !! An integer representing a single index in Liouville space. integer , intent ( out ) :: i , j !! Integers representing the corresponding indices in Hilbert space. ! Intermediate variables to hold the square root and square of iPair integer :: n , n2 ! Calculate the integer square root of iPair n = int ( sqrt ( 1.d0 * iPair )) ! Calculate the square of the integer square root n2 = n ** 2 ! Check if iPair is a perfect square if ( n2 == iPair ) then i = n j = n ! Check if the difference between iPair and n2 is less than or equal to n elseif ( iPair - n2 <= n ) then i = iPair - n2 j = n + 1 ! Otherwise, the difference is greater than n else i = n + 1 j = iPair - n2 - n endif end subroutine LiouvilleToHilbertIndexes !<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ! Called ... rn not going to organize these yet ... figure out what module they go to ! ---------------------------------------------------- subroutine DiagonalizeDipole ( Dmat , EVEC_DX , zUMAT_DX , EVEC_DY , zUMAT_DY , EVEC_DZ , zUMAT_DZ ) !! Purpose: Diagonalizes the dipole matrices in the X, Y, and Z directions. Takes the dipole moment matrix as !! input and computes the diagonalized matrices and their eigenvalues. !! !! Internal Operations: Allocation of matrices, diagonalization using Short_Diag, and assignment of the resultant matrices and eigenvalues. real ( kind ( 1 d0 )), intent ( in ) :: Dmat (:, :, :) !!  Real 3D array representing the dipole moment matrix. complex ( kind ( 1 d0 )), allocatable , intent ( out ) :: zUMAT_DX (:, :), zUMAT_DY (:, :), zUMAT_DZ (:, :) !! Complex 2D arrays for the diagonalized matrices in X, Y, and Z directions, respectively. real ( kind ( 1 d0 )), allocatable , intent ( out ) :: EVEC_DX (:), EVEC_DY (:), EVEC_DZ (:) !! Real 1D arrays for the eigenvalues of the dipoles in X, Y, and Z directions. ! real ( kind ( 1 d0 )), allocatable :: rmat (:, :) integer :: nStates nStates = size ( Dmat , 1 ) allocate ( rmat ( nStates , nStates )) ! !.. X dipole if ( allocated ( zUMAT_DX )) deallocate ( zUMAT_DX ) if ( allocated ( EVEC_DX )) deallocate ( EVEC_DX ) allocate ( zUMAT_DX ( nStates , nStates ), EVEC_DX ( nStates )) rmat = Dmat (:, :, 1 ) EVEC_DX = 0.d0 call Short_Diag ( nStates , rmat , EVEC_DX ) zUMAT_DX = Z1 * rmat ! !.. Y dipole if ( allocated ( zUMAT_DY )) deallocate ( zUMAT_DY ) if ( allocated ( EVEC_DY )) deallocate ( EVEC_DY ) allocate ( zUMAT_DY ( nStates , nStates ), EVEC_DY ( nStates )) rmat = Dmat (:, :, 2 ) EVEC_DY = 0.d0 call Short_Diag ( nStates , rmat , EVEC_DY ) zUMAT_DY = Z1 * rmat ! !.. Z dipole if ( allocated ( zUMAT_DZ )) deallocate ( zUMAT_DZ ) if ( allocated ( EVEC_DZ )) deallocate ( EVEC_DZ ) allocate ( zUMAT_DZ ( nStates , nStates ), EVEC_DZ ( nStates )) rmat = Dmat (:, :, 3 ) EVEC_DZ = 0.d0 call Short_Diag ( nStates , rmat , EVEC_DZ ) zUMAT_DZ = Z1 * rmat ! deallocate ( rmat ) end subroutine DiagonalizeDipole subroutine Computevolume ( nPts , volume , gridv ) integer , intent ( in ) :: nPts real ( kind ( 1 d0 )), intent ( out ) :: volume real ( kind ( 1 d0 )), allocatable , intent ( in ) :: gridv (:, :) real ( kind ( 1 d0 )) :: coord1 , coord2 , delta real ( kind ( 1 d0 )), parameter :: threshold = 1 d - 10 integer :: iPts , iCoord volume = 1.d0 do iCoord = 1 , 3 coord1 = gridv ( iCoord , 1 ) delta = 1 d10 do iPts = 2 , nPts coord2 = gridv ( iCoord , iPts ) if ( abs ( coord1 - coord2 ) > threshold ) then delta = min ( delta , abs ( coord1 - coord2 )) endif enddo volume = volume * delta enddo end subroutine Computevolume subroutine Compute_R_el ( gridv , WeightV , OrbTab , R_el ) real ( kind ( 1 d0 )), allocatable , intent ( in ) :: OrbTab (:, :), gridv (:, :), WeightV (:, :) real ( kind ( 1 d0 )), allocatable , intent ( out ) :: R_el (:, :) real ( kind ( 1 d0 )) :: sum , m , r , sum1 integer :: nAtoms , nPts , number_of_orbitals , iOrb , jOrb , uid nAtoms = size ( WeightV , 2 ) nPts = size ( WeightV , 1 ) number_of_orbitals = size ( OrbTab , 2 ) ! write ( * , \"(a)\" ) \"Computing Barycenters of the Atomic Charges\" ! allocate ( R_el ( 3 , nAtoms )) do iAtom = 1 , nAtoms do iPol = 1 , 3 sum = 0.d0 sum1 = 0.d0 do iOrb = 1 , number_of_orbitals do jOrb = 1 , number_of_orbitals do iPts = 1 , nPts m = WeightV ( iPts , iAtom ) * OrbTab ( iPts , iOrb ) * OrbTab ( iPts , jOrb ) r = gridv ( iPol , iPts ) sum = sum + (( m * r )) sum1 = sum1 + m end do end do end do ! R_el ( iPol , iAtom ) = sum / sum1 end do end do end subroutine Compute_R_el subroutine AtomicRadius_Bragg_Slater_Becke ( atom_names , nAtom , Radius_BS ) real ( kind ( 1 d0 )), allocatable , intent ( out ) :: Radius_BS (:) integer , intent ( in ) :: nAtom character ( len = 16 ), intent ( in ) :: atom_names (:) integer :: iAtom allocate ( Radius_BS ( nAtom )) do iAtom = 1 , nAtom Radius_BS ( iAtom ) = Radius_Table ( atom_names ( iAtom )) end do end subroutine AtomicRadius_Bragg_Slater_Becke subroutine ComputeAtomicCharges ( OrbitalDensity , BeckeMatrix , QchargeVec ) real ( kind ( 1 d0 )), intent ( in ) :: OrbitalDensity (:, :) real ( kind ( 1 d0 )), intent ( in ) :: BeckeMatrix (:, :, :, :) real ( kind ( 1 d0 )), allocatable , intent ( out ) :: QchargeVec (:, :) integer :: iAtom , nAtoms , number_of_orbitals , jOrb , iOrb , iPol real ( kind ( 1 d0 )), external :: DDOT real ( kind ( 1 d0 )) :: dsum number_of_orbitals = size ( BeckeMatrix , 2 ) nAtoms = size ( BeckeMatrix , 4 ) allocate ( QchargeVec ( 3 , nAtoms )) QchargeVec = 0.d0 do iPol = 1 , 3 do iAtom = 1 , nAtoms do jOrb = 1 , number_of_orbitals do iOrb = 1 , number_of_orbitals QchargeVec ( iPol , iAtom ) = QchargeVec ( iPol , iAtom ) + OrbitalDensity ( iOrb , jOrb ) & * BeckeMatrix ( iPol , iOrb , jOrb , iAtom ) end do end do enddo end do end subroutine ComputeAtomicCharges subroutine ComputeOrbitalDensity ( zStatRho , TDM , Amat ) !! Build the expansion Matrix !!   A_{nm}(t) = \\sum_{IJ} P_{IJ}(t) \\rho&#94;{JI}_{nm} !!   where P_{IJ}(t) is the solution of a suitable Master equation, starting from P_{IJ}(0) !!   Here, we will neglect relaxation and decoherence and hence P_{IJ}(t) = P_{IJ}(0) e&#94;{-i\\omega_{IJ}t} !!   where \\omega_{IJ}=E_I-E_J complex ( kind ( 1 d0 )), intent ( in ) :: zStatRho (:, :) real ( kind ( 1 d0 )), intent ( in ) :: TDM (:, :, :, :) real ( kind ( 1 d0 )), allocatable , intent ( out ) :: Amat (:, :) integer :: number_of_orbitals , ii_orb , ij_orb , ii_state , ij_state number_of_orbitals = size ( TDM , 1 ) if ( allocated ( Amat )) then if ( abs ( size ( Amat , 1 ) - number_of_orbitals ) + abs ( size ( Amat , 2 ) - number_of_orbitals ) > 0 ) then deallocate ( Amat ) allocate ( Amat ( number_of_orbitals , number_of_orbitals )) endif else allocate ( Amat ( number_of_orbitals , number_of_orbitals )) endif ! Amat = 0.d0 do ii_orb = 1 , number_of_orbitals do ij_orb = 1 , number_of_orbitals ! do ii_state = 1 , nStates do ij_state = 1 , nStates Amat ( ii_orb , ij_orb ) = Amat ( ii_orb , ij_orb ) + & dble ( zStatRho ( ii_state , ij_state ) * TDM ( ii_orb , ij_orb , ij_state , ii_state )) enddo enddo ! enddo enddo end subroutine ComputeOrbitalDensity subroutine ComputeAtomicWeights ( nPts , gridv , nAtoms , AtCoord , WeightV , Radius_BS ) integer , intent ( in ) :: nPts , nAtoms real ( kind ( 1 d0 )), intent ( in ) :: gridv (:, :), AtCoord (:, :), Radius_BS (:) real ( kind ( 1 d0 )), allocatable , intent ( out ) :: WeightV (:, :) integer , parameter :: k = 4 integer :: iPts , iAtom real ( kind ( 1 d0 )) :: rvec ( 3 ) write ( * , \"(a)\" ) \"Computing Weights\" allocate ( WEIGHTV ( nPts , nAtoms )) !$OMP PARALLEL DO PRIVATE(iPts, rvec, iAtom) do iPts = 1 , nPts rvec = gridv (:, iPts ) do iAtom = 1 , nAtoms WeightV ( iPts , iAtom ) = wkfun ( rvec , iAtom , AtCoord , nAtoms , k , Radius_BS ) enddo enddo !$OMP END PARALLEL DO end subroutine ComputeAtomicWeights subroutine TabulateChargeDensity ( Amat , OrbTab , ChDen ) real ( kind ( 1 d0 )), intent ( in ) :: Amat (:, :) real ( kind ( 1 d0 )), intent ( in ) :: OrbTab (:, :) real ( kind ( 1 d0 )), intent ( out ) :: ChDen (:) integer :: number_of_orbitals , ii_orb , ij_orb number_of_orbitals = size ( OrbTab , 2 ) !.. Tabulate Charge Density ChDen = 0.d0 !$OMP PARALLEL DO PRIVATE(iPts, ii_orb, ij_orb) do iPts = 1 , nPts do ii_orb = 1 , number_of_orbitals do ij_orb = 1 , number_of_orbitals ChDen ( iPts ) = ChDen ( iPts ) + OrbTab ( iPts , ii_orb ) * Amat ( ii_orb , ij_orb ) * OrbTab ( iPts , ij_orb ) enddo enddo enddo !$OMP END PARALLEL DO end subroutine TabulateChargeDensity subroutine ComputeBeckeMatrix ( WeightV , OrbTab , BeckeMatrix , Bary_center ) real ( kind ( 1 d0 )), intent ( in ) :: WeightV (:, :) real ( kind ( 1 d0 )), intent ( in ) :: OrbTab (:, :) real ( kind ( 1 d0 )), allocatable , intent ( out ) :: BeckeMatrix (:, :, :, :) real ( kind ( 1 d0 )), intent ( in ) :: Bary_center (:, :) integer :: nPts , number_of_orbitals , nAtoms integer :: iPts , iOrb1 , iOrb2 , iAtom , iPol real ( kind ( 1 d0 )) :: dsum ! write ( * , \"(a)\" ) \"Computing Becke's Matrix\" ! nAtoms = size ( WeightV , 2 ) nPts = size ( WeightV , 1 ) number_of_orbitals = size ( OrbTab , 2 ) allocate ( BeckeMatrix ( 3 , number_of_orbitals , number_of_orbitals , nAtoms )) BeckeMatrix = 0.d0 !$omp parallel do private(iOrb2, iOrb1, iPts) shared(BeckeMatrix, WeightV, OrbTab, Bary_center) do iPol = 1 , 3 do iAtom = 1 , nAtoms do iOrb2 = 1 , number_of_orbitals do iOrb1 = 1 , number_of_orbitals do iPts = 1 , nPts BeckeMatrix ( iPol , iOrb1 , iOrb2 , iAtom ) = BeckeMatrix ( iPol , iOrb1 , iOrb2 , iAtom ) + & WeightV ( iPts , iAtom ) * OrbTab ( iPts , iOrb1 ) * OrbTab ( iPts , iOrb2 ) * & Bary_center ( iPol , iAtom ) ! fixme???? end do end do end do end do end do !$omp end parallel do end subroutine ComputeBeckeMatrix ! <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< ! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> ! Not used in the code ...? ! ---------------------------------------------------- complex ( kind ( 1 d0 )) function zTraceFunction ( zA ) result ( zTrace ) integer :: i complex ( kind ( 1 d0 )), intent ( in ) :: zA (:, :) zTrace = 0.d0 do i = 1 , size ( zA , 1 ) zTrace = zTrace + zA ( i , i ) enddo end function zTraceFunction ! <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< end program ChargeMigration","tags":"","loc":"sourcefile/main.f90.html"},{"title":"Module_Becke.f90 – Charge Migration","text":"Source Code Module Module_Becke use , intrinsic :: ISO_FORTRAN_ENV implicit none private logical :: Verbous public :: & EuclDist , & EllipticalCoord , & Radius_Table , & get_param_a , & new_mu_transformation , & fkfun , & skfun , & skfunab , & Pkfuna , & PkFunTot , & wkfun contains ! >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> !! This code is a Fortran implementation of the Becke partitioning scheme based on the following papers: !! !! H. Gharibnejad, N. Douguet, B.I. Schneider, J. Olsen, L. Argenti, !!  A multi-center quadrature scheme for the molecular continuum, !!  Computer Physics Communications, Volume 263, 2021, 107889, ISSN 0010-4655, !!  https://doi.org/10.1016/j.cpc.2021.107889. !! !! and !! !! A. D. Becke; A multicenter numerical integration scheme for polyatomic molecules. !!  J. Chem. Phys. 15 February 1988; 88 (4): 2547–2553. https://doi.org/10.1063/1.454033 !! !! ---------------------------------------------------- !!Result = P_a(\\vec{r})/\\sum_bP_b(\\vec{r})  !! ---------------------------------------------------- !! !! Quick Notes: !! !!Radius_Table: Given the name of an atom, returns its atomic radius. Only supports H, C, N, O, and Mg. !! !!get_param_a: Given two radii R_i and R_j, returns a transformed parameter a_ij. If the absolute value of a_{ij} is greater than 0.5, it's set to 0.5. !! !!new_mu_transformation: Returns a new mu parameter, given the original mu and a_{ij}. !! !!wkfun: Calculates a weighted function for atom i. !! !!PkFunTot: Sums up the function Pkfuna over all atoms. !! !!Pkfuna: Calculates a product of skfunab over all atoms excluding atom i. !! !!skfunab: Transforms an elliptical coordinate to a new mu, then returns the result of skfun with this new mu. !! !!skfun: Transforms a mu parameter into a step function. !! !!fkfun: Recursively calculates a function of mu. !! !!EllipticalCoord: Given coordinates rvec, avec, and bvec, calculates an elliptical coordinate. !! !!EuclDist: Given two points in space, calculates their Euclidean distance. !! !!The main considerations: !!This code does not handle the case where the input atomic name does not match one of the provided options in Radius_Table. This could lead to an error or unexpected behavior. !!The recursion in fkfun does not seem to have a base case when k is less than 1, which could potentially lead to a stack overflow error. !!There are no checks for zero or negative distances in EuclDist which might cause issues if not handled properly upstream. !!The input values are not validated for possible errors. Adding error handling and input validation could make the code more robust. !!The functions are tightly coupled, which might make modifications and debugging more difficult. !.. Euclidean distance real ( kind ( 1 d0 )) function EuclDist ( avec , bvec ) result ( res ) !! This function calculates the Euclidean distance between two points in 3D space. The inputs are two 3-component vectors representing the coordinates of the points, and the output is a scalar representing the distance between them. real ( kind ( 1 d0 )), intent ( in ) :: avec ( 3 ), bvec ( 3 ) real ( kind ( 1 d0 )) :: cvec ( 3 ) cvec = ( avec - bvec ) res = sqrt ( sum ( cvec * cvec )) end function EuclDist ! ---------------------------------------------------- !.. Elliptical coordinate real ( kind ( 1 d0 )) function EllipticalCoord ( rvec , avec , bvec ) result ( res ) !! Eq. 1  \\mu_{ab}(\\vec{r})  !! This function calculates the elliptical coordinate (\\mu_{ab}) of a point relative to two other points (defined as atoms 'a' and 'b'). This coordinate is a measure of how much closer the point is to atom 'a' compared to atom 'b'. real ( kind ( 1 d0 )), intent ( in ) :: rvec ( 3 ), avec ( 3 ), bvec ( 3 ) real ( kind ( 1 d0 )) :: r_a , r_b , R_ab ! $r_a$, $r_b$, $R_ab$ r_a = EuclDist ( rvec , avec ) r_b = EuclDist ( rvec , bvec ) R_ab = EuclDist ( avec , bvec ) res = ( r_a - r_b ) / R_ab end function EllipticalCoord ! ---------------------------------------------------- !..Radius_Table real ( kind ( 1 d0 )) function Radius_Table ( Atomic_Name ) result ( Atomic_Radius ) !!Radius_Table for atomic radius based on atomic name !!This function provides the atomic radius based on the atomic name. The input is a string representing the atomic name and the output is the corresponding atomic radius. This is useful for defining the size of atoms in molecular modelling. character ( len = 16 ), intent ( in ) :: Atomic_Name if ( Atomic_Name == \"H\" ) then Atomic_Radius = 0.35 elseif ( Atomic_Name == \"C\" ) then Atomic_Radius = 0.70 elseif ( Atomic_Name == \"N\" ) then Atomic_Radius = 0.65 elseif ( Atomic_Name == \"O\" ) then Atomic_Radius = 0.60 elseif ( Atomic_Name == \"Mg\" ) then Atomic_Radius = 1.50 end if end function Radius_Table ! ---------------------------------------------------- !..get_param_aij real ( kind ( 1 d0 )) function get_param_a ( R_i , R_j ) result ( a_ij ) !! This function calculates the parameter 'a' (a_{ij}) which depends on the radii of two atoms. This parameter is used in the transformation of the elliptical coordinate. real ( kind ( 1 d0 )), intent ( in ) :: R_i , R_j real ( kind ( 1 d0 )) :: Chi Chi = R_i / R_j a_ij = ( Chi - 1 ) / ( Chi + 1 ) if ( abs ( a_ij ) > ( 0.5d0 )) then a_ij = 0.5d0 endif end function get_param_a ! ---------------------------------------------------- !..new_mu_transformation real ( kind ( 1 d0 )) function new_mu_transformation ( mu , a_ij ) result ( res ) !! This function transforms the elliptical coordinate using the parameter 'a' (a_{ij}). This transformation is used to handle cases where the point is much closer to one atom than the other. real ( kind ( 1 d0 )), intent ( in ) :: mu , a_ij res = mu + a_ij * ( 1 - mu ** 2 ) end function new_mu_transformation ! ---------------------------------------------------- real ( kind ( 1 d0 )) recursive function fkfun ( mu , k ) result ( res ) !! Eq. 4 Recursive   f_k(\\mu)  !! This function calculates a recursive function of the transformed elliptical coordinate. The output of this function will be used in the calculation of the step function skfun. implicit none real ( kind ( 1 d0 )), intent ( in ) :: mu integer , intent ( in ) :: k res = 0.5d0 * mu * ( 3.d0 - mu ** 2 ) if ( k == 1 ) return res = fkfun ( res , k - 1 ) end function fkfun ! ---------------------------------------------------- real ( kind ( 1 d0 )) function skfun ( mu , k ) result ( res ) !!  s(\\mu): [-1,1]  \\rightarrow [0,1]   (Step Function) !! This function calculates a step function of the transformed elliptical coordinate. This function maps the transformed elliptical coordinate from the range [-1,1] to [0,1]. implicit none real ( kind ( 1 d0 )), intent ( in ) :: mu integer , intent ( in ) :: k real ( kind ( 1 d0 )) :: r_m res = 0.5d0 * ( 1.d0 - fkfun ( mu , k )) end function skfun ! ---------------------------------------------------- real ( kind ( 1 d0 )) function skfunab ( rvec , avec , bvec , k , a_ij ) result ( res ) !! This function combines the calculations of the transformed elliptical coordinate and the step function. The output of this function will be used in the calculation of the partial partition function Pkfuna. real ( kind ( 1 d0 )), intent ( in ) :: rvec ( 3 ), avec ( 3 ), bvec ( 3 ) integer , intent ( in ) :: k real ( kind ( 1 d0 )) :: mu_old , mu_new , a_ij mu_old = EllipticalCoord ( rvec , avec , bvec ) mu_new = new_mu_transformation ( mu_old , a_ij ) res = skfun ( mu_new , k ) end function skfunab ! ---------------------------------------------------- real ( kind ( 1 d0 )) function Pkfuna ( rvec , iAtom , AtCoord , nAtoms , k , Radius_BS ) result ( res ) !! Eq. 2   P_a(\\vec{r}) , nominator of Eq. 3 !! This function calculates the partial partition function for a specific atom. The output of this function represents the contribution of a specific atom to the total partition function. integer , intent ( in ) :: nAtoms , iAtom real ( kind ( 1 d0 )), intent ( in ) :: rvec ( 3 ), AtCoord ( 3 , nAtoms ), Radius_BS (:) integer , intent ( in ) :: k integer :: jAtom real ( kind ( 1 d0 )) :: a_ij , R_i , R_j res = 1.d0 !$OMP PARALLEL DO REDUCTION(*:res) PRIVATE(jAtom, R_i, R_j, a_ij) do jAtom = 1 , nAtoms if ( jAtom == iAtom ) cycle R_i = Radius_BS ( iAtom ) R_j = Radius_BS ( jAtom ) a_ij = get_param_a ( R_i , R_j ) res = res * skfunab ( rvec , AtCoord (:, iAtom ), AtCoord (:, jAtom ), k , a_ij ) end do !$OMP END PARALLEL DO end function Pkfuna ! ---------------------------------------------------- real ( kind ( 1 d0 )) function PkFunTot ( rvec , AtCoord , nAtoms , k , Radius_BS ) result ( res ) !! Eq. 3  \\sum_bP_b(\\vec{r})  in the denominator !! This function calculates the total partition function. This is done by summing the partial partition functions for all atoms. integer , intent ( in ) :: nAtoms real ( kind ( 1 d0 )), intent ( in ) :: rvec ( 3 ), AtCoord ( 3 , nAtoms ), Radius_BS (:) integer , intent ( in ) :: k integer :: iAtom res = 0.d0 !$OMP PARALLEL DO REDUCTION(+:res) PRIVATE(iAtom) do iAtom = 1 , nAtoms res = res + Pkfuna ( rvec , iAtom , AtCoord , nAtoms , k , Radius_BS ) end do !$OMP END PARALLEL DO end function PkFunTot ! ---------------------------------------------------- real ( kind ( 1 d0 )) function wkfun ( rvec , iAtom , AtCoord , nAtoms , k , Radius_BS ) result ( res ) !! Eq. 3 $w_a \\vec(r)$  (WEIGHTS) !! This function calculates the weight of an atom. The weight is defined as the ratio of the partial partition function of the atom to the total partition function. This weight represents the relative importance of the atom. integer , intent ( in ) :: iAtom , k , nAtoms real ( kind ( 1 d0 )), intent ( in ) :: rvec ( 3 ), AtCoord ( 3 , nAtoms ), Radius_BS (:) ! res = Pkfuna ( rvec , iAtom , AtCoord , nAtoms , k , Radius_BS ) / PkfunTot ( rvec , AtCoord , nAtoms , k , Radius_BS ) end function wkfun ! ---------------------------------------------------- ! <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< End Module Module_Becke","tags":"","loc":"sourcefile/module_becke.f90.html"}]}
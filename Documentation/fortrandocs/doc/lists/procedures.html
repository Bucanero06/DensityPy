<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta name="description" content="Documentation for Charge Migration">
    <meta name="author" content="" >
    <link rel="icon" href="../favicon.png">

    <title>All Procedures &ndash; Charge Migration
</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
          integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
      <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">

    <script src="https://code.jquery.com/jquery-3.7.0.slim.min.js" integrity="sha256-tG5mcZUtJsZvyKAxYLVXrmjKBVLd6VpVccqz/r4ypFE=" crossorigin="anonymous"></script>
  </head>

  <body>

    <!-- Fixed navbar -->
    <div class="container-fluid mb-sm-4 mb-xl-2">
      <nav class="navbar navbar-expand-lg navbar-dark bg-dark fixed-top">
        <div class="container">
          <a class="navbar-brand" href="../index.html">Charge Migration </a>
          <button type="button" class="navbar-toggler" data-bs-toggle="collapse" data-bs-target="#navbar"
                  aria-expanded="false" aria-controls="navbar" aria-label="Toggle navigation">
                  <span class="navbar-toggler-icon">
          </button>

          <div id="navbar" class="navbar-collapse collapse">
            <ul class="navbar-nav">
                  <li class="nav-item">
                    <a class="nav-link" href="../lists/files.html">Source Files</a>
                  </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/modules.html">Modules</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../lists/procedures.html">Procedures</a>
                </li>
                <li class="nav-item">
                  <a class="nav-link" href="../program/chargemigration.html">Program</a>
                </li>
            </ul>
              <div class="d-flex align-items-end flex-grow-1">
                <form action="../search.html" role="search" class="ms-auto">
                  <input type="text" class="form-control" aria-label="Search" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
                </form>
              </div>
          </div><!--/.nav-collapse -->
        </div>
      </nav>
    </div>

    <div class="container">
      <div class="row">
        <div class="col-lg-12" id='text'>
			 <h1>Procedures</h1>
			 <table class="table table-striped">
			 <thead><tr><th>Procedure</th><th>Location</th><th>Procedure Type</th><th>Description</th></tr></thead>
			 <tbody>
			   <tr><td><a href='../proc/atomicradius_bragg_slater_becke.html'>AtomicRadius_Bragg_Slater_Becke</a></td><td><a href='../program/chargemigration.html'>ChargeMigration</a></td><td>Subroutine</td><td></td></tr>
			   <tr><td><a href='../proc/compute_r_el.html'>Compute_R_el</a></td><td><a href='../program/chargemigration.html'>ChargeMigration</a></td><td>Subroutine</td><td></td></tr>
			   <tr><td><a href='../proc/computeatomiccharges.html'>ComputeAtomicCharges</a></td><td><a href='../program/chargemigration.html'>ChargeMigration</a></td><td>Subroutine</td><td></td></tr>
			   <tr><td><a href='../proc/computeatomicweights.html'>ComputeAtomicWeights</a></td><td><a href='../program/chargemigration.html'>ChargeMigration</a></td><td>Subroutine</td><td></td></tr>
			   <tr><td><a href='../proc/computebeckematrix.html'>ComputeBeckeMatrix</a></td><td><a href='../program/chargemigration.html'>ChargeMigration</a></td><td>Subroutine</td><td></td></tr>
			   <tr><td><a href='../proc/computeliouvillian_0.html'>ComputeLiouvillian_0</a></td><td><a href='../program/chargemigration.html'>ChargeMigration</a></td><td>Subroutine</td><td><p>Calculates the time-independent Lindblad superoperator (Liouvillian), a crucial element in the Lindblad master equation, used for describing the time evolution of the density matrix of a quantum system in an open quantum system framework.</p><a href="../proc/computeliouvillian_0.html" class="pull-right"><emph>Read more&hellip;</emph></a></td></tr>
			   <tr><td><a href='../proc/computeorbitaldensity.html'>ComputeOrbitalDensity</a></td><td><a href='../program/chargemigration.html'>ChargeMigration</a></td><td>Subroutine</td><td><p>Build the expansion Matrix
  <script type="math/tex; mode=display">A_{nm}(t) = \sum_{IJ} P_{IJ}(t) \rho^{JI}_{nm}</script>
  where <script type="math/tex">P_{IJ}(t)</script> is the solution of a suitable Master equation, starting from <script type="math/tex">P_{IJ}(0)</script>
  Here, we will neglect relaxation and decoherence and hence <script type="math/tex">P_{IJ}(t) = P_{IJ}(0) e^{-i\omega_{IJ}t}</script>
  where <script type="math/tex">\omega_{IJ}=E_I-E_J</script>
</p></td></tr>
			   <tr><td><a href='../proc/computevolume.html'>Computevolume</a></td><td><a href='../program/chargemigration.html'>ChargeMigration</a></td><td>Subroutine</td><td></td></tr>
			   <tr><td><a href='../proc/diagonalizedipole.html'>DiagonalizeDipole</a></td><td><a href='../program/chargemigration.html'>ChargeMigration</a></td><td>Subroutine</td><td><p>input and computes the diagonalized matrices and their eigenvalues.</p><a href="../proc/diagonalizedipole.html" class="pull-right"><emph>Read more&hellip;</emph></a></td></tr>
			   <tr><td><a href='../proc/diagonalizelindblad_0.html'>DiagonalizeLindblad_0</a></td><td><a href='../program/chargemigration.html'>ChargeMigration</a></td><td>Subroutine</td><td><p>Performs the diagonalization of the time-independent
Lindblad superoperator (Liouvillian0). The diagonalization is performed using the
Short_Diag subroutine, and the results are printed to the standard output.
This routine also checks that the product of right and conjugate transpose of left eigenvectors
is an identity matrix (a necessary condition for a valid diagonalization).</p><a href="../proc/diagonalizelindblad_0.html" class="pull-right"><emph>Read more&hellip;</emph></a></td></tr>
			   <tr><td><a href='../proc/ellipticalcoord.html'>EllipticalCoord</a></td><td><a href='../module/module_becke.html'>Module_Becke</a></td><td>Function</td><td><p>Eq. 1 <script type="math/tex"> \mu_{ab}(\vec{r}) </script>
This function calculates the elliptical coordinate (<script type="math/tex">\mu_{ab}</script>) of a point relative to two other points (defined as atoms 'a' and 'b'). This coordinate is a measure of how much closer the point is to atom 'a' compared to atom 'b'.</p></td></tr>
			   <tr><td><a href='../proc/eucldist.html'>EuclDist</a></td><td><a href='../module/module_becke.html'>Module_Becke</a></td><td>Function</td><td><p>This function calculates the Euclidean distance between two points in 3D space. The inputs are two 3-component vectors representing the coordinates of the points, and the output is a scalar representing the distance between them.</p></td></tr>
			   <tr><td><a href='../proc/fkfun.html'>fkfun</a></td><td><a href='../module/module_becke.html'>Module_Becke</a></td><td>Function</td><td><p>Eq. 4 Recursive  <script type="math/tex"> f_k(\mu) </script>
This function calculates a recursive function of the transformed elliptical coordinate. The output of this function will be used in the calculation of the step function skfun.</p></td></tr>
			   <tr><td><a href='../proc/get_param_a.html'>get_param_a</a></td><td><a href='../module/module_becke.html'>Module_Becke</a></td><td>Function</td><td><p>This function calculates the parameter 'a' (<script type="math/tex">a_{ij}</script>) which depends on the radii of two atoms. This parameter is used in the transformation of the elliptical coordinate.</p></td></tr>
			   <tr><td><a href='../proc/getruntimeparameters.html'>GetRunTimeParameters</a></td><td><a href='../module/module_cm_rtp.html'>Module_CM_RTP</a></td><td>Subroutine</td><td><p>Reads the run time parameters specified in the command line.</p></td></tr>
			   <tr><td><a href='../proc/hilberttoliouvilleindexes.html'>HilbertToLiouvilleIndexes</a></td><td><a href='../program/chargemigration.html'>ChargeMigration</a></td><td>Subroutine</td><td><p>Transforms matrix indices in Hilbert space into a
single index in Liouville space. The transformation is dependent on the relative values of the
input indices. The resulting single index is required for the transformation from Hilbert to
Liouville space.</p></td></tr>
			   <tr><td><a href='../proc/hilberttoliouvillematrix.html'>HilbertToLiouvilleMatrix</a></td><td><a href='../program/chargemigration.html'>ChargeMigration</a></td><td>Subroutine</td><td><p>Transforms a matrix from Hilbert space into a vector
in Liouville space. The transformation is performed by looping through each element of the input
matrix and mapping it to the corresponding position in the output vector using the subroutine
HilbertToLiouvilleIndexes. This transformation is required for the application of the Liouville operator.</p></td></tr>
			   <tr><td><a href='../proc/liouvilletohilbertindexes.html'>LiouvilleToHilbertIndexes</a></td><td><a href='../program/chargemigration.html'>ChargeMigration</a></td><td>Subroutine</td><td><p>Takes in a single integer index in Liouville space
and converts it into a pair of matrix indices in Hilbert space. The indices are calculated by
decomposing the given Liouville index into a square plus a remainder, which are then used to
calculate the corresponding Hilbert indices.</p></td></tr>
			   <tr><td><a href='../proc/liouvilletohilbertmatrix.html'>LiouvilleToHilbertMatrix</a></td><td><a href='../program/chargemigration.html'>ChargeMigration</a></td><td>Subroutine</td><td><p>Performs the inverse transformation of
HilbertToLiouvilleMatrix, transforming a vector in Liouville space back into a matrix in
Hilbert space. The transformation is performed by looping through each element of the output matrix
and assigning it the corresponding value from the input vector using the subroutine
HilbertToLiouvilleIndexes.</p></td></tr>
			   <tr><td><a href='../proc/liouvillianpropagator.html'>LiouvillianPropagator</a></td><td><a href='../program/chargemigration.html'>ChargeMigration</a></td><td>Subroutine</td><td><p>The central routine in simulating the dynamics of a quantum system subject to an external field, describing the time evolution of the system in Liouville space.
 Build the time-independent Lindblad superoperator
 <script type="math/tex; mode=display">\begin{equation}
\dot{\rho}(t) = -i[H, \rho(t)] + \sum_{mn} \Bigl( L_{mn} \rho(t) L_{mn}^\dagger - \frac{1}{2} L_{mn}^\dagger L_{mn} \rho(t) - \frac{1}{2} \rho(t) L_{mn}^\dagger L_{mn} \Bigr)
\end{equation}</script>
</p><a href="../proc/liouvillianpropagator.html" class="pull-right"><emph>Read more&hellip;</emph></a></td></tr>
			   <tr><td><a href='../proc/loaddipoleme.html'>LoadDipoleME</a></td><td><a href='../module/module_cm_cd_io.html'>Module_CM_CD_IO</a></td><td>Subroutine</td><td><p>Loads all the Dipoles found inside the input_directory</p></td></tr>
			   <tr><td><a href='../proc/loaddipolemo.html'>LoadDipoleMO</a></td><td><a href='../module/module_cm_cd_io.html'>Module_CM_CD_IO</a></td><td>Subroutine</td><td><p>Loads Dipole Matrix Elements between molecular orbitals
IDEALLY, SHOULD COMPUTE THE DIPOLE FROM THE AO - AO DIPOLES.</p></td></tr>
			   <tr><td><a href='../proc/loadenergies.html'>LoadEnergies</a></td><td><a href='../module/module_cm_cd_io.html'>Module_CM_CD_IO</a></td><td>Subroutine</td><td><p>Loads the Energies found inside the input_directory</p></td></tr>
			   <tr><td><a href='../proc/loadgeometry.html'>LoadGeometry</a></td><td><a href='../module/module_cm_cd_io.html'>Module_CM_CD_IO</a></td><td>Subroutine</td><td><p>Load Subroutines &lt;&lt;!
 Load the position of the atomic nuclei</p><a href="../proc/loadgeometry.html" class="pull-right"><emph>Read more&hellip;</emph></a></td></tr>
			   <tr><td><a href='../proc/loadgrid.html'>LoadGrid</a></td><td><a href='../module/module_cm_cd_io.html'>Module_CM_CD_IO</a></td><td>Subroutine</td><td><p>Loads the Grid found inside the input_directory</p></td></tr>
			   <tr><td><a href='../proc/loadorbitals.html'>LoadOrbitals</a></td><td><a href='../module/module_cm_cd_io.html'>Module_CM_CD_IO</a></td><td>Subroutine</td><td><p>Loads the Orbitals found inside the input_directory
Loads the Orbitals from the grid_density.csv file inside the input_directory</p></td></tr>
			   <tr><td><a href='../proc/loadtdms.html'>LoadTDMs</a></td><td><a href='../module/module_cm_cd_io.html'>Module_CM_CD_IO</a></td><td>Subroutine</td><td><p>Loads the TDM found inside the input_directory</p></td></tr>
			   <tr><td><a href='../proc/new_mu_transformation.html'>new_mu_transformation</a></td><td><a href='../module/module_becke.html'>Module_Becke</a></td><td>Function</td><td><p>This function transforms the elliptical coordinate using the parameter 'a' (<script type="math/tex">a_{ij}</script>). This transformation is used to handle cases where the point is much closer to one atom than the other.</p></td></tr>
			   <tr><td><a href='../proc/pkfuna.html'>Pkfuna</a></td><td><a href='../module/module_becke.html'>Module_Becke</a></td><td>Function</td><td><p>Eq. 2  <script type="math/tex"> P_a(\vec{r}) </script>, nominator of Eq. 3
This function calculates the partial partition function for a specific atom. The output of this function represents the contribution of a specific atom to the total partition function.</p></td></tr>
			   <tr><td><a href='../proc/pkfuntot.html'>PkFunTot</a></td><td><a href='../module/module_becke.html'>Module_Becke</a></td><td>Function</td><td><p>Eq. 3 <script type="math/tex"> \sum_bP_b(\vec{r}) </script> in the denominator
This function calculates the total partition function. This is done by summing the partial partition functions for all atoms.</p></td></tr>
			   <tr><td><a href='../proc/radius_table.html'>Radius_Table</a></td><td><a href='../module/module_becke.html'>Module_Becke</a></td><td>Function</td><td><p>Radius_Table for atomic radius based on atomic name
This function provides the atomic radius based on the atomic name. The input is a string representing the atomic name and the output is the corresponding atomic radius. This is useful for defining the size of atoms in molecular modelling.</p></td></tr>
			   <tr><td><a href='../proc/read_weights.html'>Read_Weights</a></td><td><a href='../module/module_cm_cd_io.html'>Module_CM_CD_IO</a></td><td>Subroutine</td><td><p>Read Weights Subroutine</p></td></tr>
			   <tr><td><a href='../proc/set_cd_io_verbous.html'>Set_CD_IO_Verbous</a></td><td><a href='../module/module_cm_cd_io.html'>Module_CM_CD_IO</a></td><td>Subroutine</td><td><p>Commons &lt;&lt;!</p><a href="../proc/set_cd_io_verbous.html" class="pull-right"><emph>Read more&hellip;</emph></a></td></tr>
			   <tr><td><a href='../proc/skfun.html'>skfun</a></td><td><a href='../module/module_becke.html'>Module_Becke</a></td><td>Function</td><td><p>
<script type="math/tex"> s(\mu): [-1,1]  \rightarrow [0,1] </script>  (Step Function)
This function calculates a step function of the transformed elliptical coordinate. This function maps the transformed elliptical coordinate from the range [-1,1] to [0,1].</p></td></tr>
			   <tr><td><a href='../proc/skfunab.html'>skfunab</a></td><td><a href='../module/module_becke.html'>Module_Becke</a></td><td>Function</td><td><p>This function combines the calculations of the transformed elliptical coordinate and the step function. The output of this function will be used in the calculation of the partial partition function Pkfuna.</p></td></tr>
			   <tr><td><a href='../proc/tabulatechargedensity.html'>TabulateChargeDensity</a></td><td><a href='../program/chargemigration.html'>ChargeMigration</a></td><td>Subroutine</td><td></td></tr>
			   <tr><td><a href='../proc/wkfun.html'>wkfun</a></td><td><a href='../module/module_becke.html'>Module_Becke</a></td><td>Function</td><td><p>Eq. 3 $w_a \vec(r)$  (WEIGHTS)
This function calculates the weight of an atom. The weight is defined as the ratio of the partial partition function of the atom to the total partition function. This weight represents the relative importance of the atom.</p></td></tr>
			   <tr><td><a href='../proc/write_charge_density.html'>Write_Charge_Density</a></td><td><a href='../module/module_cm_cd_io.html'>Module_CM_CD_IO</a></td><td>Subroutine</td><td></td></tr>
			   <tr><td><a href='../proc/write_dipole.html'>Write_Dipole</a></td><td><a href='../module/module_cm_cd_io.html'>Module_CM_CD_IO</a></td><td>Subroutine</td><td></td></tr>
			   <tr><td><a href='../proc/write_q_charge.html'>Write_Q_Charge</a></td><td><a href='../module/module_cm_cd_io.html'>Module_CM_CD_IO</a></td><td>Subroutine</td><td></td></tr>
			   <tr><td><a href='../proc/write_r_el_bc.html'>Write_R_el_bc</a></td><td><a href='../module/module_cm_cd_io.html'>Module_CM_CD_IO</a></td><td>Subroutine</td><td><p>Save Subroutines</p><a href="../proc/write_r_el_bc.html" class="pull-right"><emph>Read more&hellip;</emph></a></td></tr>
			   <tr><td><a href='../proc/write_summary.html'>Write_Summary</a></td><td><a href='../module/module_cm_cd_io.html'>Module_CM_CD_IO</a></td><td>Subroutine</td><td></td></tr>
			   <tr><td><a href='../proc/write_weights.html'>Write_Weights</a></td><td><a href='../module/module_cm_cd_io.html'>Module_CM_CD_IO</a></td><td>Subroutine</td><td><p>Write Weights Subroutine</p></td></tr>
			   <tr><td><a href='../proc/ztracefunction.html'>zTraceFunction</a></td><td><a href='../program/chargemigration.html'>ChargeMigration</a></td><td>Function</td><td></td></tr>
			 </tbody></table>
             
        </div>
      </div>
      <hr>
    </div> <!-- /container -->
    <footer>
      <div class="container">
        <div class="row justify-content-between">
          <div class="col"><p>Charge Migration was developed by <br>&copy; 2023 
</p>
          </div>
          <div class="col">
            <p class="text-end">
              Documentation generated by
              <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
            </p>
          </div>
        </div>
        <br>
      </div> <!-- /container -->
    </footer>

    <!-- Bootstrap core JavaScript -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"
            integrity="sha384-ka7Sk0Gln4gmtz2MlQnikT1wXgYsOg+OMhuP+IlRH9sENBO0LRn5q+8nbTov4+1p" crossorigin="anonymous"></script>    

    <!-- MathJax JavaScript
             ================================================== -->
             <!-- Placed at the end of the document so the pages load faster -->
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
          TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
          jax: ['input/TeX','input/MathML','output/HTML-CSS'],
          extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
          });
        </script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

          <script src="../tipuesearch/tipuesearch_content.js"></script>
          <script src="../tipuesearch/tipuesearch_set.js"></script>
          <script src="../tipuesearch/tipuesearch.js"></script>

  </body>
</html>